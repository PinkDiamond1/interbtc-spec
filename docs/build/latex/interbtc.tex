%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Introduction}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{interbtc Documentation: interbtc}
\date{Jul 02, 2021}
\release{}
\author{Interlay}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxadmonition}{note}{Note:}
Please note that this specification is a living document. The actual implementation might deviate from the specification. In case of deviations in the code, the code has priority over the specification.
\end{sphinxadmonition}


\chapter{BTC Parachain at a Glance}
\label{\detokenize{intro/at-a-glance:btc-parachain-at-a-glance}}\label{\detokenize{intro/at-a-glance::doc}}
The \sphinxstyleemphasis{BTC Parachain} connects the Polkadot ecosystem with Bitcoin.
It allows the creation of \sphinxstyleemphasis{interbtc}, a fungible token that represents Bitcoin in the Polkadot ecosystem.
interbtc is backed by Bitcoin 1:1 and allows redeeming of the equivalent amount of Bitcoins by relying on a collateralized third\sphinxhyphen{}party.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{overview}.png}
\caption{The BTC Parachain allows the creation of collateralized 1:1 Bitcoin\sphinxhyphen{}backed tokens in Polkadot. These tokens can be transfered and traded within the Polkadot ecosystem.}\label{\detokenize{intro/at-a-glance:id1}}\end{figure}


\section{Functionality}
\label{\detokenize{intro/at-a-glance:functionality}}
On a high\sphinxhyphen{}level, the BTC Parachain enables the issuing and redeeming of interbtc.
The \sphinxstyleemphasis{issue process} allows a user to lock Bitcoin on the Bitcoin chain and, in return, issue interbtc on the BTC Parachain.
Consequently, the \sphinxstyleemphasis{redeem process} allows a user to burn interbtc on the BTC Parachain and redeem previously locked Bitcoins on Bitcoin.
Users can trade interbtc on the BTC Parachain and, through the Relay Chain, in other Parachains as well.
The issue and redeem process can be executed by different users.
Typically, this process is augmented by a collateralized realized third\sphinxhyphen{}party, a so\sphinxhyphen{}called \sphinxstyleemphasis{vault}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Overview-Func}.png}
\caption{The BTC Parachain includes a protocol to issue interbtc by locking Bitcoin and a protocol to redeem Bitcoin by burning interbtc tokens.}\label{\detokenize{intro/at-a-glance:id2}}\end{figure}


\section{Components}
\label{\detokenize{intro/at-a-glance:components}}
The BTC Parachain makes use of two main components to achieve issuing and redeeming of interbtc:
\begin{itemize}
\item {} 
\sphinxstylestrong{XCLAIM(BTC,DOT)}: The XCLAIM(BTC,DOT) component implements four protocols including issue, transfer, redeem, and replace. It maintains the interbtc tokens, i.e. who owns how many tokens and manages the vaults as well as the collateral in the system.

\item {} 
\sphinxstylestrong{BTC\sphinxhyphen{}Relay}: The BTC\sphinxhyphen{}Relay component is used to verify that certain transactions have happened on the Bitcoin blockchain. For example, when a user issues a new interbtc an equivalent amount of Bitcoins needs to be locked on the Bitcoin chain. The user can prove this to the interbtc component by verifying his transaction in the BTC\sphinxhyphen{}Relay component.

\end{itemize}

The figure below describes the relationships between the components in a high level. Please note that we use a simplified model here, where users are the ones augmenting the issue and redeem process. In practice, this is executed by the collateralized vaults.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Overview-Components}.png}
\caption{The BTC Parachain consists of two logically different components. The XCLAIM(BTC,DOT) component (in green) maintains the accounts that own interbtc tokens. The BTC\sphinxhyphen{}Relay (blue) is repsonible for verifying the Bitcoin state to verify transactions. Users (in purple) are able to create new interbtc by locking BTC on the Bitcoin chain and redeeming BTC by burning interbtc. Also, users can trade interbtc on the BTC Parachain and in the wider Polkadot ecosystem.}\label{\detokenize{intro/at-a-glance:id3}}\end{figure}


\chapter{Cryptocurrency\sphinxhyphen{}backed Assets}
\label{\detokenize{intro/CbA:cryptocurrency-backed-assets}}\label{\detokenize{intro/CbA::doc}}
Building trustless cross\sphinxhyphen{}blockchain trading protocols is challenging.
Centralized exchanges thus remain the preferred route to executing transfers across blockchains.
However, these services require trust and therefore undermine the very nature of the blockchains on which they operate.
To overcome this, several decentralized exchanges have recently emerged which offer support for \sphinxstyleemphasis{commit\sphinxhyphen{}reveal} atomic cross\sphinxhyphen{}chain swaps (ACCS).

Commit\sphinxhyphen{}reveal ACCS, most notably based on \sphinxhref{https://en.bitcoin.it/wiki/Hashed\_Timelock\_Contracts}{HTCLs}, enable the trustless exchange of cryptocurrencies across blockchains.
To this date, this is the only mechanism to have been deployed in production.
However, commit\sphinxhyphen{}reveal ACCS face numerous challenges:
\begin{itemize}
\item {} 
\sphinxstylestrong{Long waiting times:} Each commit\sphinxhyphen{}reveal ACCS requires multiple transactions to occur on all
involved blockchains (commitments and revealing of secrets).

\item {} 
\sphinxstylestrong{High costs:} Publishing multiple transaction per swap results in high fees to maintain such a system.

\item {} 
\sphinxstylestrong{Strict online requirements:} Both parties must be online during the ACCS. Otherwise, the trade fails or, in the worst case, \sphinxstyleemphasis{loss of funds is possible}.

\item {} 
\sphinxstylestrong{Out\sphinxhyphen{}of\sphinxhyphen{}band channels:} Secure operation requires users to exchange additional data \sphinxstyleemphasis{off\sphinxhyphen{}chain} (revocation commitments).

\item {} 
\sphinxstylestrong{Race conditions:} Commit\sphinxhyphen{}reveal ACCS use time\sphinxhyphen{}locks to ensure security. Synchronizing time across
blockchains, however, is challenging and opens up risks to race conditions.

\item {} 
\sphinxstylestrong{Inefficiency:} Finally, commit\sphinxhyphen{}reveal ACCS are \sphinxstyleemphasis{one\sphinxhyphen{}time}. That is, all of the above challenges are faced with each and every trade.

\end{itemize}

Commit\sphinxhyphen{}reveal ACCS have been around since 2012. The practical challenges explain their limited use in practice.


\section{Cryptocurrency\sphinxhyphen{}back Assets (CbA)}
\label{\detokenize{intro/CbA:cryptocurrency-back-assets-cba}}
The idea of CbAs is that an asset is locked on a \sphinxstyleemphasis{backing blockchain} and issued 1:1 on an \sphinxstyleemphasis{issuing blockchain}. CbA that minimize trust in a third\sphinxhyphen{}party are based on the \sphinxhref{https://www.xclaim.io/}{XCLAIM protocol}. The third parties in XCLAIM are called \sphinxstyleemphasis{vaults} and are required to lock collateral as an insurance against misbehaviour.

XCLAIM introduces three protocols to achieve decentralized, transparent, consistent, atomic, and censorship resistant cross\sphinxhyphen{}blockchain swaps:
\begin{itemize}
\item {} 
\sphinxstylestrong{Issue}: Create Bitcoin\sphinxhyphen{}backed tokens, so\sphinxhyphen{}called \sphinxstyleemphasis{interbtc} on the BTC Parachain.

\item {} 
\sphinxstylestrong{Transfer}: Transfer interbtc to others within the Polkadot ecosystem.

\item {} 
\sphinxstylestrong{Redeem}: Burn Bitcoin\sphinxhyphen{}backed tokens on the BTC Parachain and receive 1:1 of the amount of Bitcoin in return.

\end{itemize}

The basic intuition of the protocol is as below:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{xclaim-process}.png}
\caption{The issue, transfer/swap, and redeem protocols in XCLAIM.}\label{\detokenize{intro/CbA:id1}}\end{figure}


\section{Design Principles}
\label{\detokenize{intro/CbA:design-principles}}
XCLAIM guarantees that Bitcoin\sphinxhyphen{}backed tokens can be redeemed for the corresponding amount of Bitcoin, or the equivalent economic value in DOT. Thereby, XCLAIM overcomes the limitations of centralized approaches through three primary techniques:
\begin{itemize}
\item {} 
\sphinxstylestrong{Secure audit logs}: Logs are constructed to record actions of all users both on Bitcoin and the BTC Parachain.

\item {} 
\sphinxstylestrong{Transaction inclusion proofs}: Chain relays are used to prove correct behavior on Bitcoin to the BTC Parachain.

\item {} 
\sphinxstylestrong{Proof\sphinxhyphen{}or\sphinxhyphen{}Punishment}: Instead of relying on timely fraud proofs (reactive), XCLAIM requires correct behavior to be proven proactively.

\item {} 
\sphinxstylestrong{Over\sphinxhyphen{}collateralization}: Non\sphinxhyphen{}trusted intermediaries, i.e. vaults, are bound by collateral, with mechanisms in place to mitigate exchange rate fluctuations.

\end{itemize}


\section{Recommended Background Reading}
\label{\detokenize{intro/CbA:recommended-background-reading}}\begin{itemize}
\item {} 
\sphinxstylestrong{XCLAIM: Trustless, Interoperable, Cryptocurrency\sphinxhyphen{}backed Assets}. \sphinxstyleemphasis{IEEE Security and Privacy (S\&P).} Zamyatin, A., Harz, D., Lind, J., Panayiotou, P., Gervais, A., \& Knottenbelt, W. (2019).

\item {} 
\sphinxstylestrong{Enabling Blockchain Innovations with Pegged Sidechains}. \sphinxstyleemphasis{Back, A., Corallo, M., Dashjr, L., Friedenbach, M., Maxwell, G., Miller, A., Poelstra A., Timon J.,  \& Wuille, P}. (2014)

\item {} 
\sphinxstylestrong{SoK: Communication Across Distributed Ledgers}. \sphinxstyleemphasis{Cryptology ePrint Archiv, Report 2019/1128}. Zamyatin A, Al\sphinxhyphen{}Bassam M, Zindros D, Kokoris\sphinxhyphen{}Kogias E, Moreno\sphinxhyphen{}Sanchez P, Kiayias A, Knottenbelt WJ. (2019)

\item {} 
\sphinxstylestrong{Proof\sphinxhyphen{}of\sphinxhyphen{}Work Sidechains}. \sphinxstyleemphasis{Workshop on Trusted Smart Contracts, Financial Cryptography} Kiayias, A., \& Zindros, D. (2018)

\end{itemize}


\chapter{Polkadot}
\label{\detokenize{intro/polkadot:polkadot}}\label{\detokenize{intro/polkadot:id1}}\label{\detokenize{intro/polkadot::doc}}
Polkadot is a \sphinxhref{https://wiki.polkadot.network/docs/en/learn-introduction}{sharded blockchain} that aims to connect multiple different blockchains together.
The idea is that each shard has its custom state transition function.
In Polkadot, a shard is called a \sphinxhref{https://wiki.polkadot.network/docs/en/learn-parachains}{Parachain}.
Having different shards with varying state transition functions offers to build blockchains with various cases in mind.

Each blockchain has to make trade\sphinxhyphen{}offs in terms of features it wishes to include. Great examples are Bitcoin which focusses on the core aspect of asset transfers with limited scripting capabilities. On the other end of the spectrum is Ethereum that features a (resource\sphinxhyphen{}limited) Turing complete execution environment.
With Polkadot, the idea is to allow transfers between these different blockchains using a concept called \sphinxhref{https://wiki.polkadot.network/docs/en/learn-bridges}{Bridges}.


\section{Substrate}
\label{\detokenize{intro/polkadot:substrate}}
Polkadot is built using the \sphinxhref{https://substrate.dev/}{Substrate framework}.
Substrate is a blockchain framework that allows to create custom blockchains.
We refer the reader to the detailed introduction on the \sphinxhref{https://substrate.dev/docs/en/}{Substrate website}.


\section{Substrate Specifics}
\label{\detokenize{intro/polkadot:substrate-specifics}}
While this specification does not intend to give a general introduction to either Polkadot or Substrate, we want to highlight several features that are relevant to the implementation.
\begin{itemize}
\item {} 
\sphinxstylestrong{Bootstrapping}: A new Substrate node can be built either using the \sphinxhref{https://github.com/paritytech/substrate}{Substrate implementation} directly or a bare \sphinxhref{https://github.com/substrate-developer-hub/substrate-node-template}{Substrate node template}. For a quick start, the Substrate node template is recommended.

\item {} 
\sphinxstylestrong{Account\sphinxhyphen{}based model}: Substrate uses an account\sphinxhyphen{}based model to store user’s and their balances through the \sphinxhref{https://substrate.dev/rustdocs/master/pallet\_balances/index.html}{Balances} or \sphinxhref{https://substrate.dev/rustdocs/master/pallet\_generic\_asset/index.html}{Generic Asset} modules.

\item {} 
\sphinxstylestrong{DOT to Parachain}: Currently, there exists no pre\sphinxhyphen{}defined module to maintain DOT, Polkadot’s native currency, on Substrate. This will be added in the future. For now, we assume such a module exists and model its functionality via the Generic Assets module.

\item {} 
\sphinxstylestrong{Restricting function calls}: Functions declared in Substrate can be called by any external party. To restrict calls to specific modules, each module can have an account (\sphinxcode{\sphinxupquote{AccountId}} in Substrate) assigned. Restricting a function call can then be enforced by limiting calls from pre\sphinxhyphen{}defined accounts (i.e. caller \sphinxcode{\sphinxupquote{Origin}} must be equal to the modules \sphinxcode{\sphinxupquote{AccountId}}).

\item {} 
\sphinxstylestrong{Failure handling}: Substrate has no implicit failure handling. Errors within a function or errors raised in other function calls must be handled explicitly in the function implementation. Best practice is to (1) verify that the function conditions are met, (2) update the state, (3) emit events and return. \sphinxstyleemphasis{Note}: State can be partially updated if a transaction updates the state at a certain point and fails after the state update is executed.

\item {} 
\sphinxstylestrong{Concurrency}: Substrate does not support concurrent state transitions at the moment.

\item {} 
\sphinxstylestrong{Generic Rust crates}: Substrate does not include the Rust standard library due to non\sphinxhyphen{}deterministic behavior. However, crates can still be used and custom made if they do not depend on the Rust standard library.

\end{itemize}


\chapter{Architecture}
\label{\detokenize{intro/architecture:architecture}}\label{\detokenize{intro/architecture::doc}}
interbtc consists of four different actors and eight modules. The component further uses two additional modules, the BTC\sphinxhyphen{}Relay component and the Parachain Governance mechanism.


\section{Actors}
\label{\detokenize{intro/architecture:actors}}
There are four main participant roles in the system. A high\sphinxhyphen{}level overview of all modules and actors, as well as interactions between them, is provided in \hyperref[\detokenize{intro/architecture:high-level}]{Fig.\@ \ref{\detokenize{intro/architecture:high-level}}} below.
\begin{itemize}
\item {} 
\sphinxstylestrong{Vaults}: Vaults are collateralized intermediaries that are active on both the backing blockchain (Bitcoin) and the issuing blockchain to provide collateral in DOT. They receive and hold BTC from users who wish to create interbtc tokens. When a user destroys interbtc tokens, a vault releases the corresponding amount of BTC to the user’s BTC address. Vaults interact with the following modules directly: {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}, {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, and {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}.

\item {} 
\sphinxstylestrong{Users}: Users interact with the BTC Parachain to create, use (trade/transfer/…), and redeem Bitcoin\sphinxhyphen{}backed interbtc tokens. Since the different protocol phases can be executed by different users, we introduce the following \sphinxstyleemphasis{sub\sphinxhyphen{}roles}:
\begin{itemize}
\item {} 
\sphinxstylestrong{Requester}: A user that locks BTC with a vault on Bitcoin and issues interbtc on the BTC Parachain. Interacts with the {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}} module.

\item {} 
\sphinxstylestrong{Sender} and \sphinxstylestrong{Receiver}: A user (Sender) that sends interbtc to another user (Receiver) on the BTC Parachain. Interacts with the {\hyperref[\detokenize{spec/treasury:treasury-module}]{\sphinxcrossref{\DUrole{std,std-ref}{Treasury}}}} module.

\item {} 
\sphinxstylestrong{Redeemer}: A user that destroys interbtc on the BTC Parachain to receive the corresponding amount of BTC on the Bitcoin blockchain from a Vault. Interacts with the {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}} module.

\end{itemize}

\item {} 
\sphinxstylestrong{Staked Relayers}:  Collateralized intermediaries which run Bitcoin full nodes and (i) monitor validity and availability of transactional data for Bitcoin blocks submitted to BTC\sphinxhyphen{}Relay, (ii) monitor that Vaults do not move locked BTC on Bitcoin without prior authorization by the BTC Parachain (i.e., through one of the Issue, Redeem or Replace protocols). In case either of the above errors was detected, Staked Relayers report this to the BTC Parachain. Interact with the {\hyperref[\detokenize{spec/btc-relay:btc-relay}]{\sphinxcrossref{\DUrole{std,std-ref}{BTC\sphinxhyphen{}Relay}}}}, {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}}, and {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}} modules.

\end{itemize}
\begin{itemize}
\item {} 
\sphinxstylestrong{Governance Mechanism}: The Parachain Governance Mechanism monitors the correct operation of the BTC Parachain, as well as the correct behaviour of Staked Relayers (and other participants if necessary). Interacts with the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} module when Staked Relayers misbehave and can manually interfere with the operation and parameterization of all components of the BTC Parachain.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
The exact composition of the Governance Mechanism is to be defined by Polkadot.
\end{sphinxadmonition}


\section{Modules}
\label{\detokenize{intro/architecture:modules}}
The eight modules in interbtc plus the BTC\sphinxhyphen{}Relay and Governance Mechanism interact with each other, but all have distinct logical functionalities. The figure below shows them.

The specification clearly separates these modules to ensure that each module can be implemented, tested, and verified in isolation. The specification follows the principle of abstracting the internal implementation away and providing a clear interface. This should allow optimisation and improvements of a module with minimal impact on other modules.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{architecture}.png}
\caption{High level overview of the BTC Parachain. interbtc consists of seven modules. The Oracle module stores the exchange rates based on the input of centralized and decentralized exchanges. The Treasury module maintains the ownership of interbtc, the VaultRegistry module stores information about the current Vaults in the system, and the Issue, Redeem and Replace modules expose funcitons and maintain data related to the respective sub protocols. The StabilizedCollateral modules handles vault collateralization, stabilization against exchange rate fluctuations and automatic liquidation. BTC\sphinxhyphen{}Relay tracks the Bitcoin main chain and verifies transaction inclusion. The Parachain Governance maintains correct operation of the BTC Parachain and intervenes / halts operation if necessary.}\label{\detokenize{intro/architecture:id2}}\label{\detokenize{intro/architecture:high-level}}\end{figure}


\subsection{Exchange Rate Oracle}
\label{\detokenize{intro/architecture:exchange-rate-oracle}}
The Oracle module maintains the \sphinxcode{\sphinxupquote{ExchangeRate}} value between the asset that is used to collateralize Vaults (DOT) and the to\sphinxhyphen{}be\sphinxhyphen{}issued asset (BTC).
In the proof\sphinxhyphen{}of\sphinxhyphen{}concept, the Oracle is operated by a trusted third party to feed the current exchange rates into the system.

\begin{sphinxadmonition}{note}{Note:}
The exchange rate oracle implementation is not part of this specification. interbtc simply expects a continuous input of exchange rate data and assumes the oracle operates correctly.
\end{sphinxadmonition}


\subsection{Treasury}
\label{\detokenize{intro/architecture:treasury}}
The Treasury module maintains the ownership and balance of interbtc token holders. It allows respective owners of interbtc to send their tokens to other entities  and to query their balance.
Further, it tracks the total supply of tokens.


\subsection{Vault Registry}
\label{\detokenize{intro/architecture:vault-registry}}
The VaultRegistry module manages the Vaults in the system.It allows Managing the list of active Vaults in the system and the necessary data (e.g. BTC addresses) to execute the Issue, Redeem, and Replace protocols.

This module also handles the collateralization rates of Vaults and reacts to exchange rate fluctuations.
Specifically, it:
\begin{itemize}
\item {} 
stores how much collateral each vault provided and how much of that collateral is allocated to interbtc.

\item {} 
tracks the collateralization rate of each vault and triggers measures in case the rate declines, e.g. due to exchange rate fluctuations.

\item {} 
triggers, as a last resort, automatic liquidation if a vault falls below the minimum collateralization rate.

\end{itemize}


\subsection{Collateral}
\label{\detokenize{intro/architecture:collateral}}
The Collateral module is the central storage for any collateral that is collected in any other module.
It is allows for three simple operations: locking collateral by a party, releasing collateral back to the original party that locked this collateral, and last, slashing collateral where the collateral is relocated to a party other than the one that locked the collateral.


\subsection{Issue}
\label{\detokenize{intro/architecture:issue}}
The Issue module handles the issuing process for interbtc tokens. It tracks issue requests by users, handles the collateral provided by users as griefing protection and exposes functionality for users to prove correct locking on BTC with Vaults (interacting with the endpoints in BTC\sphinxhyphen{}Relay).


\subsection{Redeem}
\label{\detokenize{intro/architecture:redeem}}
The Redeem module handles the redeem process for interbtc tokens. It tracks redeem requests by users, exposes functionality for Vaults to prove correct release of BTC to users (interacting with the endpoints in BTC\sphinxhyphen{}Relay), and handles the Vault’s collateral in case of success (free) and failure (slash).


\subsection{Replace}
\label{\detokenize{intro/architecture:replace}}
The Replace module handles the replace process for Vaults.
It tracks replace requests by existing Vaults, exposes functionality for to\sphinxhyphen{}be\sphinxhyphen{}replaced Vaults to prove correct transfer of locked BTC to new vault candidates (interacting with the endpoints in BTC\sphinxhyphen{}Relay), and handles the collateral provided by participating Vaults as griefing protection.


\subsection{Security}
\label{\detokenize{intro/architecture:security}}
The Security module handles the Staked Relayers. Staked Relayers can register and vote, where applicable, on the status of the BTC Parachain. They can also report theft of BTC by vaults.


\subsection{Governance Mechanism}
\label{\detokenize{intro/architecture:governance-mechanism}}
The Governance Mechanism handles correct operation of the BTC Parachain.

\begin{sphinxadmonition}{note}{Note:}
The Governance Mechanism is not part of this specification. The BTC Parachain simply expects continous operation of the BTC Parachain.
\end{sphinxadmonition}


\section{Interactions}
\label{\detokenize{intro/architecture:interactions}}
We provide a detailed overview of the function calls between the different modules in \hyperref[\detokenize{intro/architecture:fig-interactions}]{Fig.\@ \ref{\detokenize{intro/architecture:fig-interactions}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{detailed-architecture}.png}
\caption{Detailed architecture of the BTC Parachain, showing all actors, components and their interactions.}\label{\detokenize{intro/architecture:id3}}\label{\detokenize{intro/architecture:fig-interactions}}\end{figure}


\chapter{How to read this specification}
\label{\detokenize{spec/introduction:how-to-read-this-specification}}\label{\detokenize{spec/introduction::doc}}
This specification is a living document. The actual implementation might deviate from the specification. In case of deviations in the code, the code has priority over the specification.


\section{Return types}
\label{\detokenize{spec/introduction:return-types}}
Return types MAY return be wrapped in a \sphinxcode{\sphinxupquote{Result}} type, in order to be able to return an error in case of failure. That is, when a return type is described as \sphinxcode{\sphinxupquote{T}}, it MAY actually return a value of type \sphinxcode{\sphinxupquote{Result\textless{}T, DispatchError\textgreater{}}}.


\section{Preconditions, Postconditions and Invariants}
\label{\detokenize{spec/introduction:preconditions-postconditions-and-invariants}}
Preconditions are condition that must hold before the function is executed. Unless otherwise stated, if the precondition does not hold, the function MUST return an error. If the function is a dispatchable function (i.e. callable by users), then if the function returns an error, it MUST NOT make any changes to the storage. The postconditions describe the changes the function MAY make to the storage. Additionally, it describes the return value of the function, if any. Invariants describe conditions that must hold both before and after the execution, but the function might not check whether the invariant holds prior to execution if the code assures that it always holds.


\section{Errors and Events}
\label{\detokenize{spec/introduction:errors-and-events}}
Error listed in the function specification are not necessarily exhaustive \sphinxhyphen{} a function MAY return errors not listed. Similarly, events listed in the function specification are not necessarily exhaustive \sphinxhyphen{} a function MAY emit other events.


\chapter{BTC\sphinxhyphen{}Relay}
\label{\detokenize{spec/btc-relay:btc-relay}}\label{\detokenize{spec/btc-relay:id1}}\label{\detokenize{spec/btc-relay::doc}}
The BTC\sphinxhyphen{}Relay is responsible for storing Bitcoin block headers and maintaining the current longest chain.
We can use the stored block headers to verify transaction inclusion in Bitcoin.
Further, BTC\_Relay exposes functions to validate that the contents of a transactions are as expected.

The specification of the \sphinxhref{https://interlay.gitlab.io/interbtc-spec/btcrelay-spec/}{BTC\sphinxhyphen{}Relay is found here: https://interlay.gitlab.io/interbtc\sphinxhyphen{}spec/btcrelay\sphinxhyphen{}spec/}.


\chapter{Collateral}
\label{\detokenize{spec/collateral:collateral}}\label{\detokenize{spec/collateral:collateral-module}}\label{\detokenize{spec/collateral::doc}}

\section{Overview}
\label{\detokenize{spec/collateral:overview}}
The Collateral module is the central storage for collateral provided by users and vaults of the system.
It allows to (i) lock, (ii) release, and (iii) slash collateral of either users or vaults.
It can only be accessed by other modules and not directly through external transactions.


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}Step}
\label{\detokenize{spec/collateral:step-by-step}}
The protocol has three different “sub\sphinxhyphen{}protocols”.
\begin{itemize}
\item {} 
\sphinxstylestrong{Lock}: Store a certain amount of collateral from a single entity (user or vault).

\item {} 
\sphinxstylestrong{Release}: Transfer a certain amount of collateral back to the entity that paid it.

\item {} 
\sphinxstylestrong{Slash}: Transfer a certain amount of collateral to a party that was damaged by the actions of another party.

\end{itemize}


\section{Data Model}
\label{\detokenize{spec/collateral:data-model}}

\subsection{Scalars}
\label{\detokenize{spec/collateral:scalars}}

\subsubsection{TotalCollateral}
\label{\detokenize{spec/collateral:totalcollateral}}
The total collateral provided.


\subsection{Maps}
\label{\detokenize{spec/collateral:maps}}

\subsubsection{CollateralBalances}
\label{\detokenize{spec/collateral:collateralbalances}}
Mapping from accounts to their collateral balances.


\section{Functions}
\label{\detokenize{spec/collateral:functions}}

\subsection{lockCollateral}
\label{\detokenize{spec/collateral:lockcollateral}}\label{\detokenize{spec/collateral:id1}}
A user or a vault locks some amount of collateral.


\subsubsection{Specification}
\label{\detokenize{spec/collateral:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{lockCollateral(sender, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: The sender wishing to lock collateral.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of collateral.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{LockCollateral(sender, amount)}}: Issues an event when collateral is locked.

\end{itemize}


\subsubsection{Precondition}
\label{\detokenize{spec/collateral:precondition}}\begin{itemize}
\item {} 
The function must be called by any of the four modules: {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}}, {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}, or {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/collateral:function-sequence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Add the \sphinxcode{\sphinxupquote{amount}} of provided collateral to the \sphinxcode{\sphinxupquote{CollateralBalances}} of the \sphinxcode{\sphinxupquote{sender}}.

\item {} 
Increase \sphinxcode{\sphinxupquote{TotalCollateral}} by \sphinxcode{\sphinxupquote{amount}}.

\end{enumerate}


\subsection{releaseCollateral}
\label{\detokenize{spec/collateral:releasecollateral}}\label{\detokenize{spec/collateral:id2}}
When any of the issue, redeem, or replace protocols are completed successfully the party that has initially provided collateral receives their collateral back.


\subsubsection{Specification}
\label{\detokenize{spec/collateral:id3}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{releaseCollateral(sender, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: The sender getting returned its collateral.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of collateral.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ReleaseCollateral(sender, amount)}}: Issues an event when collateral is released.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL\_AVAILABLE}}: The \sphinxcode{\sphinxupquote{sender}} has less collateral stored than the requested \sphinxcode{\sphinxupquote{amount}}.

\end{itemize}


\subsubsection{Precondition}
\label{\detokenize{spec/collateral:id4}}\begin{itemize}
\item {} 
The function must be called by any of the four modules: {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}}, {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}, or {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/collateral:id5}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if the \sphinxcode{\sphinxupquote{amount}} is less or equal to the \sphinxcode{\sphinxupquote{CollateralBalances}} of the \sphinxcode{\sphinxupquote{sender}}. If not, throw \sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL\_AVAILABLE}}.

\item {} 
Deduct the \sphinxcode{\sphinxupquote{amount}} from the \sphinxcode{\sphinxupquote{sender}}’s \sphinxcode{\sphinxupquote{CollateralBalances}}.

\item {} 
Deduct the \sphinxcode{\sphinxupquote{amount}} from the \sphinxcode{\sphinxupquote{TotalCollateral}}.

\item {} 
Transfer the \sphinxcode{\sphinxupquote{amount}} to the \sphinxcode{\sphinxupquote{sender}}.

\end{enumerate}


\subsection{slashCollateral}
\label{\detokenize{spec/collateral:slashcollateral}}\label{\detokenize{spec/collateral:id6}}
When any of the issue, redeem, or replace protocols are not completed in time, the party that has initially provided collateral (\sphinxcode{\sphinxupquote{sender}}) is slashed and the collateral is transferred to another party (\sphinxcode{\sphinxupquote{receiver}}).


\subsubsection{Specification}
\label{\detokenize{spec/collateral:id7}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{slashCollateral(sender, receiver, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: The sender that initially provided the collateral.

\item {} 
\sphinxcode{\sphinxupquote{receiver}}: The receiver of the collateral.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of collateral.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SlashCollateral(sender, receiver, amount)}}: Issues an event when collateral is slashed.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL\_AVAILABLE}}: The \sphinxcode{\sphinxupquote{sender}} has less collateral stored than the requested \sphinxcode{\sphinxupquote{amount}}.

\end{itemize}


\subsubsection{Precondition}
\label{\detokenize{spec/collateral:id8}}\begin{itemize}
\item {} 
The function must be called by any of the four modules: {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}}, {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}, or {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/collateral:id9}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if the \sphinxcode{\sphinxupquote{amount}} is less or equal to the \sphinxcode{\sphinxupquote{CollateralBalances}} of the \sphinxcode{\sphinxupquote{sender}}. If not, throw \sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL\_AVAILABLE}}.

\item {} 
Deduct the \sphinxcode{\sphinxupquote{amount}} from the \sphinxcode{\sphinxupquote{sender}}’s \sphinxcode{\sphinxupquote{CollateralBalances}}.

\item {} 
Deduct the \sphinxcode{\sphinxupquote{amount}} from the \sphinxcode{\sphinxupquote{TotalCollateral}}.

\item {} 
Transfer the \sphinxcode{\sphinxupquote{amount}} to the \sphinxcode{\sphinxupquote{receiver}}.

\end{enumerate}


\section{Events}
\label{\detokenize{spec/collateral:events}}

\subsection{LockCollateral}
\label{\detokenize{spec/collateral:id10}}
Emit a \sphinxcode{\sphinxupquote{LockCollateral}} event when a sender locks collateral.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{LockCollateral(sender, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: The sender that provides the collateral.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of collateral.

\end{itemize}

\sphinxstyleemphasis{Function}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/collateral:lockcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{lockCollateral}}}}

\end{itemize}


\subsection{ReleaseCollateral}
\label{\detokenize{spec/collateral:id11}}
Emit a \sphinxcode{\sphinxupquote{ReleaseCollateral}} event when a sender releases collateral.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{ReleaseCollateral(sender, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: The sender that initially provided the collateral.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of collateral.

\end{itemize}

\sphinxstyleemphasis{Function}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/collateral:releasecollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{releaseCollateral}}}}

\end{itemize}


\subsection{SlashCollateral}
\label{\detokenize{spec/collateral:id12}}
Emit a \sphinxcode{\sphinxupquote{SlashCollateral}} event when a sender’s collateral is slashed and transferred to the receiver.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{SlashCollateral(sender, receiver, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: The sender that initially provided the collateral.

\item {} 
\sphinxcode{\sphinxupquote{receiver}}: The receiver of the collateral.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of collateral.

\end{itemize}

\sphinxstyleemphasis{Function}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/collateral:slashcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{slashCollateral}}}}

\end{itemize}


\section{Errors}
\label{\detokenize{spec/collateral:errors}}
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL\_AVAILABLE\textasciigrave{}}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The sender’s collateral balance is below the requested amount.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/collateral:releasecollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{releaseCollateral}}}} | {\hyperref[\detokenize{spec/collateral:slashcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{slashCollateral}}}}

\item {} 
\sphinxstylestrong{Cause}: the \sphinxcode{\sphinxupquote{sender}} has less collateral stored than the requested \sphinxcode{\sphinxupquote{amount}}.

\end{itemize}


\chapter{Fee}
\label{\detokenize{spec/fee:fee}}\label{\detokenize{spec/fee::doc}}

\section{Overview}
\label{\detokenize{spec/fee:overview}}
The fee model crate implements the fee model outlined in {\hyperref[\detokenize{economics/fees:fee-model}]{\sphinxcrossref{\DUrole{std,std-ref}{Fee Model}}}}.


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}step}
\label{\detokenize{spec/fee:step-by-step}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Fees are paid by Users (e.g., during issue and redeem requests) and forwarded to a reward pool.

\item {} 
Fees are then split between Vaults, Staked Relayers, Maintainers, and Collators.

\item {} 
Network participants can claim these rewards from the pool based on their stake.

\item {} 
Stake is determined by their participation in the network \sphinxhyphen{} through incentivized actions.

\item {} 
Rewards may be paid in multiple currencies.

\end{enumerate}


\section{Data Model}
\label{\detokenize{spec/fee:data-model}}

\subsection{Scalars (Fee Pools)}
\label{\detokenize{spec/fee:scalars-fee-pools}}

\subsubsection{ParachainFeePool}
\label{\detokenize{spec/fee:parachainfeepool}}
Tracks the balance of fees earned by the BTC\sphinxhyphen{}Parachain which are to be distributed across all Vault, Staked Relayer, Collator and Maintainer pools.


\subsubsection{VaultRewards}
\label{\detokenize{spec/fee:vaultrewards}}
Tracks the fee share (in \%) allocated to Vaults.
\begin{itemize}
\item {} 
Initial value: 77\%

\end{itemize}


\subsubsection{StakedRelayerRewards}
\label{\detokenize{spec/fee:stakedrelayerrewards}}
Tracks the fee share (in \%) allocated to Staked Relayers.
\begin{itemize}
\item {} 
Initial value: 3\%

\end{itemize}


\subsubsection{CollatorRewards}
\label{\detokenize{spec/fee:collatorrewards}}
Tracks the fee share (in \%) allocated to Collators (excl. Parachain transaction fees).
\begin{itemize}
\item {} 
Initial value: 0\%

\end{itemize}


\subsubsection{MaintainerRewards}
\label{\detokenize{spec/fee:maintainerrewards}}
Tracks fee share (in \%) allocated to Parachain maintainers.
\begin{itemize}
\item {} 
Initial value: 20\%

\end{itemize}


\subsection{Scalars (Fees)}
\label{\detokenize{spec/fee:scalars-fees}}

\subsubsection{IssueFee}
\label{\detokenize{spec/fee:issuefee}}
Issue fee share (configurable parameter, as percentage) that users need to pay upon execute issuing wrapped tokens.
\begin{itemize}
\item {} 
Paid in wrapped tokens

\item {} 
Initial value: 0.5\%

\end{itemize}


\subsubsection{IssueGriefingCollateral}
\label{\detokenize{spec/fee:issuegriefingcollateral}}
Default griefing collateral as a percentage of the locked collateral of a vault a user has to lock to issue wrapped tokens.
\begin{itemize}
\item {} 
Paid in collateral

\item {} 
Initial value: 0.005\%

\end{itemize}


\subsubsection{RedeemFee}
\label{\detokenize{spec/fee:redeemfee}}\label{\detokenize{spec/fee:id1}}
Redeem fee share (configurable parameter, as percentage) that users need to pay upon request redeeming wrapped tokens.
\begin{itemize}
\item {} 
Paid in wrapped tokens

\item {} 
Initial value: 0.5\%

\end{itemize}


\subsubsection{PremiumRedeemFee}
\label{\detokenize{spec/fee:premiumredeemfee}}\label{\detokenize{spec/fee:id2}}
Fee for users to premium redeem (as percentage). If users execute a redeem with a Vault flagged for premium redeem, they earn a premium slashed from the Vault’s collateral.
\begin{itemize}
\item {} 
Paid in collateral

\item {} 
Initial value: 5\%

\end{itemize}


\subsubsection{PunishmentFee}
\label{\detokenize{spec/fee:punishmentfee}}\label{\detokenize{spec/fee:id3}}
Fee (as percentage) that a vault has to pay if it fails to execute redeem requests (for redeem, on top of the slashed value of the request). The fee is paid in collateral based on the wrapped token amount at the current exchange rate.
\begin{itemize}
\item {} 
Paid in collateral

\item {} 
Initial value: 10\%

\end{itemize}


\subsubsection{PunishmentDelay}
\label{\detokenize{spec/fee:punishmentdelay}}
Time period in which a vault cannot participate in issue, redeem or replace requests.
\begin{itemize}
\item {} 
Measured in Parachain blocks

\item {} 
Initial value: 1 day (Parachain constant)

\end{itemize}


\subsubsection{ReplaceGriefingCollateral}
\label{\detokenize{spec/fee:replacegriefingcollateral}}\label{\detokenize{spec/fee:id4}}
Default griefing collateral as a percentage of the to\sphinxhyphen{}be\sphinxhyphen{}locked collateral of the new vault, vault has to lock to be replaced by another vault. This collateral will be slashed and allocated to the replacing Vault if the to\sphinxhyphen{}be\sphinxhyphen{}replaced Vault does not transfer BTC on time.
\begin{itemize}
\item {} 
Paid in collateral

\item {} 
Initial value: 0.005\%

\end{itemize}


\section{Functions}
\label{\detokenize{spec/fee:functions}}

\subsection{distributeRewards}
\label{\detokenize{spec/fee:distributerewards}}
Specifies the distribution of fees among incentivised network participants.


\subsubsection{Specification}
\label{\detokenize{spec/fee:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{distributeRewards()}}


\subsubsection{Function Sequence}
\label{\detokenize{spec/fee:function-sequence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Calculate the total fees for all Vaults using the \sphinxtitleref{VaultRewards} percentage.

\item {} 
Calculate the total fees for all Staked Relayers using the \sphinxtitleref{StakedRelayerRewards} percentage.

\item {} 
Calculate the total fees for all Collators using the \sphinxtitleref{CollatorRewards} percentage.

\item {} 
Send the remaining fees to the Maintainer fund.

\end{enumerate}


\subsection{withdrawRewards}
\label{\detokenize{spec/fee:withdrawrewards}}\label{\detokenize{spec/fee:id5}}
A function that allows Staked Relayers, Vaults and Collators to withdraw the fees earned.


\subsubsection{Specification}
\label{\detokenize{spec/fee:id6}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{withdrawRewards(account, currency, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{account}}: the account withdrawing rewards

\item {} 
\sphinxcode{\sphinxupquote{currency}}: the currency of the reward to withdraw

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{WithdrawRewards(account, currency, amount)}}

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/fee:id7}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Compute the rewards based on the account’s stake.

\item {} 
Transfer all rewards to the account.

\end{enumerate}


\section{Events}
\label{\detokenize{spec/fee:events}}

\subsection{WithdrawRewards}
\label{\detokenize{spec/fee:id8}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{WithdrawRewards(account, currency, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{account}}: the account withdrawing rewards

\item {} 
\sphinxcode{\sphinxupquote{currency}}: the currency of the reward to withdraw

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the amount withdrawn

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/fee:withdrawrewards}]{\sphinxcrossref{\DUrole{std,std-ref}{withdrawRewards}}}}

\end{itemize}


\chapter{Exchange Rate Oracle}
\label{\detokenize{spec/oracle:exchange-rate-oracle}}\label{\detokenize{spec/oracle:oracle}}\label{\detokenize{spec/oracle::doc}}
\begin{sphinxadmonition}{note}{Note:}
This exchange oracle module is a bare minimum model that relies on a single trusted oracle source. Decentralized oracles are a difficult and open research problem that is outside of the scope of this specification. However, the general interface to get the exchange rate can remain the same even with different constructions.
\end{sphinxadmonition}

The Exchange Rate Oracle receives a continuous data feed on the exchange rate between BTC and DOT.

The implementation of the oracle \sphinxstylestrong{is not part of this specification}. interbtc assumes the oracle operates correctly and that the received data is reliable.


\section{Data Model}
\label{\detokenize{spec/oracle:data-model}}

\subsection{Constants}
\label{\detokenize{spec/oracle:constants}}

\subsubsection{GRANULARITY}
\label{\detokenize{spec/oracle:granularity}}
The granularity of the exchange rate. The granularity is set to \(10^{-5}\).


\subsection{Scalars}
\label{\detokenize{spec/oracle:scalars}}

\subsubsection{ExchangeRateBtcInDot}
\label{\detokenize{spec/oracle:exchangeratebtcindot}}
The BTC in DOT exchange rate. This exchange rate is used to determine how much collateral is required to issue a specific amount of interbtc.

\begin{sphinxadmonition}{note}{Note:}
If the \sphinxcode{\sphinxupquote{ExchangeRate}} is set to 1238763, it translates to \(12.38763\) as the last five digits are used for the floating point (as defined by the \sphinxcode{\sphinxupquote{GRANULARITY}}).
\end{sphinxadmonition}


\subsubsection{SatoshiPerBytesFast}
\label{\detokenize{spec/oracle:satoshiperbytesfast}}
The estimated Satoshis per bytes required to get a Bitcoin transaction included in the next block.


\subsubsection{SatoshiPerBytesMedium}
\label{\detokenize{spec/oracle:satoshiperbytesmedium}}
The estimated Satoshis per bytes required to get a Bitcoin transaction included in the next three blocks (about 30 min).


\subsubsection{SatoshiPerBytesSlow}
\label{\detokenize{spec/oracle:satoshiperbytesslow}}
The estimated Satoshis per bytes required to get a Bitcoin transaction included in the six blocks (about 1 hour).


\subsubsection{MaxDelay}
\label{\detokenize{spec/oracle:maxdelay}}
The maximum delay in seconds between incoming calls providing exchange rate data. If the Exchange Rate Oracle receives no data for more than this period, the BTC Parachain enters an \sphinxcode{\sphinxupquote{Error}} state with a \sphinxcode{\sphinxupquote{ORACLE\_OFFLINE}} error cause.


\subsubsection{LastExchangeRateTime}
\label{\detokenize{spec/oracle:lastexchangeratetime}}
UNIX timestamp indicating when the last exchange rate data was received.


\subsection{Enums}
\label{\detokenize{spec/oracle:enums}}

\subsubsection{InclusionEstimate}
\label{\detokenize{spec/oracle:inclusionestimate}}
The estimated time until when a BTC transaction is included based on the Satoshi per byte fee.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{FAST: 0}} \sphinxhyphen{} the fee to include a BTC transaction within the next block.

\item {} 
\sphinxcode{\sphinxupquote{MEDIUM: 1}}\sphinxhyphen{} the fee to include a BTC transaction within the next three blocks (\textasciitilde{}30 min)).

\item {} 
\sphinxcode{\sphinxupquote{SLOW: 2}} \sphinxhyphen{} the fee to include a BTC transaction within the six blocks  (\textasciitilde{}60 min).

\end{itemize}


\subsection{Maps}
\label{\detokenize{spec/oracle:maps}}

\subsubsection{AuthorizedOracles}
\label{\detokenize{spec/oracle:authorizedoracles}}
The account(s) of the oracle. Returns true if registered as an oracle.


\section{Functions}
\label{\detokenize{spec/oracle:functions}}

\subsection{setExchangeRate}
\label{\detokenize{spec/oracle:setexchangerate}}\label{\detokenize{spec/oracle:id1}}
Set the latest (aggregate) BTC/DOT exchange rate. This function invokes a check of vault collateral rates in the {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}} component.


\subsubsection{Specification}
\label{\detokenize{spec/oracle:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{setExchangeRate(oracle, rate)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oracle}}: the oracle account calling this function. Must be pre\sphinxhyphen{}authorized and tracked in this component!

\item {} 
\sphinxcode{\sphinxupquote{rate}}: the \sphinxcode{\sphinxupquote{u128}} BTC/DOT exchange rate

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SetExchangeRate(oracle, rate)}}: Emits the new exchange rate when it is updated by the oracle.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_INVALID\_ORACLE\_SOURCE}}: the caller of the function was not the authorized oracle.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/oracle:preconditions}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/oracle:function-sequence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if the caller of the function is the \sphinxcode{\sphinxupquote{AuthorizedOracle}}. If not, throw \sphinxcode{\sphinxupquote{ERR\_INVALID\_ORACLE\_SOURCE}}.

\item {} 
Update the \sphinxcode{\sphinxupquote{ExchangeRate}} with the \sphinxcode{\sphinxupquote{rate}}.

\item {} 
If \sphinxcode{\sphinxupquote{LastExchangeRateTime}} minus the current UNIX timestamp is greater or equal to \sphinxcode{\sphinxupquote{MaxDelay}}, call {\hyperref[\detokenize{spec/oracle:recoverfromoracleoffline}]{\sphinxcrossref{\DUrole{std,std-ref}{recoverFromORACLEOFFLINE}}}} to recover from an \sphinxcode{\sphinxupquote{ORACLE\_OFFLINE}} error (which was the case before this data submission).

\item {} 
Set \sphinxcode{\sphinxupquote{LastExchangeRateTime}} to the current UNIX timestamp.

\item {} 
Emit the \sphinxcode{\sphinxupquote{SetExchangeRate}} event.

\end{enumerate}


\subsection{setSatoshiPerBytes}
\label{\detokenize{spec/oracle:setsatoshiperbytes}}\label{\detokenize{spec/oracle:id2}}
Set the Satoshi per bytes fee


\subsubsection{Specification}
\label{\detokenize{spec/oracle:id3}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{setSatoshiPerBytes(fee, InclusionEstimate)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{fee}}: the Satoshi per byte fee.

\item {} 
\sphinxcode{\sphinxupquote{InclusionEstimate}}: the estimated inclusion time.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SetSatoshiPerByte(fee, InclusionEstimate)}}:

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_INVALID\_ORACLE\_SOURCE}}: the caller of the function was not the authorized oracle.

\end{itemize}


\subsubsection{Requirements}
\label{\detokenize{spec/oracle:requirements}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\item {} 
If the caller of the function is not in \sphinxcode{\sphinxupquote{AuthorizedOracles}} MUST return \sphinxcode{\sphinxupquote{ERR\_INVALID\_ORACLE\_SOURCE}}.

\item {} 
If the above checks passed, the function MUST update the \sphinxcode{\sphinxupquote{SatoshiPerBytes}} field indicated by the \sphinxcode{\sphinxupquote{InclusionEstimate}} enum.

\item {} 
If the above steps passed, MUST emit the \sphinxcode{\sphinxupquote{SetSatoshiPerByte}} event.

\end{itemize}


\subsection{getExchangeRate}
\label{\detokenize{spec/oracle:getexchangerate}}\label{\detokenize{spec/oracle:id4}}
Returns the latest BTC/DOT exchange rate, as received from the external data sources.


\subsubsection{Specification}
\label{\detokenize{spec/oracle:id5}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{getExchangeRate()}}

\sphinxstyleemphasis{Returns}
\begin{itemize}
\item {} 
\sphinxtitleref{u128} (aggregate) exchange rate value

\end{itemize}

\sphinxcode{\sphinxupquote{fn getExchangeRate(origin) \sphinxhyphen{}\textgreater{} Result\textless{}u128, ERR\_MISSING\_EXCHANGE\_RATE\textgreater{} \{...\}}}

\sphinxstyleemphasis{Errors}

\sphinxcode{\sphinxupquote{ERR\_MISSING\_EXCHANGE\_RATE}}: the last exchange rate information exceeded the maximum delay acceptable by the oracle.


\subsubsection{Preconditions}
\label{\detokenize{spec/oracle:id6}}
This function can be called by any participant to retrieve the BTC/DOT exchange rate as tracked by the BTC Parachain.


\subsubsection{Function Sequence}
\label{\detokenize{spec/oracle:id7}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if the current (UNIX) time minus the \sphinxcode{\sphinxupquote{LastExchangeRateTime}} exceeds \sphinxcode{\sphinxupquote{MaxDelay}}. If this is the case, return \sphinxcode{\sphinxupquote{ERR\_MISSING\_EXCHANGE\_RATE}} error.

\item {} 
Otherwise, return the \sphinxcode{\sphinxupquote{ExchangeRate}} from storage.

\end{enumerate}


\subsection{getLastExchangeRateTime}
\label{\detokenize{spec/oracle:getlastexchangeratetime}}\label{\detokenize{spec/oracle:id8}}
Returns the UNIX timestamp of when the last BTC/DOT exchange rate was received from the external data sources.


\subsubsection{Specification}
\label{\detokenize{spec/oracle:id9}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{getLastExchangeRateTime()}}

\sphinxstyleemphasis{Returns}
\begin{itemize}
\item {} 
\sphinxtitleref{timestamp}: 32bit UNIX timestamp

\end{itemize}

\sphinxcode{\sphinxupquote{fn getLastExchangeRateTime() \sphinxhyphen{}\textgreater{} U32 \{...\}}}


\subsubsection{Function Sequence}
\label{\detokenize{spec/oracle:id10}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Return \sphinxcode{\sphinxupquote{LastExchangeRateTime}} from storage.

\end{enumerate}


\section{Events}
\label{\detokenize{spec/oracle:events}}

\subsection{SetExchangeRate}
\label{\detokenize{spec/oracle:id11}}
Emits the new exchange rate when it is updated by the oracle.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{SetExchangeRate(oracle, rate)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oracle}}: the oracle account calling this function. Must be pre\sphinxhyphen{}authorized and tracked in this component!

\item {} 
\sphinxcode{\sphinxupquote{rate}}: the \sphinxcode{\sphinxupquote{u128}} BTC/DOT exchange rate

\end{itemize}

\sphinxstyleemphasis{Function}

{\hyperref[\detokenize{spec/oracle:setexchangerate}]{\sphinxcrossref{\DUrole{std,std-ref}{setExchangeRate}}}}


\subsection{recoverFromORACLEOFFLINE}
\label{\detokenize{spec/oracle:recoverfromoracleoffline}}\label{\detokenize{spec/oracle:id12}}
Internal function. Recovers the BTC Parachain state from a \sphinxcode{\sphinxupquote{ORACLE\_OFFLINE}} error and sets \sphinxcode{\sphinxupquote{ParachainStatus}} to \sphinxcode{\sphinxupquote{RUNNING}} if there are no other errors.

\begin{sphinxadmonition}{attention}{Attention:}
Can only be called from {\hyperref[\detokenize{spec/oracle:oracle}]{\sphinxcrossref{\DUrole{std,std-ref}{Exchange Rate Oracle}}}}.
\end{sphinxadmonition}


\subsubsection{Specification}
\label{\detokenize{spec/oracle:id13}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{recoverFromORACLEOFFLINE()}}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ExecuteStatusUpdate(newStatusCode, addErrors, removeErrors, msg)}} \sphinxhyphen{} emits an event indicating the status change, with \sphinxcode{\sphinxupquote{newStatusCode}} being the new \sphinxcode{\sphinxupquote{StatusCode}}, \sphinxcode{\sphinxupquote{addErrors}} the set of to\sphinxhyphen{}be\sphinxhyphen{}added \sphinxcode{\sphinxupquote{ErrorCode}} entries (if the new status is \sphinxcode{\sphinxupquote{Error}}), \sphinxcode{\sphinxupquote{removeErrors}} the set of to\sphinxhyphen{}be\sphinxhyphen{}removed \sphinxcode{\sphinxupquote{ErrorCode}} entries,, and \sphinxcode{\sphinxupquote{msg}} the detailed reason for the status update.

\end{itemize}


\section{Error Codes}
\label{\detokenize{spec/oracle:error-codes}}
\sphinxcode{\sphinxupquote{ERR\_MISSING\_EXCHANGE\_RATE}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Exchange rate not set.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/oracle:getexchangerate}]{\sphinxcrossref{\DUrole{std,std-ref}{getExchangeRate}}}}

\item {} 
\sphinxstylestrong{Cause}: The last exchange rate information exceeded the maximum delay acceptable by the oracle.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_INVALID\_ORACLE\_SOURCE}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Invalid oracle account.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/oracle:setexchangerate}]{\sphinxcrossref{\DUrole{std,std-ref}{setExchangeRate}}}}

\item {} 
\sphinxstylestrong{Cause}: The caller of the function was not the authorized oracle.

\end{itemize}


\chapter{Issue}
\label{\detokenize{spec/issue:issue}}\label{\detokenize{spec/issue:issue-protocol}}\label{\detokenize{spec/issue::doc}}

\section{Overview}
\label{\detokenize{spec/issue:overview}}
The Issue module allows as user to create new interbtc tokens. The user needs to request interbtc through the {\hyperref[\detokenize{spec/issue:requestissue}]{\sphinxcrossref{\DUrole{std,std-ref}{requestIssue}}}} function, then send BTC to a vault, and finally complete the issuing of interbtc by calling the {\hyperref[\detokenize{spec/issue:executeissue}]{\sphinxcrossref{\DUrole{std,std-ref}{executeIssue}}}} function. If the user does not complete the process in time, the vault can cancel the issue request and receive a griefing collateral from the user by invoking the {\hyperref[\detokenize{spec/issue:cancelissue}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelIssue}}}} function. Below is a high\sphinxhyphen{}level step\sphinxhyphen{}by\sphinxhyphen{}step description of the protocol.


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}step}
\label{\detokenize{spec/issue:step-by-step}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Precondition: a vault has locked collateral as described in the {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}.

\item {} 
A user executes the {\hyperref[\detokenize{spec/issue:requestissue}]{\sphinxcrossref{\DUrole{std,std-ref}{requestIssue}}}} function to open an issue request on the BTC Parachain. The issue request includes the amount of interbtc the user wants to issue, the selected vault, and a small collateral to prevent {\hyperref[\detokenize{security_performance/security-analysis:griefing}]{\sphinxcrossref{\DUrole{std,std-ref}{Griefing}}}}.

\item {} 
A user sends the equivalent amount of BTC that he wants to issue as interbtc to the vault on the Bitcoin blockchain.

\item {} 
The user or a vault acting on behalf of the user extracts a transaction inclusion proof of that locking transaction on the Bitcoin blockchain. The user or a vault acting on behalf of the user executes the {\hyperref[\detokenize{spec/issue:executeissue}]{\sphinxcrossref{\DUrole{std,std-ref}{executeIssue}}}} function on the BTC Parachain. The issue function requires a reference to the issue request and the transaction inclusion proof of the Bitcoin locking transaction. If the function completes successfully, the user receives the requested amount of interbtc into his account.

\item {} 
Optional: If the user is not able to complete the issue request within the predetermined time frame (\sphinxcode{\sphinxupquote{IssuePeriod}}), the vault is able to call the {\hyperref[\detokenize{spec/issue:cancelissue}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelIssue}}}} function to cancel the issue request adn will receive the griefing collateral locked by the user.

\end{enumerate}


\subsection{Security}
\label{\detokenize{spec/issue:security}}\begin{itemize}
\item {} 
Unique identification of Bitcoin payments: {\hyperref[\detokenize{security_performance/security-analysis:okd}]{\sphinxcrossref{\DUrole{std,std-ref}{On\sphinxhyphen{}Chain Key Derivation Scheme}}}}

\end{itemize}


\subsection{Vault Registry}
\label{\detokenize{spec/issue:vault-registry}}
The data access and state changes to the vault registry are documented in \hyperref[\detokenize{spec/issue:fig-vault-registry-issue}]{Fig.\@ \ref{\detokenize{spec/issue:fig-vault-registry-issue}}} below.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{VaultRegistry-Issue}.png}
\caption{The issue protocol interacts with three functions in the vault registry that handle updating the different token balances.}\label{\detokenize{spec/issue:id15}}\label{\detokenize{spec/issue:fig-vault-registry-issue}}\end{figure}


\subsection{Fee Model}
\label{\detokenize{spec/issue:fee-model}}
Following additions are added if the fee model is integrated.
\begin{itemize}
\item {} 
Issue fees are paid by users in interbtc when executing the request. The fees are transferred to the Parachain Fee Pool.

\item {} 
If an issue request is executed, the user’s griefing collateral is returned.

\item {} 
If an issue request is canceled, the vault assigned to this issue request receives the griefing collateral.

\end{itemize}


\section{Data Model}
\label{\detokenize{spec/issue:data-model}}

\subsection{Scalars}
\label{\detokenize{spec/issue:scalars}}

\subsubsection{IssuePeriod}
\label{\detokenize{spec/issue:issueperiod}}
The time difference between when an issue request is created and required completion time by a user. Concretely, this period is the amount by which {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}} is allowed to increase before the issue is considered to be expired. The period has an upper limit to prevent griefing of vault collateral.


\subsubsection{IssueGriefingCollateral}
\label{\detokenize{spec/issue:issuegriefingcollateral}}
The minimum collateral (DOT) a user needs to provide as griefing protection.

\begin{sphinxadmonition}{note}{Note:}
Serves as a measurement to disincentivize griefing attacks against a vault. A user could otherwise create an issue request, temporarily locking a vault’s collateral and never execute the issue process.
\end{sphinxadmonition}


\subsection{Maps}
\label{\detokenize{spec/issue:maps}}

\subsubsection{IssueRequests}
\label{\detokenize{spec/issue:issuerequests}}
Users create issue requests to issue interbtc. This mapping provides access from a unique hash \sphinxcode{\sphinxupquote{IssueId}} to a \sphinxcode{\sphinxupquote{Issue}} struct. \sphinxcode{\sphinxupquote{\textless{}IssueId, Issue\textgreater{}}}.


\subsection{Structs}
\label{\detokenize{spec/issue:structs}}

\subsubsection{Issue}
\label{\detokenize{spec/issue:id1}}
Stores the status and information about a single issue request.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|l|l|L|}
\hline
\sphinxstyletheadfamily 
Parameter
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{vault}}
&
Account
&
The BTC Parachain address of the vault responsible for this commit request.
\\
\hline
\sphinxcode{\sphinxupquote{opentime}}
&
u256
&
Block height of opening the request.
\\
\hline
\sphinxcode{\sphinxupquote{griefingCollateral}}
&
DOT
&
Collateral provided by a user.
\\
\hline
\sphinxcode{\sphinxupquote{amount}}
&
interbtc
&
Amount of interbtc to be issued.
\\
\hline
\sphinxcode{\sphinxupquote{fee}}
&
interbtc
&
Fee charged to the user for issuing.
\\
\hline
\sphinxcode{\sphinxupquote{requester}}
&
Account
&
User account receiving interbtc upon successful issuing.
\\
\hline
\sphinxcode{\sphinxupquote{btcAddress}}
&
bytes{[}20{]}
&
Base58 encoded Bitcoin public key of the Vault.
\\
\hline
\sphinxcode{\sphinxupquote{completed}}
&
bool
&
Indicates if the issue has been completed.
\\
\hline
\sphinxcode{\sphinxupquote{cancelled}}
&
bool
&
Indicates if the issue request was cancelled.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Functions}
\label{\detokenize{spec/issue:functions}}

\subsection{requestIssue}
\label{\detokenize{spec/issue:requestissue}}\label{\detokenize{spec/issue:id2}}
A user opens an issue request to create a specific amount of interbtc.
When calling this function, a user provides her own parachain account identifier, the to be issued amount of interbtc, and the vault she wants to use in this process (parachain account identifier). Further, she provides some (small) amount of DOT collateral (\sphinxcode{\sphinxupquote{griefingCollateral}}) to prevent griefing.


\subsubsection{Specification}
\label{\detokenize{spec/issue:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{requestIssue(requester, amount, vault, griefingCollateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{requester}}: The user’s BTC Parachain account.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc to be issued.

\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the vault involved in this issue request.

\item {} 
\sphinxcode{\sphinxupquote{griefingCollateral}}: The collateral amount provided by the user as griefing protection.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RequestIssue(issueId, requester, amount, vault, btcAddress)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_FOUND = "There exists no vault with the given account id"}}: The specified vault does not exist.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_VAULT\_BANNED = "The selected vault has been temporarily banned."}}: Issue requests are not possible with temporarily banned Vaults.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL}}: The user did not provide enough griefing collateral.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/issue:preconditions}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/issue:function-sequence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Retrieve the \sphinxcode{\sphinxupquote{vault}} from {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}. Return \sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_FOUND}} if no vault can be found.

\item {} 
Check that the \sphinxcode{\sphinxupquote{vault}} is currently not banned, i.e., \sphinxcode{\sphinxupquote{vault.bannedUntil == None}} or \sphinxcode{\sphinxupquote{vault.bannedUntil \textless{} current parachain block height}}. Return \sphinxcode{\sphinxupquote{ERR\_VAULT\_BANNED}} if this check fails.

\item {} 
Check if the \sphinxcode{\sphinxupquote{griefingCollateral}} is greater or equal \sphinxcode{\sphinxupquote{IssueGriefingCollateral}}. If this check fails, return \sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL}}.

\item {} 
Lock the user’s griefing collateral by calling the {\hyperref[\detokenize{spec/collateral:lockcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{lockCollateral}}}} function with the \sphinxcode{\sphinxupquote{requester}} as the sender and the \sphinxcode{\sphinxupquote{griefingCollateral}} as the amount.

\item {} 
Call the VaultRegistry {\hyperref[\detokenize{spec/vault-registry:tryincreasetobeissuedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{tryIncreaseToBeIssuedTokens}}}} function with the \sphinxcode{\sphinxupquote{amount}} of tokens to be issued and the \sphinxcode{\sphinxupquote{vault}} identified by its address. This function returns a unique \sphinxcode{\sphinxupquote{btcAddress}} that the user should send Bitcoin to.

\item {} 
Generate an \sphinxcode{\sphinxupquote{issueId}} via {\hyperref[\detokenize{spec/security:generatesecureid}]{\sphinxcrossref{\DUrole{std,std-ref}{generateSecureId}}}}.

\item {} 
Store a new \sphinxcode{\sphinxupquote{Issue}} struct in the \sphinxcode{\sphinxupquote{IssueRequests}} mapping as \sphinxcode{\sphinxupquote{IssueRequests{[}issueId{]} = issue}}, where \sphinxcode{\sphinxupquote{issue}} is the \sphinxcode{\sphinxupquote{Issue}} struct as:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{issue.vault}} is the \sphinxcode{\sphinxupquote{vault}}

\item {} 
\sphinxcode{\sphinxupquote{issue.opentime}} is the current block number

\item {} 
\sphinxcode{\sphinxupquote{issue.griefingCollateral}} is the griefing collateral provided by the user

\item {} 
\sphinxcode{\sphinxupquote{issue.amount}} is the \sphinxcode{\sphinxupquote{amount}} provided as input

\item {} 
\sphinxcode{\sphinxupquote{issue.requester}} is the user’s account

\item {} 
\sphinxcode{\sphinxupquote{issue.btcAddress}} the Bitcoin address of the vault as returned in step 3

\end{itemize}

\item {} 
Issue the \sphinxcode{\sphinxupquote{RequestIssue}} event with the \sphinxcode{\sphinxupquote{issueId}}, the \sphinxcode{\sphinxupquote{requester}} account, \sphinxcode{\sphinxupquote{amount}}, \sphinxcode{\sphinxupquote{vault}}, and \sphinxcode{\sphinxupquote{btcAddress}}.

\end{enumerate}


\subsection{executeIssue}
\label{\detokenize{spec/issue:executeissue}}\label{\detokenize{spec/issue:id3}}
A user completes the issue request by sending a proof of transferring the defined amount of BTC to the vault’s address.


\subsubsection{Specification}
\label{\detokenize{spec/issue:id4}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{executeIssue(requester, issueId, merkleProof, rawTx)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{requester}}: the account of the user.

\item {} 
\sphinxcode{\sphinxupquote{issueId}}: the unique hash created during the \sphinxcode{\sphinxupquote{requestIssue}} function.

\item {} 
\sphinxcode{\sphinxupquote{merkleProof}}: Merkle tree path (concatenated LE SHA256 hashes).

\item {} 
\sphinxcode{\sphinxupquote{rawTx}}: Raw Bitcoin transaction including the transaction inputs and outputs.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ExecuteIssue(issueId, requester, amount, vault)}}: Emits an event with the information about the completed issue request.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_ISSUE\_ID\_NOT\_FOUND}}: The \sphinxcode{\sphinxupquote{issueId}} cannot be found.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_COMMIT\_PERIOD\_EXPIRED}}: The time limit as defined by the \sphinxcode{\sphinxupquote{IssuePeriod}} is not met.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_UNAUTHORIZED\_USER = Unauthorized: Caller must be associated user}}: The caller of this function is not the associated user, and hence not authorized to take this action.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/issue:id5}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/issue:id7}}
\begin{sphinxadmonition}{note}{Note:}
Ideally the \sphinxcode{\sphinxupquote{SecureCollateralThreshold}} in the VaultRegistry should be high enough to prevent the vault from entering into the liquidation state in\sphinxhyphen{}between the request and execute.
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Checks if the \sphinxcode{\sphinxupquote{issueId}} exists. Return \sphinxcode{\sphinxupquote{ERR\_ISSUE\_ID\_NOT\_FOUND}} if not found. Else, loads the according issue request struct as \sphinxcode{\sphinxupquote{issue}}.

\item {} 
Checks if the issue has expired by calling {\hyperref[\detokenize{spec/security:hasexpired}]{\sphinxcrossref{\DUrole{std,std-ref}{hasExpired}}}} in the Security module. If true, this throws \sphinxcode{\sphinxupquote{ERR\_COMMIT\_PERIOD\_EXPIRED}}.

\item {} 
Verify the transaction.
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
Call \sphinxstyleemphasis{verifyTransactionInclusion} in {\hyperref[\detokenize{spec/btc-relay:btc-relay}]{\sphinxcrossref{\DUrole{std,std-ref}{BTC\sphinxhyphen{}Relay}}}}, providing the \sphinxcode{\sphinxupquote{txId}}, and \sphinxcode{\sphinxupquote{merkleProof}} as parameters. If this call returns an error, abort and return the received error.

\item {} 
Call \sphinxstyleemphasis{validateTransaction} in {\hyperref[\detokenize{spec/btc-relay:btc-relay}]{\sphinxcrossref{\DUrole{std,std-ref}{BTC\sphinxhyphen{}Relay}}}}, providing \sphinxcode{\sphinxupquote{rawTx}}, the amount of to\sphinxhyphen{}be\sphinxhyphen{}issued BTC (\sphinxcode{\sphinxupquote{issue.amount}}), the \sphinxcode{\sphinxupquote{vault}}’s Bitcoin address (\sphinxcode{\sphinxupquote{issue.btcAddress}}), and the \sphinxcode{\sphinxupquote{issueId}} as parameters. If this call returns an error, abort and return the received error.

\end{enumerate}

\item {} 
Call the {\hyperref[\detokenize{spec/vault-registry:issuetokens}]{\sphinxcrossref{\DUrole{std,std-ref}{issueTokens}}}} with the \sphinxcode{\sphinxupquote{issue.vault}} and the \sphinxcode{\sphinxupquote{amount}} to decrease the \sphinxcode{\sphinxupquote{toBeIssuedTokens}} and increase the \sphinxcode{\sphinxupquote{issuedTokens}}.

\item {} 
Call the {\hyperref[\detokenize{spec/treasury:mint}]{\sphinxcrossref{\DUrole{std,std-ref}{mint}}}} function in the Treasury with the \sphinxcode{\sphinxupquote{amount}} and the user’s address as the \sphinxcode{\sphinxupquote{receiver}}.

\item {} 
Remove the \sphinxcode{\sphinxupquote{IssueRequest}} from \sphinxcode{\sphinxupquote{IssueRequests}}.

\item {} 
Emit an \sphinxcode{\sphinxupquote{ExecuteIssue}} event with the user’s address, the issueId, the amount, and the Vault’s address.

\end{enumerate}


\subsection{cancelIssue}
\label{\detokenize{spec/issue:cancelissue}}\label{\detokenize{spec/issue:id8}}
If an issue request is not completed on time, the issue request can be cancelled.


\subsubsection{Specification}
\label{\detokenize{spec/issue:id9}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{cancelIssue(sender, issueId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: The sender of the cancel transaction.

\item {} 
\sphinxcode{\sphinxupquote{issueId}}: the unique hash of the issue request.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CancelIssue(sender, issueId)}}: Issues an event with the \sphinxcode{\sphinxupquote{issueId}} that is cancelled.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_ISSUE\_ID\_NOT\_FOUND}}: The \sphinxcode{\sphinxupquote{issueId}} cannot be found.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_TIME\_NOT\_EXPIRED}}: Raises an error if the time limit to call \sphinxcode{\sphinxupquote{executeIssue}} has not yet passed.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_ISSUE\_COMPLETED}}: Raises an error if the issue is already completed.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/issue:id10}}\begin{itemize}
\item {} 
None.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/issue:id11}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if an issue with id \sphinxcode{\sphinxupquote{issueId}} exists. If not, throw \sphinxcode{\sphinxupquote{ERR\_ISSUE\_ID\_NOT\_FOUND}}. Otherwise, load the issue request  as \sphinxcode{\sphinxupquote{issue}}.

\item {} 
Check if the issue has expired by calling {\hyperref[\detokenize{spec/security:hasexpired}]{\sphinxcrossref{\DUrole{std,std-ref}{hasExpired}}}} in the Security module, and throw \sphinxcode{\sphinxupquote{ERR\_TIME\_NOT\_EXPIRED}} if not.

\item {} 
Check if the \sphinxcode{\sphinxupquote{issue.completed}} field is set to true. If yes, throw \sphinxcode{\sphinxupquote{ERR\_ISSUE\_COMPLETED}}.

\item {} 
Call the {\hyperref[\detokenize{spec/vault-registry:decreasetobeissuedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{decreaseToBeIssuedTokens}}}} function in the VaultRegistry with the \sphinxcode{\sphinxupquote{issue.vault}} and the \sphinxcode{\sphinxupquote{issue.amount}} to release the vault’s collateral.

\item {} 
Call the {\hyperref[\detokenize{spec/collateral:slashcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{slashCollateral}}}} function to transfer the \sphinxcode{\sphinxupquote{griefingCollateral}} of the user requesting the issue to the vault assigned to this issue request with the \sphinxcode{\sphinxupquote{issue.requester}} as sender, the \sphinxcode{\sphinxupquote{issue.vault}} as receiver, and \sphinxcode{\sphinxupquote{issue.griefingCollateral}} as amount.

\item {} 
Remove the \sphinxcode{\sphinxupquote{IssueRequest}} from \sphinxcode{\sphinxupquote{IssueRequests}}.

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
Emit a \sphinxcode{\sphinxupquote{CancelIssue}} event with the \sphinxcode{\sphinxupquote{issueId}}.

\end{enumerate}


\section{Events}
\label{\detokenize{spec/issue:events}}

\subsection{RequestIssue}
\label{\detokenize{spec/issue:id12}}
Emit a \sphinxcode{\sphinxupquote{RequestIssue}} event if a user successfully open a issue request.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RequestIssue(issueId, requester, amount, vault, btcAddress)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{issueId}}: A unique hash identifying the issue request.

\item {} 
\sphinxcode{\sphinxupquote{requester}}: The user’s BTC Parachain account.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc to be issued.

\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the vault involved in this issue request.

\item {} 
\sphinxcode{\sphinxupquote{btcAddress}}: The Bitcoin address of the vault.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/issue:requestissue}]{\sphinxcrossref{\DUrole{std,std-ref}{requestIssue}}}}

\end{itemize}


\subsection{ExecuteIssue}
\label{\detokenize{spec/issue:id13}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{ExecuteIssue(issueId, requester, amount, vault)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{issueId}}: A unique hash identifying the issue request.

\item {} 
\sphinxcode{\sphinxupquote{requester}}: The user’s BTC Parachain account.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc to be issued.

\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the vault involved in this issue request.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/issue:executeissue}]{\sphinxcrossref{\DUrole{std,std-ref}{executeIssue}}}}

\end{itemize}


\subsection{CancelIssue}
\label{\detokenize{spec/issue:id14}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{CancelIssue(issueId, sender)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{issueId}}: the unique hash of the issue request.

\item {} 
\sphinxcode{\sphinxupquote{sender}}: The sender of the cancel transaction.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/issue:cancelissue}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelIssue}}}}

\end{itemize}


\section{Error Codes}
\label{\detokenize{spec/issue:error-codes}}
\sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_FOUND}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “There exists no vault with the given account id.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/issue:requestissue}]{\sphinxcrossref{\DUrole{std,std-ref}{requestIssue}}}}

\item {} 
\sphinxstylestrong{Cause}: The specified vault does not exist.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VAULT\_BANNED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The selected vault has been temporarily banned.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/issue:requestissue}]{\sphinxcrossref{\DUrole{std,std-ref}{requestIssue}}}}

\item {} 
\sphinxstylestrong{Cause}:  Issue requests are not possible with temporarily banned Vaults

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “User provided collateral below limit.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/issue:requestissue}]{\sphinxcrossref{\DUrole{std,std-ref}{requestIssue}}}}

\item {} 
\sphinxstylestrong{Cause}: User provided griefingCollateral below \sphinxcode{\sphinxupquote{IssueGriefingCollateral}}.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_UNAUTHORIZED\_USER}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Unauthorized: Caller must be associated user”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/issue:executeissue}]{\sphinxcrossref{\DUrole{std,std-ref}{executeIssue}}}}

\item {} 
\sphinxstylestrong{Cause}: The caller of this function is not the associated user, and hence not authorized to take this action.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_ISSUE\_ID\_NOT\_FOUND}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Requested issue id not found.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/issue:executeissue}]{\sphinxcrossref{\DUrole{std,std-ref}{executeIssue}}}}

\item {} 
\sphinxstylestrong{Cause}: Issue id not found in the \sphinxcode{\sphinxupquote{IssueRequests}} mapping.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_COMMIT\_PERIOD\_EXPIRED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Time to issue interbtc expired.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/issue:executeissue}]{\sphinxcrossref{\DUrole{std,std-ref}{executeIssue}}}}

\item {} 
\sphinxstylestrong{Cause}: The user did not complete the issue request within the block time limit defined by the \sphinxcode{\sphinxupquote{IssuePeriod}}.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_TIME\_NOT\_EXPIRED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Time to issue interbtc not yet expired.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/issue:cancelissue}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelIssue}}}}

\item {} 
\sphinxstylestrong{Cause}: Raises an error if the time limit to call \sphinxcode{\sphinxupquote{executeIssue}} has not yet passed.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_ISSUE\_COMPLETED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Issue completed and cannot be cancelled.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/issue:cancelissue}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelIssue}}}}

\item {} 
\sphinxstylestrong{Cause}: Raises an error if the issue is already completed.

\end{itemize}


\chapter{Vault Nomination}
\label{\detokenize{spec/nomination:vault-nomination}}\label{\detokenize{spec/nomination:id1}}\label{\detokenize{spec/nomination::doc}}

\section{Overview}
\label{\detokenize{spec/nomination:overview}}
Vault Nomination is a feature aimed at increasing \sphinxtitleref{interbtc} issuance capacity which introduces two actors: Nominators and Operators.
Vaults who opt in to this feature take on the additional role of nomination Operators.
A Nominator is anyone who locks their free collateral so that Operators they trust can issue \sphinxtitleref{interbtc} backed by the nominated collateral.
Nominators are rewarded a fraction of the fees generated by their collateral, while the rest of the fees is given to the Operator.
Operators are assumed to be trusted by their nominators not to steal Bitcoin backed by nominated collateral.


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}step}
\label{\detokenize{spec/nomination:step-by-step}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Vaults opt in to the nomination feature, becoming Operators.

\item {} 
The maximum nomination an Operator can receive is bounded by their own locked collateral.

\item {} 
Nominators select one or more Operators and lock their collateral balance onto the BTC Parachain.

\item {} 
Nominators can go offline and their nominated collateral will generate rewards passively.

\item {} 
Operator and Nominator collateral cannot be withdrawn directly. Rather, withdrawals are subject to an unbonding period.

\item {} 
In case of Operator failure, Nominators are returned any left\sphinxhyphen{}over collateral (after victim users are reimbursed).

\end{enumerate}


\section{Protocol}
\label{\detokenize{spec/nomination:protocol}}

\subsection{Security Assumptions and Considerations}
\label{\detokenize{spec/nomination:security-assumptions-and-considerations}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The operating Vault is trusted by its Nominators not to steal the interbtc issued with their collateral.

\item {} 
There is no transitive trust. If a user trusts Vault A and Vault A trusts Vault B, the user does not trust Vault B.

\item {} 
Nominators are mostly\sphinxhyphen{}offline agents, who are slow to respond to system changes.

\item {} 
Vaults are always\sphinxhyphen{}online agents, who can promptly react to system updates.

\item {} 
A Nominator may expose the Vault and the other Nominators to additional economic risk by withdrawing nominated collateral during an exchange rate spike. Similarly, the Vault may expose its Nominators to additional economic risk by withdrawing excess collateral.
\begin{itemize}
\item {} 
Note: in the usual case, this should be handled by having the different collateral thresholds (secure, premium redeem, liquidation). But in extreme cases (very high exchange rate volatility), it might cause concern.

\end{itemize}

\end{enumerate}


\subsection{Vault Nomination Protocol}
\label{\detokenize{spec/nomination:vault-nomination-protocol}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Vaults can choose to opt in and out of the Nomination protocol. If they opt\sphinxhyphen{}in they take on the additional role of an Operator.

\item {} 
Nominators select an Operator to which they can delegate DOT balance as collateral. As a reward, they will earn a fraction of the interbtc and DOT fees generated by this collateral. The other fraction of these fees is received by the Operator.

\item {} 
Vault replacement is disallowed for Operators with nominated collateral. Otherwise, Security Assumptions 1 and 2 would be violated.

\item {} 
The nominated DOT:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
Is locked on the parachain

\item {} 
Cannot be withdrawn by the operating Vault

\item {} 
Is capped at a fraction of the Vault’s deposited collateral (Max Nomination Ratio). This prevents the Operator from withdrawing its entire collateral and only exposing Nominators to economic risk, or stealing without liquidation consequences. This means that an Operator can only withdraw collateral as long as the fraction of nominated collateral does not exceed the threshold cap. Capping Nominator collateral also prevents Operators being “outnumbered” by Nominators and their relative fee earnings being marginalized.

\end{enumerate}

\item {} 
Liquidation slashing is handled as follows.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
In case the collateral managed by the Operator falls below the liquidation threshold, the Operator and Nominators are slashed proportionally to their collateral.

\item {} 
In case the Operator steals Bitcoin deposited at its address, its collateral is used to cover as much of the slashed amount as possible. If the Operator’s collateral was not enough to cover the entire amount, the Nominators are slashed proportionally for the remaining amount.

\end{enumerate}

\item {} 
Collateral withdrawals are first requested and then executed. A withdrawal request:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
Decreases the issuable interbtc capacity.

\item {} 
May be cancelled if not executed. The amount in the cancelled withdrawal request becomes backing collateral again.

\item {} 
Is subject to a window of delay (unbonding period) that allows Nominators and the Operator to react.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumiii}{enumiv}{}{.}%
\item {} 
Operator Unbonding Period. This window is longer, because Nominators are assumed to be mostly offline.

\item {} 
Nominator Unbonding Period. This window is shorter, because the Vault Operator is assumed to always be online.

\end{enumerate}

\end{enumerate}

\item {} 
Collateral withdrawals are subject to the following restrictions.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
The remaining collateralization of an operator must not be below the secure collateral threshold.

\item {} 
Operator withdrawals must not cause nominated collateral to exceed the Max Nomination Ratio.

\end{enumerate}

\item {} 
Forced collateral withdrawal. If an operator’s withdrawal would result in a violation of the Max Nomination Ratio, automatically refund excess nominated collateral to the nominators, proportionally. Both the operator withdrawal and the nominator refunds are subject to the unbonding period.

\item {} 
If an Operator issued zero interbtc, it can deregister and automatically refund Nominators their collateral.

\item {} 
When an Operator is banned, its collateralization is lowered to the secure collateral threshold by automatically refunding nominated DOT, proportionally.

\end{enumerate}


\section{Data Model}
\label{\detokenize{spec/nomination:data-model}}

\subsection{Scalars}
\label{\detokenize{spec/nomination:scalars}}

\subsubsection{NominationEnabled}
\label{\detokenize{spec/nomination:nominationenabled}}
Flag indicating whether this feature is enabled.
As Operators may have issued \sphinxcode{\sphinxupquote{interbtc}} with nominated collateral when this feature is turned off,
a \sphinxcode{\sphinxupquote{False}} value of this scalar only prevents the opting in of new Operators.


\subsubsection{MaxNominatorsPerOperator}
\label{\detokenize{spec/nomination:maxnominatorsperoperator}}
Maximum number of nominators a single operator can have.
\begin{itemize}
\item {} 
Initial value: 100

\end{itemize}


\subsubsection{OperatorUnbondingPeriod}
\label{\detokenize{spec/nomination:operatorunbondingperiod}}
Unbonding period, measured in blocks, that Operator withdrawal requests are subject to.
\begin{itemize}
\item {} 
Initial value: 14400 (24 hours)

\end{itemize}


\subsubsection{NominatorUnbondingPeriod}
\label{\detokenize{spec/nomination:nominatorunbondingperiod}}
Unbonding period, measured in blocks, that Nominator withdrawal requests are subject to.
\begin{itemize}
\item {} 
Initial value: 7200 (12 hours)

\end{itemize}


\subsection{Maps}
\label{\detokenize{spec/nomination:maps}}

\subsubsection{Operators}
\label{\detokenize{spec/nomination:operators}}
Mapping from accounts to Operator structs.


\subsection{Structs}
\label{\detokenize{spec/nomination:structs}}

\subsubsection{Nominator}
\label{\detokenize{spec/nomination:nominator}}
Stores the information of a Nominator.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|l|l|L|}
\hline
\sphinxstyletheadfamily 
Parameter
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{id}}
&
AccountId
&
The ID of the Nominator represented by this struct.
\\
\hline
\sphinxcode{\sphinxupquote{collateral}}
&
DOT
&
Collateral amount nominated.
\\
\hline
\sphinxcode{\sphinxupquote{pendingWithdrawals}}
&
BTreeMap
&
Mapping from the withdrawal request ID to the (maturityBlock, amount) tuple.
\\
\hline
\sphinxcode{\sphinxupquote{collateralToBeWithdrawn}}
&
DOT
&
Collateral that is not backing any interbtc and has been requested for withdrawal.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Operator}
\label{\detokenize{spec/nomination:operator}}
Stores the information of an Operator.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|l|l|L|}
\hline
\sphinxstyletheadfamily 
Parameter
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{id}}
&
AccountId
&
The ID of the Nominator represented by this struct.
\\
\hline
\sphinxcode{\sphinxupquote{nominators}}
&
BTreeMap
&
Mapping from the ID of a nominator to a Nominator struct.
\\
\hline
\sphinxcode{\sphinxupquote{totalNominatedCollateral}}
&
DOT
&
Total amount of collateral received as nomination.
\\
\hline
\sphinxcode{\sphinxupquote{pendingWithdrawals}}
&
BTreeMap
&
Mapping from the withdrawal request ID to the (maturityBlock, amount) tuple.
\\
\hline
\sphinxcode{\sphinxupquote{collateralToBeWithdrawn}}
&
DOT
&
Collateral that is not backing any interbtc and has been requested for withdrawal.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Functions}
\label{\detokenize{spec/nomination:functions}}

\subsection{getMaxNominationRatio}
\label{\detokenize{spec/nomination:getmaxnominationratio}}\label{\detokenize{spec/nomination:id2}}
Returns the maximum nomination ratio (as \%), denoting the maximum \sphinxcode{\sphinxupquote{totalNominatedCollateral:operatorCollateral}} value allowed.
\begin{itemize}
\item {} 
Example (current parameterization): \sphinxcode{\sphinxupquote{(1.5 / 1.2) \sphinxhyphen{} 1 = 25\%}}

\end{itemize}


\subsubsection{Specification}
\label{\detokenize{spec/nomination:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{getMaxNominationRatio()}}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:function-sequence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Return \sphinxcode{\sphinxupquote{(secureCollateralThreshold / auctionCollateralThreshold) \sphinxhyphen{} 1}}

\end{enumerate}


\subsection{setNominationEnabled}
\label{\detokenize{spec/nomination:setnominationenabled}}\label{\detokenize{spec/nomination:id3}}
Set the feature flag for vault nomination.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id4}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{setNominationEnabled(enabled)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{enabled}}: \sphinxcode{\sphinxupquote{True}} if nomination should be enabled, \sphinxcode{\sphinxupquote{False}} if it should be disabled

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id5}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ensure the calling account is root.

\item {} 
Set the NominationEnabled scalar to the value of the \sphinxcode{\sphinxupquote{enabled}} parameter

\end{enumerate}


\subsection{optInToNomination}
\label{\detokenize{spec/nomination:optintonomination}}\label{\detokenize{spec/nomination:id6}}
Become an Operator in the Vault Nomination protocol


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id7}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{optInToNomination(operatorId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the vault to mark as Nomination Operator.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{NominationOptIn(operatorId)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNominationDisabled}}: the nomination feature is disabled.

\item {} 
\sphinxcode{\sphinxupquote{NotAVault}}: the caller of the function is not a vault.

\item {} 
\sphinxcode{\sphinxupquote{VaultAlreadyOptedInToNomination}}: the caller of the function is already opted in.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:preconditions}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id8}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if the nomination feature is enabled. If not, throw \sphinxcode{\sphinxupquote{VaultNominationDisabled}}.

\item {} 
Check if the caller is a vault. If not, throw \sphinxcode{\sphinxupquote{NotAVault}}.

\item {} 
Check if the caller is not already opted in to nomination. If not, throw \sphinxcode{\sphinxupquote{VaultAlreadyOptedInToNomination}}.

\item {} 
Instantiate an \sphinxcode{\sphinxupquote{Operator}} struct.

\item {} 
Add the struct to the \sphinxcode{\sphinxupquote{Operators}} mapping.

\end{enumerate}


\subsection{optOutOfNomination}
\label{\detokenize{spec/nomination:optoutofnomination}}\label{\detokenize{spec/nomination:id9}}
Deregister from being an Operator in the Vault Nomination protocol.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id10}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{optOutOfNomination(operatorId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the vault to deregister from the nomination feature.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{NominationOptOut(operatorId)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}: the caller is not an Operator.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:id11}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id12}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if the caller is a nomination Operator. If not, throw \sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}.

\item {} 
Immediately refund all nominated collateral, bypassing the unbonding period.

\item {} 
Remove caller from the \sphinxcode{\sphinxupquote{Operators}} mapping.

\end{enumerate}


\subsection{depositNominatedCollateral}
\label{\detokenize{spec/nomination:depositnominatedcollateral}}\label{\detokenize{spec/nomination:id13}}
Nominate collateral to a selected Operator.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id14}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{depositNominatedCollateral(nominatorId, operatorId, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nominatorId}}: the id of the user nominating collateral.

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator to receive the nomination.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the amount of collateral to nominate.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{IncreaseNominatedCollateral(nominatorId, operatorId, amount)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNominationDisabled}}: the nomination feature is disabled.

\item {} 
\sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}: the vault is not an Operator.

\item {} 
\sphinxcode{\sphinxupquote{DepositViolatesMaxNominationRatio}}: the \sphinxtitleref{amount} of nomination would cause the Max Nomination Ratio to be exceeded for this \sphinxtitleref{operatorId}.

\item {} 
\sphinxcode{\sphinxupquote{OperatorHasTooManyNominators}}: the number of Nominators to the current Operator has reached \sphinxtitleref{MaxNominatorsPerOperator}.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:id15}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id16}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if the nomination feature is enabled. If not, throw \sphinxcode{\sphinxupquote{VaultNominationDisabled}}.

\item {} 
Check if \sphinxcode{\sphinxupquote{operatorId}} represents an operator. If not, throw \sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}.

\item {} 
Check that the additional nominated \sphinxcode{\sphinxupquote{amount}} does not cause the Max Nomination Ratio to be exceeded. If not, throw \sphinxcode{\sphinxupquote{DepositViolatesMaxNominationRatio}}.

\item {} 
If the caller had no nomination to this Operator, check that the \sphinxcode{\sphinxupquote{MaxNominatorsPerOperator}} would not be exceeded by receiving this nomination. If \sphinxcode{\sphinxupquote{MaxNominatorsPerOperator}} would be exceeded, throw \sphinxcode{\sphinxupquote{OperatorHasTooManyNominators}}.

\item {} 
Update the \sphinxcode{\sphinxupquote{Operator}} object to create or update the \sphinxcode{\sphinxupquote{Nominator}} entry of the caller.

\item {} 
Move collateral from \sphinxcode{\sphinxupquote{nominatorId}} to the \sphinxcode{\sphinxupquote{backing\_collateral}} of \sphinxcode{\sphinxupquote{operatorId}} in the {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}.

\end{enumerate}


\subsection{requestOperatorCollateralWithdrawal}
\label{\detokenize{spec/nomination:requestoperatorcollateralwithdrawal}}\label{\detokenize{spec/nomination:id17}}
Request an operator collateral withdrawal, subject to an unbonding period.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id18}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{requestOperatorCollateralWithdrawal(operatorId, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the caller.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the amount to withdraw.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RequestOperatorCollateralWithdrawal(requestId, operatorId, maturity, amount)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}: the caller is not an Operator.

\item {} 
\sphinxcode{\sphinxupquote{InsufficientCollateral}}: the caller has requested to withdraw more collateral than it owns.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:id19}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id20}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check if \sphinxcode{\sphinxupquote{operatorId}} is an operator. If not, throw \sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}.

\item {} 
Check if the operator has enough collateral of its own (excluding nominations). If not, throw \sphinxcode{\sphinxupquote{InsufficientCollateral}}.

\item {} 
Immediately refund, proportionally, nominated collateral that would cause the Max Nomination Ratio to be exceeded.

\item {} 
Add the withdrawal request to the \sphinxcode{\sphinxupquote{pendingWithdrawals}} array in the \sphinxcode{\sphinxupquote{Operator}} struct.

\item {} 
Decrease the \sphinxcode{\sphinxupquote{backing\_collateral}} of \sphinxcode{\sphinxupquote{operatorId}} in the {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}.

\end{enumerate}


\subsection{requestNominatorCollateralWithdrawal}
\label{\detokenize{spec/nomination:requestnominatorcollateralwithdrawal}}\label{\detokenize{spec/nomination:id21}}
Request a nominator collateral withdrawal, subject to an unbonding period.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id22}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{requestNominatorCollateralWithdrawal(nominatorId, operatorId, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nominatorId}}: the id of the requester.

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator to withdraw from.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the amount to withdraw.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RequestNominatorCollateralWithdrawal(requestId, nominatorId, operatorId, maturity, amount)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}: the \sphinxcode{\sphinxupquote{operatorId}} is not an Operator.

\item {} 
\sphinxcode{\sphinxupquote{NominatorNotFound}}: the \sphinxcode{\sphinxupquote{nominatorId}} is not a Nominator.

\item {} 
\sphinxcode{\sphinxupquote{TooLittleNominatedCollateral}}: the caller has requested to withdraw more collateral than it owns.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:id23}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id24}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check \sphinxcode{\sphinxupquote{operatorId}} is an operator. If not, throw \sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}.

\item {} 
Check \sphinxcode{\sphinxupquote{nominatorId}} is a nominator. If not, throw \sphinxcode{\sphinxupquote{NominatorNotFound}}.

\item {} 
Check if the caller has at least as much nominated collateral as \sphinxcode{\sphinxupquote{amount}}. If not, throw \sphinxcode{\sphinxupquote{TooLittleNominatedCollateral}}.

\item {} 
Add the withdrawal request to the \sphinxcode{\sphinxupquote{pendingWithdrawals}} array in the \sphinxcode{\sphinxupquote{Nominator}} struct for \sphinxcode{\sphinxupquote{nominatorId}}, inside the \sphinxcode{\sphinxupquote{Operator}} struct of \sphinxcode{\sphinxupquote{operatorId}}.

\item {} 
Decrease the \sphinxcode{\sphinxupquote{backing\_collateral}} of \sphinxcode{\sphinxupquote{operatorId}} in the {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}.

\end{enumerate}


\subsection{executeOperatorWithdrawal}
\label{\detokenize{spec/nomination:executeoperatorwithdrawal}}\label{\detokenize{spec/nomination:id25}}
Execute all matured (unbonded) withdrawal requests of an operator.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id26}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{executeOperatorWithdrawal(operatorId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the requester.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ExecuteOperatorCollateralWithdrawal(operatorId, unbondedCollateral)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}: the \sphinxcode{\sphinxupquote{operatorId}} is not an Operator.

\item {} 
\sphinxcode{\sphinxupquote{NoMaturedCollateral}}: either no collateral withdrawal has been requested, or the requests have not matured yet.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:id27}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id28}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check \sphinxcode{\sphinxupquote{operatorId}} is an operator. If not, throw \sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}.

\item {} 
Iterate through the \sphinxcode{\sphinxupquote{withdrawalRequests}} in the \sphinxcode{\sphinxupquote{Operator}} struct to determine how much collateral was unbonded, removing matured requests.

\item {} 
If there is zero unbonded collateral, throw \sphinxcode{\sphinxupquote{NoMaturedCollateral}}.

\end{enumerate}


\subsection{executeNominatorWithdrawal}
\label{\detokenize{spec/nomination:executenominatorwithdrawal}}\label{\detokenize{spec/nomination:id29}}
Execute all matured (unbonded) withdrawal requests of a nominator.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id30}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{executeNominatorWithdrawal(nominatorId, operatorId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nominatorId}}: the id of the requester.

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ExecuteNominatorCollateralWithdrawal(nominatorId, operatorId, unbondedCollateral)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}: the \sphinxcode{\sphinxupquote{operatorId}} is not an Operator.

\item {} 
\sphinxcode{\sphinxupquote{NoMaturedCollateral}}: either no collateral withdrawal has been requested, or the requests have not matured yet.

\item {} 
\sphinxcode{\sphinxupquote{NominatorNotFound}}: the \sphinxcode{\sphinxupquote{nominatorId}} is not a Nominator.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:id31}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id32}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check \sphinxcode{\sphinxupquote{operatorId}} is an operator. If not, throw \sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}.

\item {} 
Check \sphinxcode{\sphinxupquote{nominatorId}} is a nominator. If not, throw \sphinxcode{\sphinxupquote{NominatorNotFound}}.

\item {} 
Iterate through the \sphinxcode{\sphinxupquote{withdrawalRequests}} array in the \sphinxcode{\sphinxupquote{Nominator}} struct inside the \sphinxcode{\sphinxupquote{Operator}} struct for \sphinxcode{\sphinxupquote{operatorId}}. Determine how much collateral was unbonded, removing matured requests.

\item {} 
If there is zero unbonded collateral, throw \sphinxcode{\sphinxupquote{NoMaturedCollateral}}.

\end{enumerate}


\subsection{cancelOperatorWithdrawal}
\label{\detokenize{spec/nomination:canceloperatorwithdrawal}}\label{\detokenize{spec/nomination:id33}}
Cancel an operator’s withdrawal request.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id34}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{cancelOperatorWithdrawal(operatorId, requestId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator.

\item {} 
\sphinxcode{\sphinxupquote{requestId}}: the id of the withdrawal request.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CancelOperatorCollateralWithdrawal(requestId, operatorId)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}: the \sphinxcode{\sphinxupquote{operatorId}} is not an Operator.

\item {} 
\sphinxcode{\sphinxupquote{WithdrawalRequestNotFound}}: no withdrawal request found for the given id.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:id35}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id36}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check \sphinxcode{\sphinxupquote{operatorId}} is an operator. If not, throw \sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}.

\item {} 
Check \sphinxcode{\sphinxupquote{requestId}} corresponds to an actual withdrawal request. If not, throw \sphinxcode{\sphinxupquote{WithdrawalRequestNotFound}}.

\item {} 
Remove the withdrawal request from the \sphinxcode{\sphinxupquote{withdrawalRequests}} array in the \sphinxcode{\sphinxupquote{Operator}} struct for \sphinxcode{\sphinxupquote{operatorId}}.

\item {} 
Increase the backing collateral of \sphinxcode{\sphinxupquote{operatorId}} in the {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}} by the amount in the withdrawal request.

\end{enumerate}


\subsection{cancelNominatorWithdrawal}
\label{\detokenize{spec/nomination:cancelnominatorwithdrawal}}\label{\detokenize{spec/nomination:id37}}
Cancel a nominator’s withdrawal request.


\subsubsection{Specification}
\label{\detokenize{spec/nomination:id38}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{cancelNominatorWithdrawal(nominatorId, operatorId, requestId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nominatorId}}: the id of the nominator.

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator.

\item {} 
\sphinxcode{\sphinxupquote{requestId}}: the id of the withdrawal request.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CancelNominatorCollateralWithdrawal(requestId, nominatorId, operatorId)}}

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}: the \sphinxcode{\sphinxupquote{operatorId}} is not an Operator.

\item {} 
\sphinxcode{\sphinxupquote{NominatorNotFound}}: the \sphinxcode{\sphinxupquote{nominatorId}} is not a Nominator.

\item {} 
\sphinxcode{\sphinxupquote{WithdrawalRequestNotFound}}: no withdrawal request found for the given id.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/nomination:id39}}\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/nomination:id40}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check \sphinxcode{\sphinxupquote{operatorId}} is an operator. If not, throw \sphinxcode{\sphinxupquote{VaultNotOptedInToNomination}}.

\item {} 
Check \sphinxcode{\sphinxupquote{nominatorId}} is a nominator. If not, throw \sphinxcode{\sphinxupquote{NominatorNotFound}}.

\item {} 
Check \sphinxcode{\sphinxupquote{requestId}} corresponds to an actual withdrawal request. If not, throw \sphinxcode{\sphinxupquote{WithdrawalRequestNotFound}}.

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Remove the withdrawal request from the \sphinxcode{\sphinxupquote{withdrawalRequests}} array in the \sphinxcode{\sphinxupquote{Nominator}} struct inside the \sphinxcode{\sphinxupquote{Operator}} struct for \sphinxcode{\sphinxupquote{operatorId}}.

\item {} 
Increase the backing collateral of \sphinxcode{\sphinxupquote{operatorId}} in the {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}} by the amount in the withdrawal request.

\end{enumerate}


\section{Events}
\label{\detokenize{spec/nomination:events}}

\subsection{NominationOptIn}
\label{\detokenize{spec/nomination:nominationoptin}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{NominationOptIn(account)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{account}}: the id of the operator who opten in

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:optintonomination}]{\sphinxcrossref{\DUrole{std,std-ref}{optInToNomination}}}}

\end{itemize}


\subsection{NominationOptOut}
\label{\detokenize{spec/nomination:nominationoptout}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{NominationOptOut(account)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{account}}: the id of the operator who opten out

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:optoutofnomination}]{\sphinxcrossref{\DUrole{std,std-ref}{optOutOfNomination}}}}

\end{itemize}


\subsection{IncreaseNominatedCollateral}
\label{\detokenize{spec/nomination:increasenominatedcollateral}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{IncreaseNominatedCollateral(nominatorId, operatorId, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nominatorId}}: the id of the nominator who is depositing collateral

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator who receives the nomination

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the amount of nominated collateral

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:depositnominatedcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{depositNominatedCollateral}}}}

\end{itemize}


\subsection{RequestOperatorCollateralWithdrawal}
\label{\detokenize{spec/nomination:id41}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RequestOperatorCollateralWithdrawal(requestId, operatorId, maturityBlock, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{requestId}}: the id of the request

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator withdrawing collateral

\item {} 
\sphinxcode{\sphinxupquote{maturityBlock}}: the block when the request can be executed

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the amount to withdraw

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:requestoperatorcollateralwithdrawal}]{\sphinxcrossref{\DUrole{std,std-ref}{requestOperatorCollateralWithdrawal}}}}

\end{itemize}


\subsection{ExecuteOperatorCollateralWithdrawal}
\label{\detokenize{spec/nomination:executeoperatorcollateralwithdrawal}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{ExecuteOperatorCollateralWithdrawal(operatorId, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator withdrawing collateral

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the withdrawn amount

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:executeoperatorwithdrawal}]{\sphinxcrossref{\DUrole{std,std-ref}{executeOperatorWithdrawal}}}}

\end{itemize}


\subsection{CancelOperatorCollateralWithdrawal}
\label{\detokenize{spec/nomination:canceloperatorcollateralwithdrawal}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{CancelOperatorCollateralWithdrawal(requestId, operatorId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{requestId}}: the id of the withdrawal request to cancel

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator who requested the withdrawal

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:canceloperatorwithdrawal}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelOperatorWithdrawal}}}}

\end{itemize}


\subsection{RequestNominatorCollateralWithdrawal}
\label{\detokenize{spec/nomination:id42}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RequestNominatorCollateralWithdrawal(requestId, nominatorId, operatorId, maturityBlock, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{requestId}}: the id of the request

\item {} 
\sphinxcode{\sphinxupquote{nominatorId}}: the id of the operator withdrawing collateral

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator who nominated collateral is being withdrawn

\item {} 
\sphinxcode{\sphinxupquote{maturityBlock}}: the block when the request can be executed

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the amount to withdraw

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:requestnominatorcollateralwithdrawal}]{\sphinxcrossref{\DUrole{std,std-ref}{requestNominatorCollateralWithdrawal}}}}

\end{itemize}


\subsection{ExecuteNominatorCollateralWithdrawal}
\label{\detokenize{spec/nomination:executenominatorcollateralwithdrawal}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{ExecuteNominatorCollateralWithdrawal(nominatorId, operatorId, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nominatorId}}: the id of the operator withdrawing collateral

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator who nominated collateral is being withdrawn

\item {} 
\sphinxcode{\sphinxupquote{amount}}: the withdrawn amount

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:executenominatorwithdrawal}]{\sphinxcrossref{\DUrole{std,std-ref}{executeNominatorWithdrawal}}}}

\end{itemize}


\subsection{CancelNominatorCollateralWithdrawal}
\label{\detokenize{spec/nomination:cancelnominatorcollateralwithdrawal}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{CancelNominatorCollateralWithdrawal(requestId, nominatorId, operatorId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{requestId}}: the id of the withdrawal request to cancel

\item {} 
\sphinxcode{\sphinxupquote{nominatorId}}: the id of the nominator who requested the withdrawal

\item {} 
\sphinxcode{\sphinxupquote{operatorId}}: the id of the operator who nominated collateral is being withdrawn

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/nomination:cancelnominatorwithdrawal}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelNominatorWithdrawal}}}}

\end{itemize}


\chapter{Redeem}
\label{\detokenize{spec/redeem:redeem}}\label{\detokenize{spec/redeem:redeem-protocol}}\label{\detokenize{spec/redeem::doc}}

\section{Overview}
\label{\detokenize{spec/redeem:overview}}
The redeem module allows a user to receive BTC on the Bitcoin chain in return for destroying an equivalent amount of interbtc on the BTC Parachain. The process is initiated by a user requesting a redeem with a vault. The vault then needs to send BTC to the user within a given time limit. Next, the vault has to finalize the process by providing a proof to the BTC Parachain that he has send the right amount of BTC to the user. If the vault fails to deliver a valid proof within the time limit, the user can claim an equivalent amount of DOT from the vault’s locked collateral to reimburse him for his loss in BTC.

Moreover, as part of the liquidation procedure, users are able to directly exchange interbtc for DOT. To this end, a user is able to execute a special liquidation redeem if one or multiple vaults have been liquidated.


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}step}
\label{\detokenize{spec/redeem:step-by-step}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Precondition: A user owns interbtc.

\item {} 
A user locks an amount of interbtc by calling the {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}} function. In this function call, the user selects a vault to execute the redeem request from the list of vaults. The function creates a redeem request with a unique hash.

\item {} 
The selected vault listens for the \sphinxcode{\sphinxupquote{RequestRedeem}} event emitted by the user. The vault then proceeds to transfer BTC to the address specified by the user in the {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}} function including a unique hash in the \sphinxcode{\sphinxupquote{OP\_RETURN}} of one output.

\item {} 
The vault executes the {\hyperref[\detokenize{spec/redeem:executeredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{executeRedeem}}}} function by providing the Bitcoin transaction from step 3 together with the redeem request identifier within the time limit. If the function completes successfully, the locked interbtc are destroyed and the user received its BTC.

\item {} 
Optional: If the user could not receive BTC within the given time (as required in step 4), the user calls {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}} after the redeem time limit. The user can choose either to reimburse, or to retry. In case of reimbursement, the user transfer ownership of the tokens to the vault, but receives collateral in exchange. In case of retry, the user gets back its tokens. In either case, the user is given some part of the vault’s collateral as compensation for the inconvenience. In addition, some amount (depending on the vault’s SLA) of collateral is transferred from the vault to the fee pool.
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
Optional: If during a {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}} the user selects reimbursement, and as a result the vault becomes undercollateralized, then vault does not receive the user’s tokens \sphinxhyphen{} they are burned, and the vault’s \sphinxcode{\sphinxupquote{issuedTokens}} decreases. When, at some later point, it gets sufficient colalteral, it can call {\hyperref[\detokenize{spec/redeem:minttokensforreimbursedredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{mintTokensForReimbursedRedeem}}}} to get the tokens.

\end{enumerate}

\end{enumerate}


\subsection{Security}
\label{\detokenize{spec/redeem:security}}\begin{itemize}
\item {} 
Unique identification of Bitcoin payments: {\hyperref[\detokenize{security_performance/security-analysis:op-return}]{\sphinxcrossref{\DUrole{std,std-ref}{OP\_RETURN}}}}

\end{itemize}


\subsection{Vault Registry}
\label{\detokenize{spec/redeem:vault-registry}}
The data access and state changes to the vault registry are documented in \hyperref[\detokenize{spec/redeem:fig-vault-registry-redeem}]{Fig.\@ \ref{\detokenize{spec/redeem:fig-vault-registry-redeem}}} below.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{VaultRegistry-Redeem}.png}
\caption{The redeem module interacts through three different functions with the vault registry. The green arrow indicate an increase, the red arrows a decrease.}\label{\detokenize{spec/redeem:id19}}\label{\detokenize{spec/redeem:fig-vault-registry-redeem}}\end{figure}


\subsection{Fee Model}
\label{\detokenize{spec/redeem:fee-model}}
When the user makes a redeem request for a certain amount, it will actually not receive that amount of BTC. This is because there are two types of fees subtracted. First, in order to be able to pay the bitcoin transaction cost, the vault is given a budget to spend on on the bitcoin inclusion fee, based on {\hyperref[\detokenize{spec/redeem:redeemtransactionsize}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemTransactionSize}}}} and the inclusion fee estimates reported by the oracle. The actual amount spent on the inclusion fee is not checked. If the vault does not spend the whole budget, it can keep the surplus, although it will not be able to spend it without being liquidated for theft. It may at some point want to withdraw all of its collateral and then to move its bitcoin into a new account. The second fee that the user pays for is the parachain fee that goes to the fee pool to incentivize the various participants in the system.

The main accounting changes of a successful redeem is summarized below. See the individual functions for more details.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeem.amountBTC}} bitcoin is transferred to the user.

\item {} 
\sphinxcode{\sphinxupquote{redeem.amountBTC + redeem.fee + redeem.transferFeeBTC}} is burned from the user.

\item {} 
The vault’s \sphinxcode{\sphinxupquote{issuedTokens}} decreases by \sphinxcode{\sphinxupquote{redeem.amountBTC + redeem.transferFeeBTC}}.

\item {} 
The fee pool content increases by \sphinxcode{\sphinxupquote{redeem.fee}}.

\end{itemize}


\section{Data Model}
\label{\detokenize{spec/redeem:data-model}}

\subsection{Scalars}
\label{\detokenize{spec/redeem:scalars}}

\subsubsection{RedeemPeriod}
\label{\detokenize{spec/redeem:redeemperiod}}\label{\detokenize{spec/redeem:id1}}
The time difference between when an redeem request is created and required completion time by a vault. Concretely, this period is the amount by which {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}} is allowed to increase before the redeem is considered to be expired. The period has an upper limit to ensure the user gets his BTC in time and to potentially punish a vault for inactivity or stealing BTC. Each redeem request records the value of this field upon creation, and when checking the expiry, the maximum of the current RedeemPeriod and the value as recorded in the RedeemRequest is used. This way, users are not negatively impacted by a change in the value.


\subsubsection{RedeemTransactionSize}
\label{\detokenize{spec/redeem:redeemtransactionsize}}\label{\detokenize{spec/redeem:id2}}
The expected size in bytes of a redeem. This is used to set the bitcoin inclusion fee budget.


\subsubsection{RedeemBtcDustValue}
\label{\detokenize{spec/redeem:redeembtcdustvalue}}\label{\detokenize{spec/redeem:id3}}
The minimal amount in BTc a vault can be asked to transfer to the user. Note that this is not equal to the amount requests, since an inclusion fee is deducted from that amount.


\subsection{Maps}
\label{\detokenize{spec/redeem:maps}}

\subsubsection{RedeemRequests}
\label{\detokenize{spec/redeem:redeemrequests}}
Users create redeem requests to receive BTC in return for interbtc. This mapping provides access from a unique hash \sphinxcode{\sphinxupquote{redeemId}} to a \sphinxcode{\sphinxupquote{Redeem}} struct. \sphinxcode{\sphinxupquote{\textless{}redeemId, Redeem\textgreater{}}}.


\subsection{Structs}
\label{\detokenize{spec/redeem:structs}}

\subsubsection{Redeem}
\label{\detokenize{spec/redeem:id4}}
Stores the status and information about a single redeem request.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|l|l|L|}
\hline
\sphinxstyletheadfamily 
Parameter
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{vault}}
&
Account
&
The BTC Parachain address of the vault responsible for this redeem request.
\\
\hline
\sphinxcode{\sphinxupquote{opentime}}
&
u32
&
The {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}} when the redeem request was made. Serves as start for the countdown until when the vault must transfer the BTC.
\\
\hline
\sphinxcode{\sphinxupquote{period}}
&
u32
&
Value of {\hyperref[\detokenize{spec/redeem:redeemperiod}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemPeriod}}}} when the redeem request was made, in case that value changes while this redeem is pending.
\\
\hline
\sphinxcode{\sphinxupquote{amountBTC}}
&
BTC
&
Amount of BTC to be sent to the user.
\\
\hline
\sphinxcode{\sphinxupquote{transferFeeBTC}}
&
BTC
&
Budget for the vault to spend in bitcoin inclusion fees.
\\
\hline
\sphinxcode{\sphinxupquote{fee}}
&
interbtc
&
Parachain fee: amount to be transferred from the user to the fee pool upon completion of the redeem.
\\
\hline
\sphinxcode{\sphinxupquote{premiumDOT}}
&
DOT
&
Amount of DOT to be paid as a premium to this user (if the Vault’s collateral rate was below \sphinxcode{\sphinxupquote{PremiumRedeemThreshold}} at the time of redeeming).
\\
\hline
\sphinxcode{\sphinxupquote{redeemer}}
&
Account
&
The BTC Parachain address of the user requesting the redeem.
\\
\hline
\sphinxcode{\sphinxupquote{btcAddress}}
&
bytes{[}20{]}
&
Base58 encoded Bitcoin public key of the User.
\\
\hline
\sphinxcode{\sphinxupquote{btcHeight}}
&
u32
&
Height of newest bitcoin block in the relay at the time the request is accepted. This is used by the clients upon startup, to determine how many blocks of the bitcoin chain they need to inspect to know if a payment has been made already.
\\
\hline
\sphinxcode{\sphinxupquote{status}}
&
enum
&
The status of the redeem: \sphinxcode{\sphinxupquote{Pending}}, \sphinxcode{\sphinxupquote{Completed}}, \sphinxcode{\sphinxupquote{Retried}} or \sphinxcode{\sphinxupquote{Reimbursed(bool)}}, where bool=true indicates that the vault minted tokens for the amount that the redeemer burned
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Functions}
\label{\detokenize{spec/redeem:functions}}

\subsection{requestRedeem}
\label{\detokenize{spec/redeem:requestredeem}}\label{\detokenize{spec/redeem:id5}}
A user requests to start the redeem procedure.
This function checks the BTC Parachain status in {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} and decides how the redeem process is to be executed.
The following modes are possible:
\begin{itemize}
\item {} 
\sphinxstylestrong{Normal Redeem} \sphinxhyphen{} no errors detected, full BTC value is to be Redeemed.

\item {} 
\sphinxstylestrong{Premium Redeem} \sphinxhyphen{} the selected Vault’s collateral rate has fallen below \sphinxcode{\sphinxupquote{PremiumRedeemThreshold}}. Full BTC value is to be redeemed, but the user is allocated a premium in DOT (\sphinxcode{\sphinxupquote{RedeemPremiumFee}}), taken from the Vault’s to\sphinxhyphen{}be\sphinxhyphen{}released collateral.

\end{itemize}


\subsubsection{Specification}
\label{\detokenize{spec/redeem:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{requestRedeem(redeemer, amountinterbtc, btcAddress, vault)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: address of the user triggering the redeem.

\item {} 
\sphinxcode{\sphinxupquote{amountinterbtc}}: the amount of interbtc to destroy and BTC to receive.

\item {} 
\sphinxcode{\sphinxupquote{btcAddress}}: the address to receive BTC.

\item {} 
\sphinxcode{\sphinxupquote{vault}}: the vault selected for the redeem request.

\end{itemize}

\sphinxstyleemphasis{Returns}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemId}}: A unique hash identifying the redeem request.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RequestRedeem(redeemId, redeemer, amount, vault, btcAddress)}}

\end{itemize}

\sphinxstyleemphasis{Preconditions}

Let \sphinxcode{\sphinxupquote{burnedTokens}} be \sphinxcode{\sphinxupquote{amountinterbtc}} minus the result of the multiplication of {\hyperref[\detokenize{spec/fee:redeemfee}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemFee}}}} and \sphinxcode{\sphinxupquote{amountinterbtc}}. Then:
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxstyleemphasis{redeemer}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\item {} 
The selected vault MUST NOT be banned.

\item {} 
The selected vault MUST NOT be liquidated.

\item {} 
The redeemer MUST have at least \sphinxcode{\sphinxupquote{amountinterbtc}} free tokens.

\item {} 
\sphinxcode{\sphinxupquote{burnedTokens}} minus the inclusion fee MUST be above the {\hyperref[\detokenize{spec/redeem:redeembtcdustvalue}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemBtcDustValue}}}}, where the inclusion fee is the multiplication of {\hyperref[\detokenize{spec/redeem:redeemtransactionsize}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemTransactionSize}}}} and the fee rate estimate reported by the oracle.

\item {} 
The vault’s \sphinxcode{\sphinxupquote{issuedTokens}} MUST be at least \sphinxcode{\sphinxupquote{vault.toBeRedeemedTokens + burnedTokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}

Let \sphinxcode{\sphinxupquote{burnedTokens}} be \sphinxcode{\sphinxupquote{amountinterbtc}} minus the result of the multiplication of {\hyperref[\detokenize{spec/fee:redeemfee}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemFee}}}} and \sphinxcode{\sphinxupquote{amountinterbtc}}. Then:
\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} MUST increase by \sphinxcode{\sphinxupquote{burnedTokens}}.

\item {} 
\sphinxcode{\sphinxupquote{amountinterbtc}} of the redeemer’s tokens MUST be locked by this transaction.

\item {} 
{\hyperref[\detokenize{spec/vault-registry:decreasetobereplacedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{decreaseToBeReplacedTokens}}}} MUST be called, supplying \sphinxcode{\sphinxupquote{vault}} and \sphinxcode{\sphinxupquote{burnedTokens}}. The returned \sphinxcode{\sphinxupquote{replaceCollateral}} MUST be released by this function.

\item {} \begin{description}
\item[{A new \sphinxcode{\sphinxupquote{RedeemRequest}} MUST be added to the \sphinxcode{\sphinxupquote{RedeemRequests}} map, with the following value:}] \leavevmode\begin{itemize}
\item {} 
\item {} 
\sphinxcode{\sphinxupquote{redeem.vault}} is the requested \sphinxcode{\sphinxupquote{vault}}

\item {} 
\sphinxcode{\sphinxupquote{redeem.opentime}} is the current {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}}

\item {} 
\sphinxcode{\sphinxupquote{redeem.fee}} is {\hyperref[\detokenize{spec/fee:redeemfee}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemFee}}}} multiplied by \sphinxcode{\sphinxupquote{amountinterbtc}},

\item {} 
\sphinxcode{\sphinxupquote{redeem.transferFeeBtc}} is the inclusion\_fee, which is the multiplication of {\hyperref[\detokenize{spec/redeem:redeemtransactionsize}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemTransactionSize}}}} and the fee rate estimate reported by the oracle,

\item {} 
\sphinxcode{\sphinxupquote{redeem.amount\_btc}} is \sphinxcode{\sphinxupquote{amountinterbtc \sphinxhyphen{} redeem.fee \sphinxhyphen{} redeem.transferFeeBtc}},

\item {} 
\sphinxcode{\sphinxupquote{redeem.period}} is the current value of the {\hyperref[\detokenize{spec/redeem:redeemperiod}]{\sphinxcrossref{\DUrole{std,std-ref}{RedeemPeriod}}}},

\item {} 
\sphinxcode{\sphinxupquote{redeem.redeemer}} is the \sphinxcode{\sphinxupquote{redeemer}} argument,

\item {} 
\sphinxcode{\sphinxupquote{redeem.btc\_address}} is the \sphinxcode{\sphinxupquote{btcAddress}} argument,

\item {} 
\sphinxcode{\sphinxupquote{redeem.btc\_height}} is the current height of the btc relay,

\item {} 
\sphinxcode{\sphinxupquote{redeem.status}} is \sphinxcode{\sphinxupquote{Pending}},

\item {} 
If the vault’s collateralization rate is above the {\hyperref[\detokenize{spec/vault-registry:premiumcollateralthreshold}]{\sphinxcrossref{\DUrole{std,std-ref}{PremiumRedeemThreshold}}}}, then \sphinxcode{\sphinxupquote{redeem.premium}} is \sphinxcode{\sphinxupquote{0}},

\item {} 
If the vault’s collateralization rate is below the {\hyperref[\detokenize{spec/vault-registry:premiumcollateralthreshold}]{\sphinxcrossref{\DUrole{std,std-ref}{PremiumRedeemThreshold}}}}, then \sphinxcode{\sphinxupquote{redeem.premium}} is {\hyperref[\detokenize{spec/fee:premiumredeemfee}]{\sphinxcrossref{\DUrole{std,std-ref}{PremiumRedeemFee}}}} multiplied by the worth of \sphinxcode{\sphinxupquote{redeem.amount\_btc}},

\end{itemize}

\end{description}

\end{itemize}


\subsection{liquidationRedeem}
\label{\detokenize{spec/redeem:liquidationredeem}}\label{\detokenize{spec/redeem:id6}}
A user executes a liquidation redeem that exchanges interbtc for DOT from the \sphinxtitleref{LiquidationVault}. The 1:1 backing is being recovered, hence this function burns interbtc without releasing any BTC.


\subsubsection{Specification}
\label{\detokenize{spec/redeem:id7}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{liquidationRedeem(redeemer, amountinterbtc)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: address of the user triggering the redeem.

\item {} 
\sphinxcode{\sphinxupquote{amountinterbtc}}: the amount of interbtc to destroy.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RequestRedeem(redeemID, redeemer, redeemAmountWrapped, feeWrapped, premium, vaultID, userBtcAddress, transferFeeBtc)}}

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN:2}}.

\item {} 
The function call MUST be signed.

\item {} 
The redeemer MUST have at least \sphinxcode{\sphinxupquote{amountinterbtc}} free tokens.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{amountinterbtc}} tokens MUST be burned from the user.

\item {} 
{\hyperref[\detokenize{spec/vault-registry:redeemtokensliquidation}]{\sphinxcrossref{\DUrole{std,std-ref}{redeemTokensLiquidation}}}} MUST be called with \sphinxcode{\sphinxupquote{redeemer}} and \sphinxcode{\sphinxupquote{amountinterbtc}} as arguments.

\end{itemize}


\subsection{executeRedeem}
\label{\detokenize{spec/redeem:executeredeem}}\label{\detokenize{spec/redeem:id8}}
A vault calls this function after receiving an \sphinxcode{\sphinxupquote{RequestRedeem}} event with his public key. Before calling the function, the vault transfers the specific amount of BTC to the BTC address given in the original redeem request. The vault completes the redeem with this function.


\subsubsection{Specification}
\label{\detokenize{spec/redeem:id9}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{executeRedeem(vault, redeemId, merkleProof, rawTx)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: the vault responsible for executing this redeem request.

\item {} 
\sphinxcode{\sphinxupquote{redeemId}}: the unique hash created during the \sphinxcode{\sphinxupquote{requestRedeem}} function.

\item {} 
\sphinxcode{\sphinxupquote{merkleProof}}: Merkle tree path (concatenated LE SHA256 hashes).

\item {} 
\sphinxcode{\sphinxupquote{rawTx}}: Raw Bitcoin transaction including the transaction inputs and outputs.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ExecuteRedeem(redeemer, redeemId, amount, vault)}}:

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The function call MUST be signed be \sphinxstyleemphasis{someone}, i.e. not necessarily the \sphinxstyleemphasis{redeemer}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN:2}}.

\item {} 
A \sphinxstyleemphasis{pending} \sphinxcode{\sphinxupquote{RedeemRequest}} MUST exist with an id equal to \sphinxcode{\sphinxupquote{redeemId}}.

\item {} 
The request MUST NOT have expired.

\item {} \begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{rawTx}} MUST decode to a valid transaction that transfers at least the amount specified in the \sphinxcode{\sphinxupquote{RedeemRequest}} struct. It MUST be a transaction to the correct address, and provide the expected OP\_RETURN, based on the \sphinxcode{\sphinxupquote{RedeemRequest}}.

\end{itemize}

\item {} 
The \sphinxcode{\sphinxupquote{merkleProof}} MUST contain a valid proof of of \sphinxcode{\sphinxupquote{rawTX}}.

\item {} 
The bitcoin payment MUST have been submitted to the relay chain, and MUST have sufficient confirmations.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemRequest.amount\_btc \sphinxhyphen{} redeemRequest.transferFeeBtc}} of the tokens in the redeemer’s account MUST be burned.

\item {} 
\sphinxcode{\sphinxupquote{redeemRequest.fee}} MUST be unlocked and transferred from the redeemer’s account to the fee pool.

\item {} 
{\hyperref[\detokenize{spec/vault-registry:redeemtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{redeemTokens}}}} MUST be called, supplying \sphinxcode{\sphinxupquote{redeemRequest.vault}}, \sphinxcode{\sphinxupquote{redeemRequest.amountBtc \sphinxhyphen{} redeemRequest.transferFeeBtc}}, \sphinxcode{\sphinxupquote{redeemRequest.premium}} and \sphinxcode{\sphinxupquote{redeemRequest.redeemer}} as arguments.

\item {} 
\sphinxcode{\sphinxupquote{redeemRequest.status}} MUST be set to \sphinxcode{\sphinxupquote{Completed}}.

\end{itemize}


\subsection{cancelRedeem}
\label{\detokenize{spec/redeem:cancelredeem}}\label{\detokenize{spec/redeem:id10}}
If a redeem request is not completed on time, the redeem request can be cancelled.
The user that initially requested the redeem process calls this function to obtain the Vault’s collateral as compensation for not refunding the BTC back to his address.

The failed vault is banned from further issue, redeem and replace requests for a pre\sphinxhyphen{}defined time period (\sphinxcode{\sphinxupquote{PunishmentDelay}} as defined in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}).

The user is able to choose between reimbursement and retrying. If the user chooses the retry, it gets back the tokens, and a punishment fee is transferred from the vault to the user. If the user chooses reimbursement, then he receives the equivalent worth of the tokens in collateral, plus a punishment fee. In this case, the tokens are transferred from the user to the vault. In either case, the vault may also be slashed an additional punishment that goes to the fee pool.

With the SLA model additions, the punishment fee paid to the user stays constant (i.e., the user always receives the punishment fee of e.g. 10\%). However, vaults may be slashed more than the punishment fee, as determined by the SLA. The surplus slashed collateral is routed into the Parachain Fee pool and handled like regular fee income. For example, if the vault is punished with 20\%, 10\% punishment fee is paid to the user and 10\% is paid to the fee pool.


\subsubsection{Specification}
\label{\detokenize{spec/redeem:id11}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{cancelRedeem(redeemId, reimburse)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemId}}: the unique hash of the redeem request.

\item {} 
\sphinxcode{\sphinxupquote{reimburse}}: boolean flag, specifying if the user wishes to be reimbursed in DOT and slash the vault, or wishes to keep the interbtc (and retry to redeem with another Vault).

\end{itemize}

\sphinxstyleemphasis{Events}

\sphinxcode{\sphinxupquote{CancelRedeem(redeemId, redeemer, amountBtc, fee, vault)}}: Emits an event with the \sphinxcode{\sphinxupquote{redeemId}} that is cancelled.

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\item {} 
A \sphinxstyleemphasis{pending} \sphinxcode{\sphinxupquote{RedeemRequest}} MUST exist with an id equal to \sphinxcode{\sphinxupquote{redeemId}}.

\item {} 
The function call MUST be signed by \sphinxcode{\sphinxupquote{redeemRequest.redeemer}}, i.e. this function can only be called by the account who made the redeem request.

\item {} 
The request MUST be expired.

\end{itemize}

\sphinxstyleemphasis{Postconditions}

Let \sphinxcode{\sphinxupquote{amountIncludingParachainFee}} be equal to the worth in collateral of \sphinxcode{\sphinxupquote{redeem.amount\_btc + redeem.transfer\_fee\_btc}}. Then:
\begin{itemize}
\item {} 
If the vault is liquidated, the redeemer MUST be transferred part of the vault’s collateral: an amount of  \sphinxcode{\sphinxupquote{vault.backingCollateral * ((amountIncludingParachainFee) / vault.to\_be\_redeemed\_tokens)}}.

\item {} \begin{description}
\item[{If the vault is \sphinxstyleemphasis{not} liquidated, the fellowing collateral changes are made:}] \leavevmode\begin{itemize}
\item {} 
If \sphinxcode{\sphinxupquote{reimburse}} is true, the user SHOULD be reimbursed the worth of \sphinxcode{\sphinxupquote{amountIncludingParachainFee}} in collateral. The transfer MUST be saturating, i.e. if the amount is not available, it should transfer whatever amount \sphinxstyleemphasis{is} available.

\item {} 
A punishment fee SHOULD be tranferred from the vault’s backing collateral to the reedeemer: an amount of {\hyperref[\detokenize{spec/fee:punishmentfee}]{\sphinxcrossref{\DUrole{std,std-ref}{PunishmentFee}}}} times the worth of \sphinxcode{\sphinxupquote{amountIncludingParachainFee}}. The transfer MUST be saturating, i.e. if the amount is not available, it should transfer whatever amount \sphinxstyleemphasis{is} available.

\item {} 
An additional punishment fee SHOULD be transferred to the fee pool: an amount ranging from {\hyperref[\detokenize{spec/vault-registry:liquidationcollateralthreshold}]{\sphinxcrossref{\DUrole{std,std-ref}{LiquidationCollateralThreshold}}}} to {\hyperref[\detokenize{spec/vault-registry:premiumcollateralthreshold}]{\sphinxcrossref{\DUrole{std,std-ref}{PremiumRedeemThreshold}}}} times the worth of \sphinxcode{\sphinxupquote{amountIncludingParachainFee}}, depending on the vault’s SLA. The transfer MUST be saturating, i.e. if the amount is not available, it should transfer whatever amount \sphinxstyleemphasis{is} available.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{If \sphinxcode{\sphinxupquote{reimburse}} is true:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeem.fee}} MUST be transferred from the vault to the fee pool.

\item {} \begin{description}
\item[{If after the loss of collateral the vault is below the {\hyperref[\detokenize{spec/vault-registry:securecollateralthreshold}]{\sphinxcrossref{\DUrole{std,std-ref}{SecureCollateralThreshold}}}}:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{amountIncludingParachainFee}} of the user’s tokens are \sphinxstyleemphasis{burned}.

\item {} 
{\hyperref[\detokenize{spec/vault-registry:decreasetokens}]{\sphinxcrossref{\DUrole{std,std-ref}{decreaseTokens}}}} MUST be called, supplying the vault, the user, and \sphinxcode{\sphinxupquote{amountIncludingParachainFee}} as arguments.

\item {} 
The \sphinxcode{\sphinxupquote{redeem.status}} is set to \sphinxcode{\sphinxupquote{Reimbursed(false)}}, where the \sphinxcode{\sphinxupquote{false}} indicates that the vault has not yet received the tokens.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{If after the loss of collateral the vault remains above the {\hyperref[\detokenize{spec/vault-registry:securecollateralthreshold}]{\sphinxcrossref{\DUrole{std,std-ref}{SecureCollateralThreshold}}}}:}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{amountIncludingParachainFee}} of the user’s tokens MUST be unlocked and transferred to the vault.

\item {} 
{\hyperref[\detokenize{spec/vault-registry:decreasetoberedeemedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{decreaseToBeRedeemedTokens}}}} MUST be called, supplying the vault and \sphinxcode{\sphinxupquote{amountIncludingParachainFee}} as arguments.

\item {} 
The \sphinxcode{\sphinxupquote{redeem.status}} is set to \sphinxcode{\sphinxupquote{Reimbursed(true)}}, where the \sphinxcode{\sphinxupquote{true}} indicates that the vault has received the tokens.

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{If \sphinxcode{\sphinxupquote{reimburse}} is false:}] \leavevmode\begin{itemize}
\item {} 
All the user’s tokens that were locked in {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}} MUST be unlocked, i.e. an amount of \sphinxcode{\sphinxupquote{redeem.amount\_btc + redeem.fee + redeem.transfer\_fee\_btc}}.

\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} MUST decrease by \sphinxcode{\sphinxupquote{amountIncludingParachainFee}}.

\end{itemize}

\end{description}

\item {} 
The vault MUST be banned.

\end{itemize}


\subsection{mintTokensForReimbursedRedeem}
\label{\detokenize{spec/redeem:minttokensforreimbursedredeem}}\label{\detokenize{spec/redeem:id12}}
If a redeemrequest has the status \sphinxcode{\sphinxupquote{Reimbursed(false)}}, the vault was unable to back the to be received tokens at the time of the \sphinxcode{\sphinxupquote{cancelRedeem}}. After gaining sufficient collateral, the vault can call this function to finally get its tokens.


\subsubsection{Specification}
\label{\detokenize{spec/redeem:id13}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{mintTokensForReimbursedRedeem(vault, redeemId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemId}}: the unique hash of the redeem request.

\item {} 
\sphinxcode{\sphinxupquote{reimburse}}: boolean flag, specifying if the user wishes to be reimbursed in DOT and slash the vault, or wishes to keep the interbtc (and retry to redeem with another Vault).

\end{itemize}

\sphinxstyleemphasis{Events}

\sphinxcode{\sphinxupquote{MintTokensForReimbursedRedeem(vaultId, redeemId, amountMinted)}}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\item {} 
A \sphinxcode{\sphinxupquote{RedeemRequest}} MUST exist with an id equal to \sphinxcode{\sphinxupquote{redeemId}}.

\item {} 
\sphinxcode{\sphinxupquote{redeem.status}} MUST be \sphinxcode{\sphinxupquote{Reimbursed(false)}}.

\item {} 
The vault MUST have sufficient collateral to remain above the {\hyperref[\detokenize{spec/vault-registry:securecollateralthreshold}]{\sphinxcrossref{\DUrole{std,std-ref}{SecureCollateralThreshold}}}} after issuing \sphinxcode{\sphinxupquote{redeem.amount\_btc + redeem.transfer\_fee\_btc}} tokens.

\item {} 
The vault MUST NOT be banned.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxcode{\sphinxupquote{redeem.vault}}, i.e. this function can only be called by the the vault.

\item {} 
{\hyperref[\detokenize{spec/vault-registry:tryincreasetobeissuedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{tryIncreaseToBeIssuedTokens}}}} and {\hyperref[\detokenize{spec/vault-registry:issuetokens}]{\sphinxcrossref{\DUrole{std,std-ref}{issueTokens}}}} MUST be called, both with the vault and \sphinxcode{\sphinxupquote{redeem.amount\_btc + redeem.transfer\_fee\_btc}} as arguments.

\item {} 
\sphinxcode{\sphinxupquote{redeem.amount\_btc + redeem.transfer\_fee\_btc}} tokens MUST be minted to the vault.

\end{itemize}


\section{Events}
\label{\detokenize{spec/redeem:events}}

\subsection{RequestRedeem}
\label{\detokenize{spec/redeem:id14}}
Emit an event when a redeem request is created. This event needs to be monitored by the vault to start the redeem request.

\sphinxstyleemphasis{Event Signature}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RequestRedeem(redeemID, redeemer, redeemAmountWrapped, feeWrapped, premium, vaultID, userBtcAddress, transferFeeBtc)}}

\end{itemize}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemID}}: the unique identifier of this redeem request.

\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: address of the user triggering the redeem.

\item {} 
\sphinxcode{\sphinxupquote{redeemAmountWrapped}}: the amount to be received by the user.

\item {} 
\sphinxcode{\sphinxupquote{feeWrapped}}: the fee to be given to the foo pool.

\item {} 
\sphinxcode{\sphinxupquote{premium}}: the premium to be given to the user, if any.

\item {} 
\sphinxcode{\sphinxupquote{vaultID}}: the vault selected for the redeem request.

\item {} 
\sphinxcode{\sphinxupquote{userBtcAddress}}: the address the vault is to transfer the funds to.

\item {} 
\sphinxcode{\sphinxupquote{transferFeeBtc}}: the budget the vault has to spend on bitcoin inclusion fees, paid for by the user.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{requestRedeem}

\end{itemize}


\subsection{LiquidationRedeem}
\label{\detokenize{spec/redeem:id15}}
Emit an event when a user does a liquidation redeem.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{LiquidationRedeem(redeemer, amountinterbtc)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: address of the user triggering the redeem.

\item {} 
\sphinxcode{\sphinxupquote{amountinterbtc}}: the amount of interbtc to burned.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{liquidationRedeem}

\end{itemize}


\subsection{ExecuteRedeem}
\label{\detokenize{spec/redeem:id16}}
Emit an event when a redeem request is successfully executed by a vault.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{ExecuteRedeem(redeemer, redeemId, amountinterbtc, vault)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: address of the user triggering the redeem.

\item {} 
\sphinxcode{\sphinxupquote{redeemId}}: the unique hash created during the \sphinxcode{\sphinxupquote{requestRedeem}} function.

\item {} 
\sphinxcode{\sphinxupquote{amountinterbtc}}: the amount of interbtc to destroy and BTC to receive.

\item {} 
\sphinxcode{\sphinxupquote{vault}}: the vault responsible for executing this redeem request.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{executeRedeem}

\end{itemize}


\subsection{CancelRedeem}
\label{\detokenize{spec/redeem:id17}}
Emit an event when a user cancels a redeem request that has not been fulfilled after the \sphinxcode{\sphinxupquote{RedeemPeriod}} has passed.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{CancelRedeem(redeemId, redeemer, amountBtc, fee, vault)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemId}}: the unique hash of the redeem request.

\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: The redeemer starting the redeem process.

\item {} 
\sphinxcode{\sphinxupquote{amountBtc}}: the amount that was to be received by the user.

\item {} 
\sphinxcode{\sphinxupquote{fee}}: the parachain fee that was to be added to the fee pool upon a successful redeem.

\item {} 
\sphinxcode{\sphinxupquote{vault}}: the vault who failed to execute the redeem.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{cancelRedeem}

\end{itemize}


\subsection{MintTokensForReimbursedRedeem}
\label{\detokenize{spec/redeem:id18}}
Emit an event when a vault minted the tokens corresponding the a cancelled redeem that was reimbursed to the user, when the vault did not have sufficient collateral at the time of the cancellation to back the tokens.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{MintTokensForReimbursedRedeem(vaultId, redeemId, amountMinted)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: if of the vault that now mints the tokens.

\item {} 
\sphinxcode{\sphinxupquote{redeemId}}: the unique hash of the redeem request.

\item {} 
\sphinxcode{\sphinxupquote{amountMinted}}: the amount that the vault just minted.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{mintTokensForReimbursedRedeem}

\end{itemize}


\section{Error Codes}
\label{\detokenize{spec/redeem:error-codes}}
\sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_FOUND}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “There exists no vault with the given account id.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}}, {\hyperref[\detokenize{spec/redeem:liquidationredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{liquidationRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}: The specified vault does not exist.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_AMOUNT\_EXCEEDS\_USER\_BALANCE}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The requested amount exceeds the user’s balance.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}}, {\hyperref[\detokenize{spec/redeem:liquidationredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{liquidationRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}: If the user is trying to redeem more BTC than his interbtc balance.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VAULT\_BANNED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The selected vault has been temporarily banned.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}:  Redeem requests are not possible with temporarily banned Vaults

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_AMOUNT\_EXCEEDS\_VAULT\_BALANCE}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The requested amount exceeds the vault’s balance.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}}, {\hyperref[\detokenize{spec/redeem:liquidationredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{liquidationRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}: If the user is trying to redeem from a vault that has less BTC locked than requested for redeem.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REDEEM\_ID\_NOT\_FOUND}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The \sphinxcode{\sphinxupquote{redeemId}} cannot be found.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:executeredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{executeRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}: The \sphinxcode{\sphinxupquote{redeemId}} in the \sphinxcode{\sphinxupquote{RedeemRequests}} mapping returned \sphinxcode{\sphinxupquote{None}}.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REDEEM\_PERIOD\_EXPIRED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The redeem period expired.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:executeredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{executeRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}: The time limit as defined by the \sphinxcode{\sphinxupquote{RedeemPeriod}} is not met.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_UNAUTHORIZED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Caller is not authorized to call this function.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}} | {\hyperref[\detokenize{spec/redeem:minttokensforreimbursedredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{mintTokensForReimbursedRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}: Only the user can call {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}}, and only the vault can call {\hyperref[\detokenize{spec/redeem:minttokensforreimbursedredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{mintTokensForReimbursedRedeem}}}}.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REDEEM\_PERIOD\_NOT\_EXPIRED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The period to complete the redeem request is not yet expired.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}:  Raises an error if the time limit to call \sphinxcode{\sphinxupquote{executeRedeem}} has not yet passed.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REDEEM\_CANCELLED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The redeem is in an unexpected cancelled state.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}} | {\hyperref[\detokenize{spec/redeem:minttokensforreimbursedredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{mintTokensForReimbursedRedeem}}}} | {\hyperref[\detokenize{spec/redeem:executeredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{executeRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}:  The status of the redeem is not as required for this call.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REDEEM\_COMPLETED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The redeem is already completed.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}} | {\hyperref[\detokenize{spec/redeem:executeredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{executeRedeem}}}}

\item {} 
\sphinxstylestrong{Cause}:  The status of the redeem is not as expected for this call.

\end{itemize}


\chapter{Refund}
\label{\detokenize{spec/refund:refund}}\label{\detokenize{spec/refund:refund-protocol}}\label{\detokenize{spec/refund::doc}}

\section{Overview}
\label{\detokenize{spec/refund:overview}}
The Refund module is a user failsafe mechanism. In case a user accidentally locks more Bitcoin than the actual issue request, the refund mechanism seeks to ensure that either (1) the initial issue request is increased to issue more interbtc or (2) the BTC are returned to the sending user.


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}step}
\label{\detokenize{spec/refund:step-by-step}}
If a user falsely sends additional BTC (i.e., \(|\text{BTC}| > |\text{interbtc}|\)) during the issue process:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} \begin{description}
\item[{\sphinxstylestrong{Case 1: The originally selected vault has sufficient collateral locked to cover the entire BTC amount sent by the user}:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
Increase the issue request interbtc amount and the fee to reflect the actual BTC amount paid by the user.

\item {} 
As before, issue the interbtc to the user and forward the fees.

\item {} 
Emit an event that the issue amount was increased.

\end{enumerate}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{Case 2: The originally selected vault does NOT have sufficient collateral locked to cover the additional BTC amount sent by the user}:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
Automatically create a return request from the issue module that includes a return fee (deducted from the originial BTC payment) paid to the vault returning the BTC.

\item {} 
The vault fulfills the return request via a transaction inclusion proof (similar to execute issue). However, this does not create a new interbtc.

\end{enumerate}

\end{description}

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
Only case 2 is handled in this module. Case 1 is handled directly by the issue module.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Normally, enforcing actions by a vault is achieved by locking collateral of the vault and slashing the vault in case of misbehavior. In the case where a user sends too many BTC and the vault does not have enough “free” collateral left, we cannot lock more collateral. However, the original vault cannot move the additional BTC sent as this would be flagged as theft and the vault would get slashed. The vault can possibly take the overpaid BTC though if the vault would not be backing any interbtc any longer (e.g. due to redeem/replace).
\end{sphinxadmonition}


\subsection{Security}
\label{\detokenize{spec/refund:security}}\begin{itemize}
\item {} 
Unique identification of Bitcoin payments: {\hyperref[\detokenize{security_performance/security-analysis:op-return}]{\sphinxcrossref{\DUrole{std,std-ref}{OP\_RETURN}}}}

\end{itemize}


\chapter{Replace}
\label{\detokenize{spec/replace:replace}}\label{\detokenize{spec/replace:replace-protocol}}\label{\detokenize{spec/replace::doc}}

\section{Overview}
\label{\detokenize{spec/replace:overview}}
The Replace module allows a vault (\sphinxstyleemphasis{OldVault}) to be replaced by transferring the BTC it is holding locked to another vault (\sphinxstyleemphasis{NewVault}), which provides the necessary DOT collateral. As a result, the DOT collateral of the \sphinxstyleemphasis{OldVault}, corresponding to the amount of replaced BTC, is unlocked. The \sphinxstyleemphasis{OldVault} must thereby provide some amount of collateral to protect against griefing attacks, where the \sphinxstyleemphasis{OldVault} never finalizes the Replace protocol and the \sphinxstyleemphasis{NewVault} hence temporarily locked DOT collateral for nothing.

The \sphinxstyleemphasis{OldVault} is responsible for ensuring that it has sufficient BTC to pay for the transaction fees.

Conceptually, the Replace protocol resembles a SPV atomic cross\sphinxhyphen{}chain swap.


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}Step}
\label{\detokenize{spec/replace:step-by-step}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Precondition: a vault (\sphinxstyleemphasis{OldVault}) has locked DOT collateral in the \sphinxhref{vault-registry}{Vault Registry} and has issued interbtc tokens, i.e., holds BTC on Bitcoin.

\item {} 
\sphinxstyleemphasis{OldVault} submits a replacement request, indicating how much BTC is to be migrated by calling the {\hyperref[\detokenize{spec/replace:requestreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{requestReplace}}}} function.
\begin{itemize}
\item {} 
\sphinxstyleemphasis{OldVault} is required to lock some amount of DOT collateral ({\hyperref[\detokenize{spec/fee:replacegriefingcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{ReplaceGriefingCollateral}}}}) as griefing protection, to prevent \sphinxstyleemphasis{OldVault} from holding \sphinxstyleemphasis{NewVault}’s DOT collateral locked in the BTC Parachain without ever finalizing the redeem protocol (transfer of BTC).

\end{itemize}

\item {} 
Optional: If an \sphinxstyleemphasis{OldVault} has changed its mind or can’t find a \sphinxstyleemphasis{NewVault} to replace it, it can call the {\hyperref[\detokenize{spec/replace:withdrawreplacerequest}]{\sphinxcrossref{\DUrole{std,std-ref}{withdrawReplaceRequest}}}} function to withdraw the request of some amount. For example, if \sphinxstyleemphasis{OldVault} requested a replacement for 10 tokens, and 2 tokens have been accepted by some \sphinxstyleemphasis{NewVault}, then it can withdraw up to 8 tokens from being replaced.

\item {} 
A new candidate vault (\sphinxstyleemphasis{NewVault}), commits to accepting the replacement by locking up the necessary DOT collateral to back the to\sphinxhyphen{}be\sphinxhyphen{}transferred BTC (according to the \sphinxcode{\sphinxupquote{SecureCollateralThreshold}}) by calling the {\hyperref[\detokenize{spec/replace:acceptreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{acceptReplace}}}} function..
\begin{itemize}
\item {} 
Note: from the \sphinxstyleemphasis{OldVault}’s perspective a redeem is very similar to an accepted replace. That is, its goal is to get rid of tokens, and it is not important if this is achieved by a user redeeming, or by a vault accepting the replace request. As such, when a user requests a redeem with a vault that has requested a replacement, the \sphinxstyleemphasis{OldVault}’s \sphinxcode{\sphinxupquote{toBeReplacedTokens}} is decreased by the amount of tokens redeemed by the user. The reserved griefing collateral for this replace is then released.

\end{itemize}

\item {} 
Within a pre\sphinxhyphen{}defined delay, \sphinxstyleemphasis{OldVault} must release the BTC on Bitcoin to \sphinxstyleemphasis{NewVault}’s BTC address, and submit a valid transaction inclusion proof by calling the {\hyperref[\detokenize{spec/replace:executereplace}]{\sphinxcrossref{\DUrole{std,std-ref}{executeReplace}}}} function (call to \sphinxcode{\sphinxupquote{verifyTransactionInclusion}} in {\hyperref[\detokenize{spec/btc-relay:btc-relay}]{\sphinxcrossref{\DUrole{std,std-ref}{BTC\sphinxhyphen{}Relay}}}}). If \sphinxstyleemphasis{OldVault} releases the BTC to \sphinxstyleemphasis{NewVault} correctly and submits the transaction inclusion proof to Replace module on time, \sphinxstyleemphasis{OldVault}’s DOT collateral is released \sphinxhyphen{} \sphinxstyleemphasis{NewVault} has now replaced \sphinxstyleemphasis{OldVault}.
\begin{itemize}
\item {} 
Note: as with redeems, to prevent \sphinxstyleemphasis{OldVault} from trying to re\sphinxhyphen{}use old transactions (or other payments to \sphinxstyleemphasis{NewVaults} on Bitcoin) as fake proofs, we require \sphinxstyleemphasis{OldVault} to include a \sphinxcode{\sphinxupquote{nonce}} in an OP\_RETURN output of the transfer transaction on Bitcoin.

\end{itemize}

\item {} 
Optional: If \sphinxstyleemphasis{OldVault} fails to provide the correct transaction inclusion proof on time, the \sphinxstyleemphasis{NewVault}’s \sphinxcode{\sphinxupquote{collateral}} is unlocked and \sphinxstyleemphasis{OldVault}’s \sphinxcode{\sphinxupquote{griefingCollateral}} is sent to the \sphinxstyleemphasis{NewVault} as reimbursement for the opportunity costs of locking up DOT collateral via the {\hyperref[\detokenize{spec/replace:cancelreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelReplace}}}}.

\end{enumerate}


\subsection{Security}
\label{\detokenize{spec/replace:security}}\begin{itemize}
\item {} 
Unique identification of Bitcoin payments: {\hyperref[\detokenize{security_performance/security-analysis:op-return}]{\sphinxcrossref{\DUrole{std,std-ref}{OP\_RETURN}}}}

\end{itemize}


\subsection{Vault Registry}
\label{\detokenize{spec/replace:id1}}
The data access and state changes to the vault registry are documented in \hyperref[\detokenize{spec/replace:fig-vault-registry-replace}]{Fig.\@ \ref{\detokenize{spec/replace:fig-vault-registry-replace}}} below.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{VaultRegistry-Replace}.png}
\caption{The replace module interacts with functions in the vault registry to handle updating token balances of vaults. The green lines indicate an increase, the red lines a decrease.}\label{\detokenize{spec/replace:id18}}\label{\detokenize{spec/replace:fig-vault-registry-replace}}\end{figure}


\subsection{Fee Model}
\label{\detokenize{spec/replace:fee-model}}
Following additions are added if the fee model is integrated.
\begin{itemize}
\item {} 
If a replace request is canceled, the griefing collateral is transferred to the new\_vault.

\item {} 
If a replace request is executed, the griefing collateral is transferred to the old\_vault.

\end{itemize}


\section{Data Model}
\label{\detokenize{spec/replace:data-model}}

\subsection{Scalars}
\label{\detokenize{spec/replace:scalars}}

\subsubsection{ReplaceBtcDustValue}
\label{\detokenize{spec/replace:replacebtcdustvalue}}
The minimum amount a \sphinxstyleemphasis{newVault} can accept \sphinxhyphen{} this is to ensure the \sphinxstyleemphasis{oldVault} is able to make the bitcoin transfer. Furthermore, it puts a limit on the transaction fees that the \sphinxstyleemphasis{oldVault} needs to pay.


\subsubsection{ReplacePeriod}
\label{\detokenize{spec/replace:replaceperiod}}\label{\detokenize{spec/replace:id2}}
The time difference between a replace request is accepted by another vault and the transfer of BTC (and submission of the transaction inclusion proof) by the to\sphinxhyphen{}be\sphinxhyphen{}replaced Vault. Concretely, this period is the amount by which {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}} is allowed to increase before the redeem is considered to be expired. The replace period has an upper limit to prevent griefing of vault collateral. Each accepted replace request records the value of this field upon creation, and when checking the expiry, the maximum of the current ReplacePeriod and the value as recorded in the ReplaceRequest is used. This way, vaults are not negatively impacted by a change in the value.


\subsection{Maps}
\label{\detokenize{spec/replace:maps}}

\subsubsection{ReplaceRequests}
\label{\detokenize{spec/replace:replacerequests}}
Vaults create replace requests if they want to have (a part of) their DOT collateral to be replaced by other Vaults. This mapping provides access from a unique hash \sphinxcode{\sphinxupquote{ReplaceId}} to a \sphinxcode{\sphinxupquote{ReplaceRequest}} struct. \sphinxcode{\sphinxupquote{\textless{}ReplaceId, Replace\textgreater{}}}.


\subsection{Structs}
\label{\detokenize{spec/replace:structs}}

\subsubsection{Replace}
\label{\detokenize{spec/replace:id3}}
Stores the status and information about a single replace request.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|l|l|L|}
\hline
\sphinxstyletheadfamily 
Parameter
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{oldVault}}
&
Account
&
Account of the vault that is to be replaced.
\\
\hline
\sphinxcode{\sphinxupquote{newVault}}
&
Account
&
Account of the new vault, which accepts the replace request.
\\
\hline
\sphinxcode{\sphinxupquote{amount}}
&
interbtc
&
Amount of BTC / interbtc to be replaced.
\\
\hline
\sphinxcode{\sphinxupquote{griefingCollateral}}
&
DOT
&
Griefing protection collateral locked by \sphinxstyleemphasis{oldVault}.
\\
\hline
\sphinxcode{\sphinxupquote{collateral}}
&
DOT
&
DOT collateral locked by the new Vault.
\\
\hline
\sphinxcode{\sphinxupquote{acceptTime}}
&
u32
&
The {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}} when the replace request was accepted by a new Vault. Serves as start for the countdown until when the old vault must transfer the BTC.
\\
\hline
\sphinxcode{\sphinxupquote{btcAddress}}
&
bytes{[}20{]}
&
Base58 encoded Bitcoin public key of the new Vault.
\\
\hline
\sphinxcode{\sphinxupquote{btcHeight}}
&
u32
&
Height of newest bitcoin block in the relay at the time the request is accepted. This is used by the clients upon startup, to determine how many blocks of the bitcoin chain they need to inspect to know if a payment has been made already.
\\
\hline
\sphinxcode{\sphinxupquote{period}}
&
u32
&
Value of {\hyperref[\detokenize{spec/replace:replaceperiod}]{\sphinxcrossref{\DUrole{std,std-ref}{ReplacePeriod}}}} when the redeem request was made, in case that value changes while this replace is pending.
\\
\hline
\sphinxcode{\sphinxupquote{status}}
&
Enum
&
Status of the request: Pending, Completed or Cancelled
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{btcAddress}} parameter is not to be set by the new vault, but is extracted from the \sphinxcode{\sphinxupquote{Vaults}} mapping in \sphinxcode{\sphinxupquote{VaultRegistry}} for the account of the new Vault.
\end{sphinxadmonition}


\section{Functions}
\label{\detokenize{spec/replace:functions}}

\subsection{requestReplace}
\label{\detokenize{spec/replace:requestreplace}}\label{\detokenize{spec/replace:id4}}
An \sphinxstyleemphasis{OldVault} (to\sphinxhyphen{}be\sphinxhyphen{}replaced Vault) submits a request to be (partially) replaced. If it requests more than it can fulfil (i.e. the sum of \sphinxcode{\sphinxupquote{toBeReplacedTokens}} and \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} exceeds its \sphinxcode{\sphinxupquote{issuedTokens}}, then the request amount is reduced such that the sum of \sphinxcode{\sphinxupquote{toBeReplacedTokens}} and \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} is exactly equal to \sphinxcode{\sphinxupquote{issuedTokens}}.


\subsubsection{Specification}
\label{\detokenize{spec/replace:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{requestReplace(oldVault, btcAmount, griefingCollateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault to be replaced (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}).

\item {} 
\sphinxcode{\sphinxupquote{btcAmount}}: Integer amount of BTC / interbtc to be replaced.

\item {} 
\sphinxcode{\sphinxupquote{griefingCollateral}}: collateral locked by the \sphinxstyleemphasis{oldVault} as griefing protection

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RequestReplace(oldVault, btcAmount, replaceId)}}

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxstyleemphasis{oldVault}.

\item {} 
The vault MUST be registered

\item {} 
The vault MUST NOT be banned

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\item {} 
The vault MUST provide sufficient \sphinxcode{\sphinxupquote{griefingCollateral}} such that the ratio of all of its \sphinxcode{\sphinxupquote{toBeReplacedTokens}} and \sphinxcode{\sphinxupquote{replaceCollateral}} is above {\hyperref[\detokenize{spec/fee:replacegriefingcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{ReplaceGriefingCollateral}}}}.

\item {} 
The vault MUST request sufficient tokens to be replaced such that its total is above \sphinxcode{\sphinxupquote{ReplaceBtcDustValue}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeReplaceedTokens}} is increased by \sphinxcode{\sphinxupquote{tokenIncrease = min(btcAmount, vault.toBeIssuedTokens \sphinxhyphen{} vault.toBeRedeemedTokens)}}.

\item {} 
An amount of \sphinxcode{\sphinxupquote{griefingCollateral * (tokenIncrease / btcAmount)}} is locked by this transaction.

\item {} 
The vault’s \sphinxcode{\sphinxupquote{replaceCollateral}} is increased by the amount of collateral locked in this transaction.

\end{itemize}


\subsection{withdrawReplaceRequest}
\label{\detokenize{spec/replace:withdrawreplacerequest}}\label{\detokenize{spec/replace:id5}}
The \sphinxstyleemphasis{OldVault} decreases its \sphinxcode{\sphinxupquote{toBeReplacedTokens}}.


\subsubsection{Specification}
\label{\detokenize{spec/replace:id6}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{withdrawReplaceRequest(oldVault, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault withdrawing it’s replace request (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of \sphinxcode{\sphinxupquote{to\_be\_replaced\_tokens}} to withdraw.

\end{itemize}

\sphinxstyleemphasis{Events}

\sphinxcode{\sphinxupquote{WithdrawReplaceRequest(oldVault, withdrawnTokens, withdrawnGriefingCollateral)}}: emits an event stating that a vault (\sphinxstyleemphasis{oldVault}) has withdrawn some amount of \sphinxcode{\sphinxupquote{toBeReplacedTokens}}.

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxstyleemphasis{oldVault}.

\item {} 
The vault MUST be registered

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
The vault MUST have a non\sphinxhyphen{}zero amount of \sphinxcode{\sphinxupquote{toBeReplaceedTokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeReplacedTokens}} is decrease by an amount of \sphinxcode{\sphinxupquote{tokenDecrease = min(toBeReplacedTokens, tokens)}}

\item {} 
The vault’s \sphinxcode{\sphinxupquote{replaceCollateral}} is decreased by the amount \sphinxcode{\sphinxupquote{releasedCollateral = replaceCollateral * (tokenDecrease / toBeReplacedTokens)}}.

\item {} 
The \sphinxcode{\sphinxupquote{releasedCollateral}} is unlocked.

\end{itemize}


\subsection{acceptReplace}
\label{\detokenize{spec/replace:acceptreplace}}\label{\detokenize{spec/replace:id7}}
A \sphinxstyleemphasis{NewVault} accepts an existing replace request. It can optionally lock additional DOT collateral specifically for this replace. If the replace is cancelled, this amount will be unlocked again.


\subsubsection{Specification}
\label{\detokenize{spec/replace:id8}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{acceptReplace(newVault, oldVault, btcAmount, collateral, btcAddress)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{newVault}}: Account identifier of the vault accepting the replace request (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{replaceId}}: The identifier of the replace request in \sphinxcode{\sphinxupquote{ReplaceRequests}}.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: DOT collateral provided to match the replace request (i.e., for backing the locked BTC). Can be more than the necessary amount.

\end{itemize}

\sphinxstyleemphasis{Events}

\sphinxcode{\sphinxupquote{AcceptReplace(replaceId, oldVault, newVault, btcAmount, collateral, btcAddress)}}: emits an event with data that the \sphinxstyleemphasis{oldVault} needs to execute the replace.

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxstyleemphasis{newVault}.

\item {} 
\sphinxstyleemphasis{oldVault} and \sphinxstyleemphasis{newVault} MUST be registered

\item {} 
\sphinxstyleemphasis{oldVault} MUST NOT be equal to \sphinxstyleemphasis{newVault}

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
\sphinxstyleemphasis{newVault}’s free balance MUST be enough to lock \sphinxcode{\sphinxupquote{collateral}}

\item {} 
\sphinxstyleemphasis{newVault} MUST have lock sufficient collateral to remain above the {\hyperref[\detokenize{spec/vault-registry:securecollateralthreshold}]{\sphinxcrossref{\DUrole{std,std-ref}{SecureCollateralThreshold}}}} after accepting \sphinxcode{\sphinxupquote{btcAmount}}.

\item {} 
The replaced tokens MUST be at least\textasciigrave{}\textasciigrave{}ReplaceBtcDustValue\textasciigrave{}\textasciigrave{}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}

The actual amount of replaced tokens is calculated to be \sphinxcode{\sphinxupquote{consumedTokens = min(oldVault.toBeReplacedTokens, btcAmount)}}. The amount of griefingCollateral used is \sphinxcode{\sphinxupquote{consumedGriefingCollateral = oldVault.replaceCollateral * (consumedTokens / oldVault.toBeReplacedTokens)}}.
\begin{itemize}
\item {} 
The \sphinxstyleemphasis{oldVault}’s \sphinxcode{\sphinxupquote{replaceCollateral}} is decreased by \sphinxcode{\sphinxupquote{consumedGriefingCollateral}}.

\item {} 
The \sphinxstyleemphasis{oldVault}’s \sphinxcode{\sphinxupquote{toBeReplacedTokens}} is decreased by \sphinxcode{\sphinxupquote{consumedTokens}}.

\item {} 
The \sphinxstyleemphasis{oldVault}’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} is increased by \sphinxcode{\sphinxupquote{consumedTokens}}.

\item {} 
The \sphinxstyleemphasis{newVault}’s \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is increased by \sphinxcode{\sphinxupquote{consumedTokens}}.

\item {} 
The \sphinxstyleemphasis{newVault} locks additional collateral; its \sphinxcode{\sphinxupquote{backingCollateral}} is increased by \sphinxcode{\sphinxupquote{collateral * (consumedTokens / oldVault.toBeReplacedTokens)}}.

\item {} 
A new \sphinxcode{\sphinxupquote{ReplaceRequest}} is added to storage. The amount is set to \sphinxcode{\sphinxupquote{consumedTokens}}, \sphinxcode{\sphinxupquote{griefingCollateral}} to \sphinxcode{\sphinxupquote{consumedGriefingCollateral}}, \sphinxcode{\sphinxupquote{collateral}} to the \sphinxcode{\sphinxupquote{collateral}} argument, \sphinxcode{\sphinxupquote{accept\_time}} to the current active block number, \sphinxcode{\sphinxupquote{period}} to the current \sphinxcode{\sphinxupquote{ReplacePeriod}}, \sphinxcode{\sphinxupquote{btcAddress}} to the \sphinxcode{\sphinxupquote{btcAddress}} argument, \sphinxcode{\sphinxupquote{btc\_height}} to the current height of the btc\sphinxhyphen{}relay, and \sphinxcode{\sphinxupquote{status}} to \sphinxcode{\sphinxupquote{pending}}.

\end{itemize}


\subsection{executeReplace}
\label{\detokenize{spec/replace:executereplace}}\label{\detokenize{spec/replace:id9}}
The to\sphinxhyphen{}be\sphinxhyphen{}replaced vault finalizes the replace process by submitting a proof that it transferred the correct amount of BTC to the BTC address of the new vault, as specified in the \sphinxcode{\sphinxupquote{ReplaceRequest}}. This function calls \sphinxstyleemphasis{verifyAndValidateTransaction} in {\hyperref[\detokenize{spec/btc-relay:btc-relay}]{\sphinxcrossref{\DUrole{std,std-ref}{BTC\sphinxhyphen{}Relay}}}}.


\subsubsection{Specification}
\label{\detokenize{spec/replace:id10}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{executeReplace(oldVault, replaceId, merkleProof, rawTx)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault making this call.

\item {} 
\sphinxcode{\sphinxupquote{replaceId}}: The identifier of the replace request in \sphinxcode{\sphinxupquote{ReplaceRequests}}.

\item {} 
\sphinxcode{\sphinxupquote{merkleProof}}: Merkle tree path (concatenated LE SHA256 hashes).

\item {} 
\sphinxcode{\sphinxupquote{rawTx}}: Raw Bitcoin transaction including the transaction inputs and outputs.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ExecuteReplace(oldVault, newVault, replaceId)}}: emits an event stating that the old vault (\sphinxstyleemphasis{oldVault}) has executed the BTC transfer to the new vault (\sphinxstyleemphasis{newVault}), finalizing the \sphinxcode{\sphinxupquote{ReplaceRequest}} request (\sphinxcode{\sphinxupquote{requestId}}).

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN:2}}.

\item {} 
\sphinxstyleemphasis{oldVault} MUST be registered as a vault

\item {} 
A pending \sphinxcode{\sphinxupquote{ReplaceRequest}} MUST exist with an id equal to \sphinxcode{\sphinxupquote{replaceId}}.

\item {} 
The request MUST NOT have expired.

\item {} 
The \sphinxcode{\sphinxupquote{rawTx}} MUST decode to a valid transaction that transfers at least the amount specified in the \sphinxcode{\sphinxupquote{ReplaceRequest}} struct. It MUST be a transaction to the correct address, and provide the expected OP\_RETURN, based on the \sphinxcode{\sphinxupquote{ReplaceRequest}}.

\item {} 
The \sphinxcode{\sphinxupquote{merkleProof}} MUST contain a valid proof of of \sphinxcode{\sphinxupquote{rawTX}}.

\item {} 
The bitcoin payment MUST have been submitted to the relay chain, and MUST have sufficient confirmations.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:replacetokens}]{\sphinxcrossref{\DUrole{std,std-ref}{replaceTokens}}}} has been called, providing the \sphinxcode{\sphinxupquote{oldVault}}, \sphinxcode{\sphinxupquote{newVault}}, \sphinxcode{\sphinxupquote{replaceRequest.amount}}, and \sphinxcode{\sphinxupquote{replaceRequest.collateral}} as arguments.

\item {} 
The griefing collateral as specifified in the \sphinxcode{\sphinxupquote{ReplaceRequest}} is unlocked to \sphinxstyleemphasis{oldVault}.

\item {} 
\sphinxcode{\sphinxupquote{replaceRequest.status}} is set to \sphinxcode{\sphinxupquote{Completed}}.

\end{itemize}


\subsection{cancelReplace}
\label{\detokenize{spec/replace:cancelreplace}}\label{\detokenize{spec/replace:id11}}
If a replace request is not executed on time, the replace can be cancelled by the new vault. Since the new vault provided additional collateral in vain, it can claim the old vault’s griefing collateral.


\subsubsection{Specification}
\label{\detokenize{spec/replace:id12}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{cancelReplace(newVault, replaceId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{newVault}}: Account identifier of the vault accepting the replace request (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{replaceId}}: The identifier of the replace request in \sphinxcode{\sphinxupquote{ReplaceRequests}}.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CancelReplace(replaceId, newVault, oldVault, slashedCollateral)}}: emits an event stating that the old vault (\sphinxstyleemphasis{oldVault}) has not completed the replace request, that the new vault (\sphinxstyleemphasis{newVault}) cancelled the \sphinxcode{\sphinxupquote{ReplaceRequest}} request (\sphinxcode{\sphinxupquote{requestId}}), and that \sphinxcode{\sphinxupquote{slashedCollateral}} has been slashed from \sphinxstyleemphasis{oldVault} to \sphinxstyleemphasis{newVault}.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN:2}}.

\item {} 
\sphinxstyleemphasis{oldVault} MUST be registered as a vault

\item {} 
A pending \sphinxcode{\sphinxupquote{ReplaceRequest}} MUST exist with an id equal to \sphinxcode{\sphinxupquote{replaceId}}.

\item {} 
\sphinxcode{\sphinxupquote{newVault}} MUST be equal to the \sphinxstyleemphasis{newVault} specified in the \sphinxcode{\sphinxupquote{ReplaceRequest}}. That is, this function can only be can only be called by the \sphinxstyleemphasis{newVault}.

\item {} 
The request MUST have expired.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:cancelreplacetokens}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelReplaceTokens}}}} has been called, providing the \sphinxcode{\sphinxupquote{oldVault}}, \sphinxcode{\sphinxupquote{newVault}}, \sphinxcode{\sphinxupquote{replaceRequest.amount}}, and \sphinxcode{\sphinxupquote{replaceRequest.amount}}.

\item {} \begin{description}
\item[{If \sphinxstyleemphasis{newVault} is \sphinxstyleemphasis{not} liquidated:}] \leavevmode\begin{itemize}
\item {} 
the griefing collateral is slashed from the \sphinxstyleemphasis{oldVault} to the new vault’s \sphinxcode{\sphinxupquote{backingCollateral}}.

\item {} 
If unlocking \sphinxcode{\sphinxupquote{replaceRequest.collateral}} does not put the collaterlization rate of the \sphinxstyleemphasis{newVault} below \sphinxcode{\sphinxupquote{SecureCollateralThreshold}}, the collateral is unlocked and its \sphinxcode{\sphinxupquote{backingCollateral}} decreases by the same amount.

\end{itemize}

\end{description}

\item {} 
If \sphinxstyleemphasis{newVault} \sphinxstyleemphasis{is} liquidated, the griefing collateral is slashed from the \sphinxstyleemphasis{oldVault} to the new vault’s free balance.

\item {} 
\sphinxcode{\sphinxupquote{replaceRequest.status}} is set to \sphinxcode{\sphinxupquote{Cancelled}}.

\end{itemize}


\section{Events}
\label{\detokenize{spec/replace:events}}

\subsection{RequestReplace}
\label{\detokenize{spec/replace:id13}}
Emit an event when a replace request is made by an \sphinxstyleemphasis{oldVault}.

\sphinxstyleemphasis{Event Signature}
* \sphinxcode{\sphinxupquote{RequestReplace(oldVault, btcAmount, replaceId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault to be replaced (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}).

\item {} 
\sphinxcode{\sphinxupquote{btcAmount}}: Integer amount of BTC / interbtc to be replaced.

\item {} 
\sphinxcode{\sphinxupquote{replaceId}}: The unique identified of a replace request.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/replace:requestreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{requestReplace}}}}

\end{itemize}


\subsection{WithdrawReplaceRequest}
\label{\detokenize{spec/replace:id14}}
Emits an event stating that a vault (\sphinxstyleemphasis{oldVault}) has withdrawn some amount of \sphinxcode{\sphinxupquote{toBeReplacedTokens}}.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{WithdrawReplaceRequest(oldVault, withdrawnTokens, withdrawnGriefingCollateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault requesting the replace (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{withdrawnTokens}}: The amount by which \sphinxcode{\sphinxupquote{toBeReplacedTokens}} has decreased.

\item {} 
\sphinxcode{\sphinxupquote{withdrawnGriefingCollateral}}: The amount of griefing collateral unlocked.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{withdrawReplaceRequest}

\end{itemize}


\subsection{AcceptReplace}
\label{\detokenize{spec/replace:id15}}
Emits an event stating which vault (\sphinxstyleemphasis{newVault}) has accepted the \sphinxcode{\sphinxupquote{ReplaceRequest}} request (\sphinxcode{\sphinxupquote{requestId}}), and how much collateral in DOT it provided (\sphinxcode{\sphinxupquote{collateral}}).

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{AcceptReplace(replaceId, oldVault, newVault, btcAmount, collateral, btcAddress)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{replaceId}}: The identifier of the replace request in \sphinxcode{\sphinxupquote{ReplaceRequests}}.

\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault being replaced (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{newVault}}: Account identifier of the vault that accepted the replace request (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{btcAmount}}: Amount of tokens the \sphinxstyleemphasis{newVault} just accepted.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: Amount of collateral the \sphinxstyleemphasis{newVault} locked for this replace.

\item {} 
\sphinxcode{\sphinxupquote{btcAddress}}: The address that \sphinxstyleemphasis{oldVault} should transfer the btc to.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{acceptReplace}

\end{itemize}


\subsection{ExecuteReplace}
\label{\detokenize{spec/replace:id16}}
Emits an event stating that the old vault (\sphinxstyleemphasis{oldVault}) has executed the BTC transfer to the new vault (\sphinxstyleemphasis{newVault}), finalizing the \sphinxcode{\sphinxupquote{ReplaceRequest}} request (\sphinxcode{\sphinxupquote{requestId}}).

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{ExecuteReplace(oldVault, newVault, replaceId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault being replaced (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{newVault}}: Account identifier of the vault that accepted the replace request (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{replaceId}}: The identifier of the replace request in \sphinxcode{\sphinxupquote{ReplaceRequests}}.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{executeReplace}

\end{itemize}


\subsection{CancelReplace}
\label{\detokenize{spec/replace:id17}}
Emits an event stating that the old vault (\sphinxstyleemphasis{oldVault}) has not completed the replace request, that the new vault (\sphinxstyleemphasis{newVault}) cancelled the \sphinxcode{\sphinxupquote{ReplaceRequest}} request (\sphinxcode{\sphinxupquote{requestId}}), and that \sphinxcode{\sphinxupquote{slashedCollateral}} has been slashed from \sphinxstyleemphasis{oldVault} to \sphinxstyleemphasis{newVault}.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{CancelReplace(replaceId, newVault, oldVault, slashedCollateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{replaceId}}: The identifier of the replace request in \sphinxcode{\sphinxupquote{ReplaceRequests}}.

\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault being replaced (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{newVault}}: Account identifier of the vault that accepted the replace request (as tracked in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}})

\item {} 
\sphinxcode{\sphinxupquote{slashedCollateral}}: Amount of griefingCollateral slashed to \sphinxstyleemphasis{newVault}.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
ref:\sphinxtitleref{cancelReplace}

\end{itemize}


\section{Error Codes}
\label{\detokenize{spec/replace:error-codes}}
\sphinxcode{\sphinxupquote{ERR\_UNAUTHORIZED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Unauthorized: Caller must be \sphinxstyleemphasis{newVault}.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:cancelreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelReplace}}}}

\item {} 
\sphinxstylestrong{Cause}: The caller of this function is not the associated \sphinxstyleemphasis{newVault}, and hence not authorized to take this action.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_COLLATERAL}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The provided collateral is too low.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:requestreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{requestReplace}}}}

\item {} 
\sphinxstylestrong{Cause}: The provided collateral is insufficient to match the amount of tokens requested for replacement.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REPLACE\_PERIOD\_EXPIRED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The replace period expired.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:executereplace}]{\sphinxcrossref{\DUrole{std,std-ref}{executeReplace}}}}

\item {} 
\sphinxstylestrong{Cause}: The time limit as defined by the \sphinxcode{\sphinxupquote{ReplacePeriod}} is not met.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REPLACE\_PERIOD\_NOT\_EXPIRED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The period to complete the replace request is not yet expired.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:cancelreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelReplace}}}}

\item {} 
\sphinxstylestrong{Cause}:  A vault tried to cancel a replace before it expired.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_AMOUNT\_BELOW\_BTC\_DUST\_VALUE}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “To be replaced amount is too small.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:requestreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{requestReplace}}}}, {\hyperref[\detokenize{spec/replace:acceptreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{acceptReplace}}}}

\item {} 
\sphinxstylestrong{Cause}:  The vault requests or accepts an insufficient number of tokens.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_NO\_PENDING\_REQUEST}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Could not withdraw to\sphinxhyphen{}be\sphinxhyphen{}replaced tokens because it was already zero.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:requestreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{requestReplace}}}} | {\hyperref[\detokenize{spec/replace:acceptreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{acceptReplace}}}}

\item {} 
\sphinxstylestrong{Cause}:  The vault requests or accepts an insufficient number of tokens.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REPLACE\_SELF\_NOT\_ALLOWED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Vaults can not accept replace request created by themselves.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:acceptreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{acceptReplace}}}}

\item {} 
\sphinxstylestrong{Cause}:  A vault tried to accept a replace that it itself had created.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REPLACE\_COMPLETED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Request is already completed.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:executereplace}]{\sphinxcrossref{\DUrole{std,std-ref}{executeReplace}}}} | {\hyperref[\detokenize{spec/replace:cancelreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelReplace}}}}

\item {} 
\sphinxstylestrong{Cause}:  A vault tried to operate on a request that already completed.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REPLACE\_CANCELLED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Request is already cancelled.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:executereplace}]{\sphinxcrossref{\DUrole{std,std-ref}{executeReplace}}}} | {\hyperref[\detokenize{spec/replace:cancelreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelReplace}}}}

\item {} 
\sphinxstylestrong{Cause}:  A vault tried to operate on a request that already cancelled.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_REPLACE\_ID\_NOT\_FOUND}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Invalid replace ID”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:executereplace}]{\sphinxcrossref{\DUrole{std,std-ref}{executeReplace}}}} | {\hyperref[\detokenize{spec/replace:cancelreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelReplace}}}}

\item {} 
\sphinxstylestrong{Cause}:  An invalid replaceID was given \sphinxhyphen{} it is not found in the \sphinxcode{\sphinxupquote{ReplaceRequests}} map.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_FOUND}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The \sphinxcode{\sphinxupquote{vault}} cannot be found.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/replace:requestreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{requestReplace}}}} | {\hyperref[\detokenize{spec/replace:acceptreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{acceptReplace}}}} | {\hyperref[\detokenize{spec/replace:cancelreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelReplace}}}}

\item {} 
\sphinxstylestrong{Cause}: The vault was not found in the existing \sphinxcode{\sphinxupquote{Vaults}} list in \sphinxcode{\sphinxupquote{VaultRegistry}}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
It is possible that functions in this pallet return errors defined in other pallets.
\end{sphinxadmonition}


\chapter{Security}
\label{\detokenize{spec/security:security}}\label{\detokenize{spec/security:id1}}\label{\detokenize{spec/security::doc}}
The Security module is responsible for (1) tracking the status of the BTC Parachain, (2) the “active” blocks of the BTC Parachain, and (3) generating secure identifiers.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstylestrong{BTC Parachain Status}: The BTC Parachain has three distinct states: \sphinxcode{\sphinxupquote{Running}}, \sphinxcode{\sphinxupquote{Error}}, and \sphinxcode{\sphinxupquote{Shutdown}} which determine which functions can be used.

\item {} 
\sphinxstylestrong{Active Blocks}: When the BTC Parachain is not in the \sphinxcode{\sphinxupquote{Running}} state, certain operations are restricted. In order to prevent impact on the users and vaults for the core issue, redeem, and replace operations, the BTC Parachain only considers Active Blocks for the Issue, Redeem, and Replace Periods.

\item {} 
\sphinxstylestrong{Secure Identifiers}: As part of the {\hyperref[\detokenize{security_performance/security-analysis:op-return}]{\sphinxcrossref{\DUrole{std,std-ref}{OP\_RETURN}}}} scheme to prevent replay attacks, the security module generates unique identifiers that are used to identify transactions.

\end{enumerate}


\section{Overview}
\label{\detokenize{spec/security:overview}}

\subsection{Failure Modes}
\label{\detokenize{spec/security:failure-modes}}
The BTC Parachain can enter into an ERROR and SHUTDOWN state, depending on the occurred error.
An overview is provided in the figure below.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{failureModes}.png}
\caption{(Informal) State machine showing the operational and failure modes and how to recover from or flag failures.}\label{\detokenize{spec/security:id13}}\end{figure}

Failure handling methods calls are \sphinxstylestrong{restricted}, i.e., can only be called by pre\sphinxhyphen{}determined roles.


\subsection{Oracle Offline}
\label{\detokenize{spec/security:oracle-offline}}\label{\detokenize{spec/security:oracle-offline-err}}
The {\hyperref[\detokenize{spec/oracle:oracle}]{\sphinxcrossref{\DUrole{std,std-ref}{Exchange Rate Oracle}}}} experienced a liveness failure (no up\sphinxhyphen{}to\sphinxhyphen{}date exchange rate available).
The frequency of the oracle updates is defined in the Oracle module.

\sphinxstylestrong{Error code:} \sphinxcode{\sphinxupquote{ORACLE\_OFFLINE}}


\subsection{BTC\sphinxhyphen{}Relay Offline}
\label{\detokenize{spec/security:btc-relay-offline}}
The {\hyperref[\detokenize{spec/btc-relay:btc-relay}]{\sphinxcrossref{\DUrole{std,std-ref}{BTC\sphinxhyphen{}Relay}}}} has less blocks stored than defined as the \sphinxcode{\sphinxupquote{STABLE\_BITCOIN\_CONFIRMATIONS}}.

This is the initial state of the BTC\sphinxhyphen{}Parachain. After more than the \sphinxcode{\sphinxupquote{STABLE\_BITCOIN\_CONFIRMATIONS}} BTC blocks have been stored in BTC\sphinxhyphen{}Relay, the BTC Parachain cannot decide if or not it is behind in terms of Bitcoin blocks since we make no assumption about the frequency of BTC blocks being produced.

\sphinxstylestrong{Error code:} \sphinxcode{\sphinxupquote{BTC\_RELAY\_OFFLINE}}


\section{Data Model}
\label{\detokenize{spec/security:data-model}}

\subsection{Enums}
\label{\detokenize{spec/security:enums}}

\subsubsection{StatusCode}
\label{\detokenize{spec/security:statuscode}}
Indicates ths status of the BTC Parachain.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RUNNING: 0}} \sphinxhyphen{} BTC Parachain fully operational

\item {} 
\sphinxcode{\sphinxupquote{ERROR: 1}}\sphinxhyphen{} an error was detected in the BTC Parachain. See \sphinxcode{\sphinxupquote{Errors}} for more details, i.e., the specific error codes (these determine how to react).

\item {} 
\sphinxcode{\sphinxupquote{SHUTDOWN: 2}} \sphinxhyphen{} BTC Parachain operation fully suspended. This can only be achieved via manual intervention by the Governance Mechanism.

\end{itemize}


\subsubsection{ErrorCode}
\label{\detokenize{spec/security:errorcode}}
Enum specifying error codes tracked in \sphinxcode{\sphinxupquote{Errors}}.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{NONE: 0}}

\item {} 
\sphinxcode{\sphinxupquote{ORACLE\_OFFLINE: 1}}

\item {} 
\sphinxcode{\sphinxupquote{BTC\_RELAY\_OFFLINE: 2}}

\end{itemize}


\section{Data Storage}
\label{\detokenize{spec/security:data-storage}}

\subsection{Scalars}
\label{\detokenize{spec/security:scalars}}

\subsubsection{ParachainStatus}
\label{\detokenize{spec/security:parachainstatus}}
Integer/Enum (see \sphinxcode{\sphinxupquote{StatusCode}} below). Defines the current state of the BTC Parachain.


\subsubsection{Errors}
\label{\detokenize{spec/security:errors}}
Set of error codes (\sphinxcode{\sphinxupquote{ErrorCode}} enums), indicating the reason for the error. The \sphinxcode{\sphinxupquote{ErrorCode}} entries included in this set specify how to react to the failure.


\subsubsection{Nonce}
\label{\detokenize{spec/security:nonce}}
Integer increment\sphinxhyphen{}only counter, used to prevent collisions when generating identifiers for e.g., redeem or replace requests (for OP\_RETURN field in Bitcoin).


\subsubsection{ActiveBlockCount}
\label{\detokenize{spec/security:activeblockcount}}\label{\detokenize{spec/security:id2}}
A counter variable that increments every block where the parachain status is \sphinxcode{\sphinxupquote{RUNNING:0}}. This variable is used to keep track of durations, such as issue/redeem/replace expiry. This is used instead of the block number because if the parachain status is not \sphinxcode{\sphinxupquote{RUNNING:0}}, no payment proofs can be submitted, so it would not be fair towards users and vaults to continue counting down the (expiry) periods.


\section{Functions}
\label{\detokenize{spec/security:functions}}

\subsection{generateSecureId}
\label{\detokenize{spec/security:generatesecureid}}\label{\detokenize{spec/security:id3}}
Generates a unique ID using an account identifier, the \sphinxcode{\sphinxupquote{Nonce}} and a random seed.


\subsubsection{Specification}
\label{\detokenize{spec/security:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{generateSecureId(account)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{account}}: Parachain account identifier (links this identifier to the AccountId associated with the process where this secure id is to be used, e.g., the user calling {\hyperref[\detokenize{spec/issue:requestissue}]{\sphinxcrossref{\DUrole{std,std-ref}{requestIssue}}}}).

\end{itemize}

\sphinxstyleemphasis{Returns}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{hash}}: a cryptographic hash generated via a secure hash function.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/security:function-sequence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Increment the \sphinxcode{\sphinxupquote{Nonce}}.

\item {} 
Concatenate \sphinxcode{\sphinxupquote{account}}, \sphinxcode{\sphinxupquote{Nonce}}, and \sphinxcode{\sphinxupquote{parent\_hash()}}.

\item {} 
SHA256 hash the result of step 1.

\item {} 
Return the resulting hash.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
The funtion \sphinxcode{\sphinxupquote{parent\_hash()}} is assumed to return the hash of the parachain’s parent block \sphinxhyphen{} which precedes the block this function is called in.
\end{sphinxadmonition}


\subsection{hasExpired}
\label{\detokenize{spec/security:hasexpired}}\label{\detokenize{spec/security:id4}}
Checks if the given period has expired since the given starting point. This calculation is based on the {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}}.


\subsubsection{Specification}
\label{\detokenize{spec/security:id5}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{has\_expired(opentime, period)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{opentime}}: the {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}} at the time the issue/redeem/replace was opened.

\item {} 
\sphinxcode{\sphinxupquote{period}}: the number of blocks the user or vault has to complete the action.

\end{itemize}

\sphinxstyleemphasis{Returns}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{true}} if the period has expired

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/security:id6}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Add the \sphinxcode{\sphinxupquote{opentime}} and \sphinxcode{\sphinxupquote{period}}.

\item {} 
Compare this against {\hyperref[\detokenize{spec/security:activeblockcount}]{\sphinxcrossref{\DUrole{std,std-ref}{ActiveBlockCount}}}}.

\end{enumerate}


\subsection{setParachainStatus}
\label{\detokenize{spec/security:setparachainstatus}}\label{\detokenize{spec/security:id7}}
Governance sets a status code for the BTC Parachain manually.


\subsubsection{Specification}
\label{\detokenize{spec/security:id8}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{setParachainStatus(StatusCode)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{StatusCode}}: the new StatusCode of the BTC\sphinxhyphen{}Parachain.

\end{itemize}


\subsection{insertParachainError}
\label{\detokenize{spec/security:insertparachainerror}}\label{\detokenize{spec/security:id9}}
Governance inserts an error for the BTC Parachain manually.


\subsubsection{Specification}
\label{\detokenize{spec/security:id10}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{insertParachainError(ErrorCode)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ErrorCode}}: the ErrorCode to be added to the set of errors of the BTC\sphinxhyphen{}Parachain.

\end{itemize}


\subsection{removeParachainError}
\label{\detokenize{spec/security:removeparachainerror}}\label{\detokenize{spec/security:id11}}
Governance removes an error for the BTC Parachain manually.


\subsubsection{Specification}
\label{\detokenize{spec/security:id12}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{removeParachainError(ErrorCode)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ErrorCode}}: the ErrorCode to be removed from the set of errors of the BTC\sphinxhyphen{}Parachain.

\end{itemize}


\section{Events}
\label{\detokenize{spec/security:events}}

\subsection{RecoverFromErrors}
\label{\detokenize{spec/security:recoverfromerrors}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RecoverFromErrors(StatusCode, ErrorCode{[}{]})}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{StatusCode}}: the new StatusCode of the BTC Parachain

\item {} 
\sphinxcode{\sphinxupquote{ErrorCode{[}{]}}}: the list of current errors

\end{itemize}


\chapter{SLA}
\label{\detokenize{spec/sla:sla}}\label{\detokenize{spec/sla:id1}}\label{\detokenize{spec/sla::doc}}

\section{Overview}
\label{\detokenize{spec/sla:overview}}
The SLA module implements the scheme outline in the {\hyperref[\detokenize{economics/SLA:service-level-agreements}]{\sphinxcrossref{\DUrole{std,std-ref}{Service Level Agreements}}}}. Its main purpose is to compute the delta used to increase or decrease the reward stake.

We define an SLA score to be a real number between 0 and 100: \(\text{SLA} = [0, 100)\). The delta is a rational number.

SLAs are used to compute the rewards earned by a participant through the performance of predefined “desired actions”.

Additionally, Vaults with high SLAs avoid having their entire collateral slashed in case they fail to correctly execute a Redeem request (i.e., only the minimum amount of collateral is slashed, defined by the LiquidationThreshold).


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}step}
\label{\detokenize{spec/sla:step-by-step}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Vault and Staked Relayers interact with the BTC\sphinxhyphen{}Parachain.

\item {} 
Certain actions have an impact on their SLA. If this is the case, the function updates the SLA score of the Vault or Staked Relayer accordingly.

\item {} 
The SLA is stored for each Vault and Staked Relayer to impact collateral slashing for Vaults and for fee allocation.

\end{enumerate}


\section{Data Model}
\label{\detokenize{spec/sla:data-model}}

\subsection{Scalars (Vaults)}
\label{\detokenize{spec/sla:scalars-vaults}}

\subsubsection{VaultSLATarget}
\label{\detokenize{spec/sla:vaultslatarget}}
Target value for Vault SLAs.
\begin{itemize}
\item {} 
Initial value: 100

\end{itemize}


\subsubsection{FailedRedeem (Decrease)}
\label{\detokenize{spec/sla:failedredeem-decrease}}\begin{itemize}
\item {} 
Initial value: \sphinxhyphen{}100

\end{itemize}


\subsubsection{ExecutedIssue (Increase)}
\label{\detokenize{spec/sla:executedissue-increase}}
Based on volume of the issue request as compared to the average issue request size (avgIssueSizeN) of the last N issue requests.
SLAIncrease = max(requestSize / avgIssueSizeN * maxSLA, maxSLA)
\begin{itemize}
\item {} 
Initial value: maxSLA = 4

\end{itemize}


\subsubsection{SubmitIssueProof (Increase)}
\label{\detokenize{spec/sla:submitissueproof-increase}}\begin{quote}

Vault submits correct Issue proof on behalf of the user.
\end{quote}
\begin{itemize}
\item {} 
Initial value: 1

\end{itemize}


\subsection{Scalars (Staked Relayers)}
\label{\detokenize{spec/sla:scalars-staked-relayers}}

\subsubsection{Staked Relayer SLA Target}
\label{\detokenize{spec/sla:staked-relayer-sla-target}}
Target value for Staked Relayer SLAs
\begin{itemize}
\item {} 
Initial value: 100

\end{itemize}


\subsubsection{Block Submission (Increase)}
\label{\detokenize{spec/sla:block-submission-increase}}\begin{itemize}
\item {} 
Initial value: +1

\end{itemize}


\subsubsection{Correct Theft Report (Increase)}
\label{\detokenize{spec/sla:correct-theft-report-increase}}\begin{itemize}
\item {} 
Initial value: +1

\end{itemize}


\subsection{Maps}
\label{\detokenize{spec/sla:maps}}

\subsubsection{VaultSLA}
\label{\detokenize{spec/sla:vaultsla}}
Mapping from Vault accounts to their SLA score.


\subsubsection{StakedRelayerSLA}
\label{\detokenize{spec/sla:stakedrelayersla}}
Mapping from Staked Relayer accounts to their SLA score.


\section{Functions}
\label{\detokenize{spec/sla:functions}}

\subsection{SlashAmountVault}
\label{\detokenize{spec/sla:slashamountvault}}\label{\detokenize{spec/sla:id2}}
We reduce the amount of slashed collateral based on a Vaults SLA. The minimum amount slashed is given by the \sphinxcode{\sphinxupquote{LiquidationThreshold}}, the maximum amount slashed by the \sphinxcode{\sphinxupquote{PremiumRedeemThreshold}}. The actual slashed amount of collateral is a linear function parameter zed by the two thresholds:

\(\text{MinSlashed} = \text{LiquidationThreshold} - 100\%\) (currently 10\%)
\(\text{MaxSlashed} = \text{PremiumRedeemThreshold} - 100\%\) (currently 30\%)
\begin{description}
\item[{\(\text{RealSlashed} = (\text{MaxSlashed} - \text{MinSlashed}) / \text{SLATarget} * \text{SLA}\)}] \leavevmode
\(+ (\text{LiquidationThreshold} - 100\%)\)

\end{description}


\subsubsection{Specification}
\label{\detokenize{spec/sla:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{SlashVault(account)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{account}}: The account ID of the vault.

\end{itemize}

\sphinxstyleemphasis{Returns}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{rate}}: The rate (in \%) to\sphinxhyphen{}be\sphinxhyphen{}slashed.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/sla:function-sequence}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Based on the Vault’s SLA, calculate the to\sphinxhyphen{}be\sphinxhyphen{}slashed percentage based on the formula above.

\end{enumerate}


\subsection{updateSLA}
\label{\detokenize{spec/sla:updatesla}}\label{\detokenize{spec/sla:id3}}
Updates the SLA of a Vault or Relayer.


\subsubsection{Specification}
\label{\detokenize{spec/sla:id4}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{updateSLA(account, delta)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{account}}: the account that will be updated

\item {} 
\sphinxcode{\sphinxupquote{delta}}: the increase or decrease in the sla score.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{UpdateSLA}}

\end{itemize}


\section{Events}
\label{\detokenize{spec/sla:events}}

\subsection{UpdateSLA}
\label{\detokenize{spec/sla:id5}}
\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{UpdateSLA(account, total\_score, delta)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{account}}: the account that will be updated

\item {} 
\sphinxcode{\sphinxupquote{total\_score}}: the SLA score of the account after the update

\item {} 
\sphinxcode{\sphinxupquote{delta}}: the increase or decrease in the sla score.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/sla:updatesla}]{\sphinxcrossref{\DUrole{std,std-ref}{updateSLA}}}}

\end{itemize}


\chapter{Staked Relayers}
\label{\detokenize{spec/staked-relayers:staked-relayers}}\label{\detokenize{spec/staked-relayers:id1}}\label{\detokenize{spec/staked-relayers::doc}}
The {\hyperref[\detokenize{spec/staked-relayers:staked-relayers}]{\sphinxcrossref{\DUrole{std,std-ref}{Staked Relayers}}}} module is responsible for handling the registration and staking of Staked Relayers.
It also wraps functions for Staked Relayers to submit Bitcoin block headers to the {\hyperref[\detokenize{spec/btc-relay:btc-relay}]{\sphinxcrossref{\DUrole{std,std-ref}{BTC\sphinxhyphen{}Relay}}}}.


\section{Overview}
\label{\detokenize{spec/staked-relayers:overview}}
\sphinxstylestrong{Staked Relayers} are participants whose main role it is to run Bitcoin full nodes and:
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Submit valid Bitcoin block headers to increase their {\hyperref[\detokenize{spec/sla:sla}]{\sphinxcrossref{\DUrole{std,std-ref}{SLA}}}} score.

\item {} 
Check vaults do not move BTC, unless expressly requested during {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}} or {\hyperref[\detokenize{spec/refund:refund-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Refund}}}}.

\end{enumerate}

In the second case, a single staked relayer report suffices \sphinxhyphen{} the module should check the accusation (using a Merkle proof), and liquidate the vault if valid.
\end{quote}

Staked Relayers are overseen by the Parachain \sphinxstylestrong{Governance Mechanism}.
The Governance Mechanism also votes on critical changes to the architecture or unexpected failures, e.g. hard forks or detected 51\% attacks (if a fork exceeds the specified security parameter \sphinxstyleemphasis{k}, see \sphinxhref{https://interlay.gitlab.io/interbtc-spec/btcrelay-spec/security\_performance/security.html\#security-parameter-k}{Security Parameter k}.).


\section{Data Model}
\label{\detokenize{spec/staked-relayers:data-model}}

\subsection{Structs}
\label{\detokenize{spec/staked-relayers:structs}}

\subsubsection{StakedRelayer}
\label{\detokenize{spec/staked-relayers:stakedrelayer}}
Stores the information of a Staked Relayer.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|l|l|L|}
\hline
\sphinxstyletheadfamily 
Parameter
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{stake}}
&
Backing
&
Total amount of collateral/stake provided by this Staked Relayer.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Data Storage}
\label{\detokenize{spec/staked-relayers:data-storage}}

\subsection{Constants}
\label{\detokenize{spec/staked-relayers:constants}}

\subsubsection{STAKED\_RELAYER\_STAKE}
\label{\detokenize{spec/staked-relayers:staked-relayer-stake}}
Integer denoting the minimum stake which Staked Relayers must provide when registering.


\subsection{Maps}
\label{\detokenize{spec/staked-relayers:maps}}

\subsubsection{StakedRelayers}
\label{\detokenize{spec/staked-relayers:stakedrelayers}}
Mapping from accounts of StakedRelayers to their struct. \sphinxcode{\sphinxupquote{\textless{}Account, StakedRelayer\textgreater{}}}.


\subsubsection{TheftReports}
\label{\detokenize{spec/staked-relayers:theftreports}}
Mapping of Bitcoin transaction identifiers (SHA256 hashes) to account identifiers of Vaults who have been caught stealing Bitcoin.
Per Bitcoin transaction, multiple Vaults can be accused (multiple inputs can come from multiple Vaults).
This mapping is necessary to prevent duplicate theft reports.


\section{Functions}
\label{\detokenize{spec/staked-relayers:functions}}

\subsection{registerStakedRelayer}
\label{\detokenize{spec/staked-relayers:registerstakedrelayer}}\label{\detokenize{spec/staked-relayers:id2}}
Registers a new Staked Relayer, locking the provided collateral, which must exceed \sphinxcode{\sphinxupquote{STAKED\_RELAYER\_STAKE}}.


\subsubsection{Specification}
\label{\detokenize{spec/staked-relayers:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{registerStakedRelayer(stakedRelayer, stake)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{stakedRelayer}}: The account of the staked relayer to be registered.

\item {} 
\sphinxcode{\sphinxupquote{stake}}: to\sphinxhyphen{}be\sphinxhyphen{}locked collateral/stake.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RegisterStakedRelayer(StakedRelayer, collateral)}}: emit an event stating that a new staked relayer (\sphinxcode{\sphinxupquote{stakedRelayer}}) was registered and provide information on the Staked Relayer’s stake (\sphinxcode{\sphinxupquote{stake}}).

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_ALREADY\_REGISTERED = "This AccountId is already registered as a Staked Relayer"}}: The given account identifier is already registered.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_STAKE = "Insufficient stake provided"}}: The provided stake was insufficient \sphinxhyphen{} it must be above \sphinxcode{\sphinxupquote{STAKED\_RELAYER\_STAKE}}.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/staked-relayers:preconditions}}

\subsubsection{Function Sequence}
\label{\detokenize{spec/staked-relayers:function-sequence}}
The \sphinxcode{\sphinxupquote{registerStakedRelayer}} function takes as input an AccountID and collateral amount (to be used as stake) to register a new staked relayer in the system.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
Check that the \sphinxcode{\sphinxupquote{stakedRelayer}} is not already in \sphinxcode{\sphinxupquote{StakedRelayers}}. Return \sphinxcode{\sphinxupquote{ERR\_ALREADY\_REGISTERED}} if this check fails.

\item {} 
Check that \sphinxcode{\sphinxupquote{stake \textgreater{} STAKED\_RELAYER\_STAKE}} holds, i.e., the staked relayer provided sufficient collateral. Return \sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_STAKE}} error if this check fails.

\item {} 
Lock the stake/collateral by calling {\hyperref[\detokenize{spec/collateral:lockcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{lockCollateral}}}} and passing \sphinxcode{\sphinxupquote{stakedRelayer}} and the \sphinxcode{\sphinxupquote{stake}} as parameters.

\item {} 
Store the provided information (amount of \sphinxcode{\sphinxupquote{stake}}) in a new \sphinxcode{\sphinxupquote{StakedRelayer}} and insert it into the \sphinxcode{\sphinxupquote{StakedRelayers}} mapping using the \sphinxcode{\sphinxupquote{stakedRelayer}} AccountId as key.

\item {} 
Emit a \sphinxcode{\sphinxupquote{RegisterStakedRelayer(StakedRelayer, collateral)}} event.

\end{enumerate}


\subsection{deRegisterStakedRelayer}
\label{\detokenize{spec/staked-relayers:deregisterstakedrelayer}}\label{\detokenize{spec/staked-relayers:id3}}
De\sphinxhyphen{}registers a Staked Relayer, releasing the associated stake.


\subsubsection{Specification}
\label{\detokenize{spec/staked-relayers:id4}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{registerStakedRelayer(stakedRelayer)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{stakedRelayer}}: The account of the staked relayer to be de\sphinxhyphen{}registered.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DeRegisterStakedRelayer(StakedRelayer)}}: emit an event stating that a staked relayer has been de\sphinxhyphen{}registered (\sphinxcode{\sphinxupquote{stakedRelayer}}).

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_NOT\_REGISTERED = "This AccountId is not registered as a Staked Relayer"}}: The given account identifier is not registered.

\end{itemize}


\subsubsection{Preconditions}
\label{\detokenize{spec/staked-relayers:id5}}

\subsubsection{Function Sequence}
\label{\detokenize{spec/staked-relayers:id6}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
Check if the \sphinxcode{\sphinxupquote{stakedRelayer}} is indeed registered in \sphinxcode{\sphinxupquote{StakedRelayers}}. Return \sphinxcode{\sphinxupquote{ERR\_NOT\_REGISTERED}} if this check fails.

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
Release the stake/collateral of the \sphinxcode{\sphinxupquote{stakedRelayer}} by calling {\hyperref[\detokenize{spec/collateral:lockcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{lockCollateral}}}} and passing \sphinxcode{\sphinxupquote{stakedRelayer}} and the \sphinxcode{\sphinxupquote{StakeRelayer.stake}} (as retrieved from \sphinxcode{\sphinxupquote{StakedRelayers}}) as parameters.

\item {} 
Remove the entry from \sphinxcode{\sphinxupquote{StakedRelayers}} which has \sphinxcode{\sphinxupquote{stakedRelayer}} as key.

\item {} 
Emit a \sphinxcode{\sphinxupquote{DeRegisterStakedRelayer(StakedRelayer)}} event.

\end{enumerate}


\subsection{slashStakedRelayer}
\label{\detokenize{spec/staked-relayers:slashstakedrelayer}}\label{\detokenize{spec/staked-relayers:id7}}
Slashes the stake/collateral of a staked relayer and removes them from the staked relayer list (mapping).

\begin{sphinxadmonition}{warning}{Warning:}
This function can only be called by the Governance Mechanism.
\end{sphinxadmonition}


\subsubsection{Specification}
\label{\detokenize{spec/staked-relayers:id8}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{slashStakedRelayer(governanceMechanism, stakedRelayer)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{governanceMechanism}}: The AccountId of the Governance Mechanism.

\item {} 
\sphinxcode{\sphinxupquote{stakedRelayer}}: The account of the staked relayer to be slashed.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SlashStakedRelayer(stakedRelayer)}}: emits an event indicating that a given staked relayer (\sphinxcode{\sphinxupquote{stakedRelayer}}) has been slashed and removed from \sphinxcode{\sphinxupquote{StakedRelayers}}.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_GOVERNANCE\_ONLY = This action can only be executed by the Governance Mechanism}}: Only the Governance Mechanism can slash Staked Relayers.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_NOT\_REGISTERED = "This AccountId is not registered as a Staked Relayer"}}: The given account identifier is not registered.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/staked-relayers:id9}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check that the caller of this function is indeed the Governance Mechanism. Return \sphinxcode{\sphinxupquote{ERR\_GOVERNANCE\_ONLY}} if this check fails.

\item {} 
Retrieve the staked relayer with the given account identifier (\sphinxcode{\sphinxupquote{stakedRelayer}}) from \sphinxcode{\sphinxupquote{StakedRelayers}}. Return \sphinxcode{\sphinxupquote{ERR\_NOT\_REGISTERED}} if not staked relayer with the given identifier can be found.

\item {} 
Confiscate the Staked Relayer’s collateral. For this, call {\hyperref[\detokenize{spec/collateral:slashcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{slashCollateral}}}} providing \sphinxcode{\sphinxupquote{stakedRelayer}} and \sphinxcode{\sphinxupquote{governanceMechanism}} as parameters.

\item {} 
Remove \sphinxcode{\sphinxupquote{stakedRelayer}} from \sphinxcode{\sphinxupquote{StakedRelayers}}

\item {} 
Emit \sphinxcode{\sphinxupquote{SlashStakedRelayer(stakedRelayer)}} event.

\end{enumerate}


\subsection{reportVaultTheft}
\label{\detokenize{spec/staked-relayers:reportvaulttheft}}\label{\detokenize{spec/staked-relayers:id10}}
A staked relayer reports misbehavior by a vault, providing a fraud proof (malicious Bitcoin transaction and the corresponding transaction inclusion proof).

A vault is not allowed to move BTC from any registered Bitcoin address (as specified by \sphinxcode{\sphinxupquote{Vault.wallet}}), except in the following three cases:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
The vault is executing a {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}. In this case, we can link the transaction to a \sphinxcode{\sphinxupquote{RedeemRequest}} and check the correct recipient.

\item {} 
The vault is executing a {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}. In this case, we can link the transaction to a \sphinxcode{\sphinxupquote{ReplaceRequest}} and check the correct recipient.

\item {} 
The vault is executing a {\hyperref[\detokenize{spec/refund:refund-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Refund}}}}. In this case, we can link the transaction to a \sphinxcode{\sphinxupquote{RefundRequest}} and check the correct recipient.

\item {} 
{[}Optional{]} The vault is “merging” multiple UTXOs it controls into a single / multiple UTXOs it controls, e.g. for maintenance. In this case, the recipient address of all outputs (e.g. \sphinxcode{\sphinxupquote{P2PKH}} / \sphinxcode{\sphinxupquote{P2WPKH}}) must be the same Vault.

\end{enumerate}

In all other cases, the vault is considered to have stolen the BTC.

This function checks if the vault actually misbehaved (i.e., makes sure that the provided transaction is not one of the above valid cases) and automatically liquidates the vault (i.e., triggers {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}).


\subsubsection{Specification}
\label{\detokenize{spec/staked-relayers:id11}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{reportVaultTheft(vault, merkleProof, rawTx)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: the account of the accused Vault.

\item {} 
\sphinxcode{\sphinxupquote{merkleProof}}: Merkle tree path (concatenated LE SHA256 hashes).

\item {} 
\sphinxcode{\sphinxupquote{rawTx}}: Raw Bitcoin transaction including the transaction inputs and outputs.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ReportVaultTheft(vault)}} \sphinxhyphen{} emits an event indicating that a vault (\sphinxcode{\sphinxupquote{vault}}) has been caught displacing BTC without permission.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_STAKED\_RELAYERS\_ONLY = "This action can only be executed by Staked Relayers"}}: The caller of this function was not a Staked Relayer. Only Staked Relayers are allowed to suggest and vote on BTC Parachain status updates.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_ALREADY\_REPORTED = "This txId has already been logged as a theft by the given Vault"}}: This transaction / vault combination has already been reported.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_FOUND = "There exists no vault with the given account id"}}: The specified vault does not exist.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_ALREADY\_LIQUIDATED = "This vault is already being liquidated}}: The specified vault is already being liquidated.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_VALID\_REDEEM = "The given transaction is a valid Redeem execution by the accused Vault"}}: The given transaction is associated with a valid {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_VALID\_REPLACE = "The given transaction is a valid Replace execution by the accused Vault"}}: The given transaction is associated with a valid {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_VALID\_REFUND = "The given transaction is a valid Refund execution by the accused Vault"}}: The given transaction is associated with a valid {\hyperref[\detokenize{spec/refund:refund-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Refund}}}}.

\item {} 
\sphinxcode{\sphinxupquote{ERR\_VALID\_MERGE\_TRANSACTION = "The given transaction is a valid \textquotesingle{}UTXO merge\textquotesingle{} transaction by the accused Vault"}}: The given transaction represents an allowed “merging” of UTXOs by the accused vault (no BTC was displaced).

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/staked-relayers:id12}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check that the caller of this function is indeed a Staked Relayer. Return \sphinxcode{\sphinxupquote{ERR\_STAKED\_RELAYERS\_ONLY}} if this check fails.

\item {} 
Check if the specified \sphinxcode{\sphinxupquote{vault}} exists in \sphinxcode{\sphinxupquote{Vaults}} in {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}. Return \sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_FOUND}} if there is no vault with the specified account identifier.

\item {} 
Check if this \sphinxcode{\sphinxupquote{vault}} has already been liquidated. If this is the case, return \sphinxcode{\sphinxupquote{ERR\_ALREADY\_LIQUIDATED}} (no point in duplicate reporting).

\item {} 
Check if the given Bitcoin transaction is already associated with an entry in \sphinxcode{\sphinxupquote{TheftReports}} (calculate \sphinxcode{\sphinxupquote{txId}} from \sphinxcode{\sphinxupquote{rawTx}} as key for lookup). If yes, check if the specified \sphinxcode{\sphinxupquote{vault}} is already listed in the associated set of Vaults. If the vault is already in the set, return \sphinxcode{\sphinxupquote{ERR\_ALREADY\_REPORTED}}.

\item {} 
Extract the \sphinxcode{\sphinxupquote{outputs}} from \sphinxcode{\sphinxupquote{rawTx}} using \sphinxtitleref{extractOutputs} from the BTC\sphinxhyphen{}Relay.

\item {} 
Check if the transaction is a “migration” of UTXOs to the same Vault. For each output, in the extracted \sphinxcode{\sphinxupquote{outputs}}, extract the recipient Bitcoin address (using \sphinxtitleref{extractOutputAddress} from the BTC\sphinxhyphen{}Relay).
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{)}%
\item {} 
If one of the extracted Bitcoin addresses does not match a Bitcoin address of the accused \sphinxcode{\sphinxupquote{vault}} (\sphinxcode{\sphinxupquote{Vault.wallet}}) \sphinxstylestrong{continue to step 7}.

\item {} 
If all extracted addresses match the Bitcoin addresses of the accused \sphinxcode{\sphinxupquote{vault}} (\sphinxcode{\sphinxupquote{Vault.wallet}}), abort and return \sphinxcode{\sphinxupquote{ERR\_VALID\_MERGE\_TRANSACTION}}.

\end{enumerate}

\item {} 
Check if the transaction is part of a valid {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}} or {\hyperref[\detokenize{spec/refund:refund-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Refund}}}} process.

\end{enumerate}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\item {} 
Extract the OP\_RETURN value using \sphinxtitleref{extractOPRETURN} from the BTC\sphinxhyphen{}Relay. If this call returns an error (no valid OP\_RETURN output, hence not valid {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}} or {\hyperref[\detokenize{spec/refund:refund-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Refund}}}} process), \sphinxstylestrong{continue to step 8}.

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
Check if the extracted OP\_RETURN value matches any \sphinxcode{\sphinxupquote{redeemId}} in \sphinxcode{\sphinxupquote{RedeemRequest}} (in \sphinxcode{\sphinxupquote{RedeemRequests}} in {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}), any \sphinxcode{\sphinxupquote{replaceId}} in \sphinxcode{\sphinxupquote{ReplaceRequest}} (in \sphinxcode{\sphinxupquote{RedeemRequests}} in {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}) or any \sphinxcode{\sphinxupquote{refundId}} in \sphinxcode{\sphinxupquote{RefundRequest}} (in \sphinxcode{\sphinxupquote{RefundRequests}} in {\hyperref[\detokenize{spec/refund:refund-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Refund}}}}) entries \sphinxstyleemphasis{associated with this Vault}. If no match is found, \sphinxstylestrong{continue to step 8}.

\item {} 
Otherwise, if an associated \sphinxcode{\sphinxupquote{RedeemRequest}}, \sphinxcode{\sphinxupquote{ReplaceRequest}} or \sphinxcode{\sphinxupquote{RefundRequest}} was found: extract the value (using \sphinxtitleref{extractOutputValue} from the BTC\sphinxhyphen{}Relay) and recipient Bitcoin address (using \sphinxtitleref{extractOutputAddress} from the BTC\sphinxhyphen{}Relay). Next, check:
\begin{quote}

i ) if the value is equal (or greater) than \sphinxcode{\sphinxupquote{paymentValue}} in the \sphinxcode{\sphinxupquote{RedeemRequest}}, \sphinxcode{\sphinxupquote{ReplaceRequest}} or \sphinxcode{\sphinxupquote{RefundRequest}}.

ii ) if the recipient Bitcoin address matches the recipient specified in the \sphinxcode{\sphinxupquote{RedeemRequest}}, \sphinxcode{\sphinxupquote{ReplaceRequest}} or \sphinxcode{\sphinxupquote{RefundRequest}}.

iii ) if the change Bitcoin address(es) are registered to the accused \sphinxcode{\sphinxupquote{vault}} (\sphinxcode{\sphinxupquote{Vault.wallet}}).
\end{quote}

\end{enumerate}
\begin{quote}

If all checks are successful, abort and return \sphinxcode{\sphinxupquote{ERR\_VALID\_REDEEM}}, \sphinxcode{\sphinxupquote{ERR\_VALID\_REPLACE}} or \sphinxcode{\sphinxupquote{ERR\_VALID\_REFUND}}. Otherwise, \sphinxstylestrong{continue to step 8}.
\end{quote}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
The vault misbehaved (displaced BTC).
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{)}%
\item {} 
Call {\hyperref[\detokenize{spec/vault-registry:liquidatevault}]{\sphinxcrossref{\DUrole{std,std-ref}{liquidateVault}}}}, liquidating the vault and transferring all of its balances and collateral to the \sphinxcode{\sphinxupquote{LiquidationVault}} for failure and reimbursement handling;

\item {} 
emit \sphinxcode{\sphinxupquote{ReportVaultTheft(vaultId)}}

\end{enumerate}

\item {} 
Return

\end{enumerate}


\section{Events}
\label{\detokenize{spec/staked-relayers:events}}

\subsection{RegisterStakedRelayer}
\label{\detokenize{spec/staked-relayers:id13}}
Emit an event stating that a new staked relayer was registered and provide information on the Staked Relayer’s stake

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RegisterStakedRelayer(StakedRelayer, collateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{stakedRelayer}}: newly registered staked Relayer

\item {} 
\sphinxcode{\sphinxupquote{stake}}: stake provided by the staked relayer upon registration

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/staked-relayers:registerstakedrelayer}]{\sphinxcrossref{\DUrole{std,std-ref}{registerStakedRelayer}}}}

\end{itemize}


\subsection{DeRegisterStakedRelayer}
\label{\detokenize{spec/staked-relayers:id14}}
Emit an event stating that a staked relayer has been de\sphinxhyphen{}registered

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{DeRegisterStakedRelayer(StakedRelayer)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{stakedRelayer}}: account identifier of de\sphinxhyphen{}registered Staked Relayer

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/staked-relayers:deregisterstakedrelayer}]{\sphinxcrossref{\DUrole{std,std-ref}{deRegisterStakedRelayer}}}}

\end{itemize}


\subsection{SlashStakedRelayer}
\label{\detokenize{spec/staked-relayers:id15}}
Emits an event indicating that a staked relayer has been slashed.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{SlashStakedRelayer(stakedRelayer)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{stakedRelayer}}: account identifier of the slashed staked relayer.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/staked-relayers:slashstakedrelayer}]{\sphinxcrossref{\DUrole{std,std-ref}{slashStakedRelayer}}}}

\end{itemize}


\subsection{ReportVaultTheft}
\label{\detokenize{spec/staked-relayers:id16}}
Emits an event when a vault has been accused of theft.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{ReportVaultTheft(vault)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: account identifier of the vault accused of theft.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\end{itemize}


\section{Errors}
\label{\detokenize{spec/staked-relayers:errors}}
\sphinxcode{\sphinxupquote{ERR\_NOT\_REGISTERED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “This AccountId is not registered as a Staked Relayer.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:deregisterstakedrelayer}]{\sphinxcrossref{\DUrole{std,std-ref}{deRegisterStakedRelayer}}}}, {\hyperref[\detokenize{spec/staked-relayers:slashstakedrelayer}]{\sphinxcrossref{\DUrole{std,std-ref}{slashStakedRelayer}}}}

\item {} 
\sphinxstylestrong{Cause}: The given account identifier is not registered.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_GOVERNANCE\_ONLY}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “This action can only be executed by the Governance Mechanism”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:slashstakedrelayer}]{\sphinxcrossref{\DUrole{std,std-ref}{slashStakedRelayer}}}}

\item {} 
\sphinxstylestrong{Cause}: The suggested status (\sphinxcode{\sphinxupquote{SHUTDOWN}}) can only be triggered by the Governance Mechanism but the caller of the function is not part of the Governance Mechanism.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_STAKED\_RELAYERS\_ONLY}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “This action can only be executed by Staked Relayers”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\item {} 
\sphinxstylestrong{Cause}: The caller of this function was not a Staked Relayer. Only Staked Relayers are allowed to suggest and vote on BTC Parachain status updates.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_ALREADY\_REPORTED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “This txId has already been logged as a theft by the given Vault”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\item {} 
\sphinxstylestrong{Cause}: This transaction / vault combination has already been reported.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_FOUND}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “There exists no vault with the given account id”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\item {} 
\sphinxstylestrong{Cause}:  The specified vault does not exist.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_ALREADY\_LIQUIDATED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “This vault is already being liquidated”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\item {} 
\sphinxstylestrong{Cause}:  The specified vault is already being liquidated.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VALID\_REDEEM}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The given transaction is a valid Redeem execution by the accused Vault”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\item {} 
\sphinxstylestrong{Cause}: The given transaction is associated with a valid {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VALID\_REPLACE}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The given transaction is a valid Replace execution by the accused Vault”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\item {} 
\sphinxstylestrong{Cause}: The given transaction is associated with a valid {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VALID\_REFUND}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The given transaction is a valid Refund execution by the accused Vault”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\item {} 
\sphinxstylestrong{Cause}: The given transaction is associated with a valid {\hyperref[\detokenize{spec/refund:refund-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Refund}}}}.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VALID\_MERGE\_TRANSACTION}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The given transaction is a valid ‘UTXO merge’ transaction by the accused Vault”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}

\item {} 
\sphinxstylestrong{Cause}: The given transaction represents an allowed “merging” of UTXOs by the accused vault (no BTC was displaced).

\end{itemize}


\chapter{Treasury}
\label{\detokenize{spec/treasury:treasury}}\label{\detokenize{spec/treasury:treasury-module}}\label{\detokenize{spec/treasury::doc}}

\section{Overview}
\label{\detokenize{spec/treasury:overview}}
The treasury serves as the central storage for all interbtc.
It exposes the {\hyperref[\detokenize{spec/treasury:transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{transfer}}}} function to any user. With the transfer functions users can send interbtc to and from each other.
Further, the treasury exposes three internal functions for the {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}} and the {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}.


\subsection{Step\sphinxhyphen{}by\sphinxhyphen{}step}
\label{\detokenize{spec/treasury:step-by-step}}\begin{itemize}
\item {} 
\sphinxstylestrong{Transfer}: A user sends an amount of interbtc to another user by calling the {\hyperref[\detokenize{spec/treasury:transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{transfer}}}} function.

\item {} 
\sphinxstylestrong{Issue}: The issue module calls into the treasury when an issue request is completed and the user has provided a valid proof that he transferred the required amount of BTC to the correct vault. The issue module calls the {\hyperref[\detokenize{spec/treasury:mint}]{\sphinxcrossref{\DUrole{std,std-ref}{mint}}}} function to grant the user the interbtc token.

\item {} 
\sphinxstylestrong{Redeem}: The redeem protocol requires two calls to the treasury module. First, a user requests a redeem via the {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}} function. This invokes a call to the {\hyperref[\detokenize{spec/treasury:lock}]{\sphinxcrossref{\DUrole{std,std-ref}{lock}}}} function that locks the requested amount of tokens for this user. Second, when a redeem request is completed and the vault has provided a valid proof that it transferred the required amount of BTC to the correct user, the redeem module calls the {\hyperref[\detokenize{spec/treasury:burn}]{\sphinxcrossref{\DUrole{std,std-ref}{burn}}}} function to destroy the previously locked interbtc.

\end{itemize}


\section{Data Model}
\label{\detokenize{spec/treasury:data-model}}

\subsection{Constants}
\label{\detokenize{spec/treasury:constants}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{NAME}}: \sphinxcode{\sphinxupquote{interbtc}}

\item {} 
\sphinxcode{\sphinxupquote{SYMBOL}}: \sphinxcode{\sphinxupquote{pBTC}}

\end{itemize}


\subsection{Scalars}
\label{\detokenize{spec/treasury:scalars}}

\subsubsection{TotalSupply}
\label{\detokenize{spec/treasury:totalsupply}}
The total supply of interbtc.


\subsection{Maps}
\label{\detokenize{spec/treasury:maps}}

\subsubsection{Balances}
\label{\detokenize{spec/treasury:balances}}
Mapping from accounts to their balance.


\subsubsection{Locked Balances}
\label{\detokenize{spec/treasury:locked-balances}}
Mapping from accounts to their balance of locked tokens. Locked tokens serve two purposes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Locked tokens cannot be transferred. Once a user locks the token, the token needs to be unlocked to become spendable.

\item {} 
Locked tokens are the only tokens that can be burned in the redeem procedure.

\end{enumerate}


\section{Functions}
\label{\detokenize{spec/treasury:functions}}

\subsection{transfer}
\label{\detokenize{spec/treasury:transfer}}\label{\detokenize{spec/treasury:id1}}
Transfers a specified amount of interbtc from a Sender to a Receiver on the BTC Parachain.


\subsubsection{Specification}
\label{\detokenize{spec/treasury:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{transfer(sender, receiver, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: An account with enough funds to send the \sphinxcode{\sphinxupquote{amount}} of interbtc to the \sphinxcode{\sphinxupquote{receiver}}.

\item {} 
\sphinxcode{\sphinxupquote{receiver}}: Account receiving an amount of interbtc.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The number of interbtc being sent in the transaction.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Transfer(sender, receiver, amount)}}: Issues an event when a transfer of funds was successful.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_FUNDS}}: The sender does not have a high enough balance to send an \sphinxcode{\sphinxupquote{amount}} of interbtc.

\end{itemize}

\sphinxcode{\sphinxupquote{fn transfer(origin, receiver: AccountId, amount: Balance) \sphinxhyphen{}\textgreater{} Result \{...\}}}


\subsubsection{Function Sequence}
\label{\detokenize{spec/treasury:function-sequence}}
The \sphinxcode{\sphinxupquote{transfer}} function takes as input the sender, the receiver, and an amount. The function executes the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check that the \sphinxcode{\sphinxupquote{sender}} is authorised to send the transaction by verifying the signature attached to the transaction.

\item {} 
Check that the \sphinxcode{\sphinxupquote{sender}}’s balance is above the \sphinxcode{\sphinxupquote{amount}}. If \sphinxcode{\sphinxupquote{Balances{[}sender{]} \textless{} amount}} (in Substrate \sphinxcode{\sphinxupquote{free\_balance}}), raise \sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_FUNDS}}.

\item {} 
Subtract the sender’s balance by \sphinxcode{\sphinxupquote{amount}}, i.e. \sphinxcode{\sphinxupquote{Balances{[}sender{]} \sphinxhyphen{}= amount}} and add \sphinxcode{\sphinxupquote{amount}} to the receiver’s balance, i.e. \sphinxcode{\sphinxupquote{Balances{[}receiver{]} += amount}}.

\item {} 
Emit the \sphinxcode{\sphinxupquote{Transfer(sender, receiver, amount)}} event.

\end{enumerate}


\subsection{mint}
\label{\detokenize{spec/treasury:mint}}\label{\detokenize{spec/treasury:id2}}
In the BTC Parachain new interbtc can be created by leveraging the {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}}.
However, to separate concerns and access to data, the Issue module has to call the \sphinxcode{\sphinxupquote{mint}} function to complete the issue process in the interbtc component.
The function increases the \sphinxcode{\sphinxupquote{totalSupply}} of interbtc.

\begin{sphinxadmonition}{warning}{Warning:}
This function can \sphinxstyleemphasis{only} be called from the Issue module.
\end{sphinxadmonition}


\subsubsection{Specification}
\label{\detokenize{spec/treasury:id3}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{mint(requester, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{requester}}: The account of the requester of interbtc.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc to be added to an account.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Mint(requester, amount)}}: Issue an event when new interbtc are minted.

\end{itemize}

\sphinxcode{\sphinxupquote{fn mint(requester: AccountId, amount: Balance) \sphinxhyphen{}\textgreater{} Result \{...\}}}


\subsubsection{Preconditions}
\label{\detokenize{spec/treasury:preconditions}}
This is an internal function and can only be called by the {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue module}}}}.


\subsubsection{Function Sequence}
\label{\detokenize{spec/treasury:id4}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Increase the \sphinxcode{\sphinxupquote{requester}} Balance by \sphinxcode{\sphinxupquote{amount}}, i.e. \sphinxcode{\sphinxupquote{Balances{[}requester{]} += amount}}.

\item {} 
Emit the \sphinxcode{\sphinxupquote{Mint(requester, amount)}} event.

\end{enumerate}


\subsection{lock}
\label{\detokenize{spec/treasury:lock}}\label{\detokenize{spec/treasury:id5}}
During the redeem process, a user needs to be able to lock interbtc. Locking transfers coins from the \sphinxcode{\sphinxupquote{Balances}} mapping to the \sphinxcode{\sphinxupquote{LockedBalances}} mapping to prevent users from transferring the coins.


\subsubsection{Specification}
\label{\detokenize{spec/treasury:id6}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{lock(redeemer, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: The Redeemer wishing to lock a certain amount of interbtc.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc that should be locked.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Lock(redeemer, amount)}}: Emits newly locked amount of interbtc by a user.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_FUNDS}}: User has not enough interbtc to lock coins.

\end{itemize}


\subsubsection{Precondition}
\label{\detokenize{spec/treasury:precondition}}\begin{itemize}
\item {} 
Can only be called by the redeem module.

\end{itemize}


\subsubsection{Function Sequence}
\label{\detokenize{spec/treasury:id7}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Checks if the user has a balance higher than or equal to the requested amount, i.e. \sphinxcode{\sphinxupquote{Balances{[}redeemer{]} \textgreater{}= amount}}. Return \sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_FUNDS}} if the user’s balance is too low.

\item {} 
Decreases the user’s token balance by the amount and increases the locked tokens balance by amount, i.e. \sphinxcode{\sphinxupquote{Balances{[}redeemer{]} \sphinxhyphen{}= amount}} and \sphinxcode{\sphinxupquote{LockedBalances{[}redeemer{]} += amount}}.

\item {} 
Emit the \sphinxcode{\sphinxupquote{Lock}} event.

\end{enumerate}


\subsection{burn}
\label{\detokenize{spec/treasury:burn}}\label{\detokenize{spec/treasury:id8}}
During the {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, users first lock and then “burn” (i.e. destroy) their interbtc to receive BTC. Users can only burn tokens once they are locked to prevent transaction ordering dependencies. This means a user first needs to move his tokens from the \sphinxcode{\sphinxupquote{Balances}} to the \sphinxcode{\sphinxupquote{LockedBalances}} mapping via the {\hyperref[\detokenize{spec/treasury:lock}]{\sphinxcrossref{\DUrole{std,std-ref}{lock}}}} function.

\begin{sphinxadmonition}{warning}{Warning:}
This function is only internally callable by the Redeem module.
\end{sphinxadmonition}


\subsubsection{Specification}
\label{\detokenize{spec/treasury:id9}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{burn(redeemer, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: The Redeemer wishing to burn a certain amount of interbtc.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc that should be destroyed.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Burn(redeemer, amount)}}: Issue an event when the amount of interbtc is successfully destroyed.

\end{itemize}

\sphinxstyleemphasis{Errors}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_LOCKED\_FUNDS}}: If the user has insufficient funds locked, i.e. her locked balance is lower than the amount.

\end{itemize}

\sphinxcode{\sphinxupquote{fn burn(redeemer: AccountId, amount: Balance) \sphinxhyphen{}\textgreater{} Result \{...\}}}


\subsubsection{Preconditions}
\label{\detokenize{spec/treasury:id10}}
This is an internal function and can only be called by the {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem module}}}}.


\subsubsection{Function Sequence}
\label{\detokenize{spec/treasury:id11}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Check that the \sphinxcode{\sphinxupquote{redeemer}}’s locked balance is above the \sphinxcode{\sphinxupquote{amount}}. If \sphinxcode{\sphinxupquote{LockedBalance{[}redeemer{]} \textless{} amount}} (in Substrate \sphinxcode{\sphinxupquote{free\_balance}}), raise \sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_LOCKED\_FUNDS}}.

\item {} 
Subtract the Redeemer’s locked balance by \sphinxcode{\sphinxupquote{amount}}, i.e. \sphinxcode{\sphinxupquote{LockedBalances{[}redeemer{]} \sphinxhyphen{}= amount}}.

\item {} 
Emit the \sphinxcode{\sphinxupquote{Burn(redeemer, amount)}} event.

\end{enumerate}


\section{Events}
\label{\detokenize{spec/treasury:events}}

\subsection{Transfer}
\label{\detokenize{spec/treasury:id12}}
Issues an event when a transfer of funds was successful.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{Transfer(sender, receiver, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sender}}: An account with enough funds to send the \sphinxcode{\sphinxupquote{amount}} of interbtc to the \sphinxcode{\sphinxupquote{receiver}}.

\item {} 
\sphinxcode{\sphinxupquote{receiver}}: Account receiving an amount of interbtc.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The number of interbtc being sent in the transaction.

\end{itemize}

\sphinxstyleemphasis{Function}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/treasury:transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{transfer}}}}

\end{itemize}


\subsection{Mint}
\label{\detokenize{spec/treasury:id13}}
Issue an event when new interbtc are minted.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{Mint(requester, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{requester}}: The account of the requester of interbtc.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc to be added to an account.

\end{itemize}

\sphinxstyleemphasis{Function}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/treasury:mint}]{\sphinxcrossref{\DUrole{std,std-ref}{mint}}}}

\end{itemize}


\subsection{Lock}
\label{\detokenize{spec/treasury:id14}}
Emits newly locked amount of interbtc by a user.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{Lock(redeemer, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: The Redeemer wishing to lock a certain amount of interbtc.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc that should be locked.

\end{itemize}

\sphinxstyleemphasis{Function}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/treasury:lock}]{\sphinxcrossref{\DUrole{std,std-ref}{lock}}}}

\end{itemize}


\subsection{Burn}
\label{\detokenize{spec/treasury:id15}}
Issue an event when the amount of interbtc is successfully destroyed.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{Burn(redeemer, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: The Redeemer wishing to burn a certain amount of interbtc.

\item {} 
\sphinxcode{\sphinxupquote{amount}}: The amount of interbtc that should be burned.

\end{itemize}

\sphinxstyleemphasis{Function}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/treasury:burn}]{\sphinxcrossref{\DUrole{std,std-ref}{burn}}}}

\end{itemize}


\section{Errors}
\label{\detokenize{spec/treasury:errors}}
\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_FUNDS}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The balance of this account is insufficient to complete the transaction.”

\item {} 
\sphinxstylestrong{Functions}: {\hyperref[\detokenize{spec/treasury:transfer}]{\sphinxcrossref{\DUrole{std,std-ref}{transfer}}}} | {\hyperref[\detokenize{spec/treasury:lock}]{\sphinxcrossref{\DUrole{std,std-ref}{lock}}}}

\item {} 
\sphinxstylestrong{Cause}: The balance of the user of available tokens (i.e. \sphinxcode{\sphinxupquote{Balances}}) is below a certain amount to either transfer or lock tokens.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_LOCKED\_FUNDS}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The locked token balance of this account is insufficient to burn the tokens.”

\item {} 
\sphinxstylestrong{Function}: {\hyperref[\detokenize{spec/treasury:burn}]{\sphinxcrossref{\DUrole{std,std-ref}{burn}}}}

\item {} 
\sphinxstylestrong{Cause}: The user has locked too little tokens in the \sphinxcode{\sphinxupquote{LockedBalances}} to execute the burn function.

\end{itemize}


\chapter{Vault Registry}
\label{\detokenize{spec/vault-registry:vault-registry}}\label{\detokenize{spec/vault-registry:id1}}\label{\detokenize{spec/vault-registry::doc}}

\section{Overview}
\label{\detokenize{spec/vault-registry:overview}}
The vault registry is the central place to manage vaults. Vaults can register themselves here, update their collateral, or can be liquidated.
Similarly, the issue, redeem, refund, and replace protocols call this module to assign vaults during issue, redeem, refund, and replace procedures.
Morever, vaults use the registry to register public key for the {\hyperref[\detokenize{security_performance/security-analysis:okd}]{\sphinxcrossref{\DUrole{std,std-ref}{On\sphinxhyphen{}Chain Key Derivation Scheme}}}} and register addresses for the {\hyperref[\detokenize{security_performance/security-analysis:op-return}]{\sphinxcrossref{\DUrole{std,std-ref}{OP\_RETURN}}}} scheme.


\section{Data Model}
\label{\detokenize{spec/vault-registry:data-model}}

\subsection{Constants}
\label{\detokenize{spec/vault-registry:constants}}

\subsection{Scalars}
\label{\detokenize{spec/vault-registry:scalars}}

\subsubsection{MinimumCollateralVault}
\label{\detokenize{spec/vault-registry:minimumcollateralvault}}
The minimum collateral a vault needs to provide to participate in the issue process.

\begin{sphinxadmonition}{note}{Note:}
This is a protection against spamming the protocol with very small collateral amounts. Vaults are still able to withdraw the collateral after registration, but at least it requires an additional transaction fee, and it provides protection against accidental registration with very low amounts of collateral.
\end{sphinxadmonition}


\subsubsection{PunishmentDelay}
\label{\detokenize{spec/vault-registry:punishmentdelay}}
If a Vault fails to execute a correct redeem or replace, it is \sphinxstyleemphasis{temporarily} banned from further issue, redeem or replace requests. This value configures the duration of this ban (in number of blocks) .


\subsubsection{SecureCollateralThreshold}
\label{\detokenize{spec/vault-registry:securecollateralthreshold}}\label{\detokenize{spec/vault-registry:id2}}
Determines the over\sphinxhyphen{}collateralization rate for collateral locked by Vaults, necessary for issuing tokens. This threshold should be greater than the LiquidationCollateralThreshold, and typically it should be greater than the PremiumRedeemThreshold as well.

The vault can take on issue requests depending on the collateral it provides and under consideration of the \sphinxcode{\sphinxupquote{SecureCollateralThreshold}}.
The maximum amount of interbtc a vault is able to support during the issue process is based on the following equation:
\(\text{max(interbtc)} = \text{collateral} * \text{ExchangeRate} / \text{SecureCollateralThreshold}\).

\begin{sphinxadmonition}{note}{Note:}
As an example, assume we use \sphinxcode{\sphinxupquote{DOT}} as collateral, we issue \sphinxcode{\sphinxupquote{interbtc}} and lock \sphinxcode{\sphinxupquote{BTC}} on the Bitcoin side. Let’s assume the \sphinxcode{\sphinxupquote{BTC}}/\sphinxcode{\sphinxupquote{DOT}} exchange rate is \sphinxcode{\sphinxupquote{80}}, i.e. one has to pay 80 \sphinxcode{\sphinxupquote{DOT}} to receive 1 \sphinxcode{\sphinxupquote{BTC}}. Further, the \sphinxcode{\sphinxupquote{SecureCollateralThreshold}} is 200\%, i.e. a vault has to provide two\sphinxhyphen{}times the amount of collateral to back an issue request. Now let’s say the vault deposits 400 \sphinxcode{\sphinxupquote{DOT}} as collateral. Then this vault can back at most 2.5 interbtc as: \(400 * (1/80) / 2 = 2.5\).
\end{sphinxadmonition}


\subsubsection{PremiumRedeemThreshold}
\label{\detokenize{spec/vault-registry:premiumredeemthreshold}}\label{\detokenize{spec/vault-registry:premiumcollateralthreshold}}
Determines the rate for the collateral rate of Vaults, at which users receive a premium, allocated from the Vault’s collateral, when performing a {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}} with this Vault. This threshold should be greater than the LiquidationCollateralThreshold. Typically this value should be greater than the LiquidationCollateralThreshold.


\subsubsection{LiquidationCollateralThreshold}
\label{\detokenize{spec/vault-registry:liquidationcollateralthreshold}}\label{\detokenize{spec/vault-registry:id3}}
Determines the lower bound for the collateral rate in issued tokens. If a Vault’s collateral rate drops below this, automatic liquidation is triggered.


\subsubsection{LiquidationVault}
\label{\detokenize{spec/vault-registry:liquidationvault}}
Account identifier of an artificial vault maintained by the VaultRegistry to handle interbtc balances and DOT collateral of liquidated Vaults. That is, when a vault is liquidated, its balances are transferred to \sphinxcode{\sphinxupquote{LiquidationVault}} and claims are later handled via the \sphinxcode{\sphinxupquote{LiquidationVault}}.

\begin{sphinxadmonition}{note}{Note:}
A Vault’s token balances and DOT collateral are transferred to the \sphinxcode{\sphinxupquote{LiquidationVault}} as a result of automated liquidations and {\hyperref[\detokenize{spec/staked-relayers:reportvaulttheft}]{\sphinxcrossref{\DUrole{std,std-ref}{reportVaultTheft}}}}.
\end{sphinxadmonition}


\subsection{Maps}
\label{\detokenize{spec/vault-registry:maps}}

\subsubsection{Vaults}
\label{\detokenize{spec/vault-registry:vaults}}
Mapping from accounts of Vaults to their struct. \sphinxcode{\sphinxupquote{\textless{}Account, Vault\textgreater{}}}.


\subsection{Structs}
\label{\detokenize{spec/vault-registry:structs}}

\subsubsection{Vault}
\label{\detokenize{spec/vault-registry:vault}}
Stores the information of a Vault.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|l|l|L|}
\hline
\sphinxstyletheadfamily 
Parameter
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{toBeIssuedTokens}}
&
interbtc
&
Number of interbtc tokens currently requested as part of an uncompleted issue request.
\\
\hline
\sphinxcode{\sphinxupquote{issuedTokens}}
&
interbtc
&
Number of interbtc tokens actively issued by this Vault.
\\
\hline
\sphinxcode{\sphinxupquote{toBeRedeemedTokens}}
&
interbtc
&
Number of interbtc tokens reserved by pending redeem and replace requests.
\\
\hline
\sphinxcode{\sphinxupquote{collateral}}
&
DOT
&
Total amount of collateral provided by this vault (note: “free” collateral is calculated on the fly and updated each time new exchange rate data is received).
\\
\hline
\sphinxcode{\sphinxupquote{toBeReplacedTokens}}
&
interbtc
&
Number of interbtc tokens requested for replacement.
\\
\hline
\sphinxcode{\sphinxupquote{replaceCollateral}}
&
DOT
&
Griefing collateral to be used for accepted replace requests.
\\
\hline
\sphinxcode{\sphinxupquote{backingCollateral}}
&
DOT
&
The total amount of collateral the vault uses as insurance for the issued tokens.
\\
\hline
\sphinxcode{\sphinxupquote{wallet}}
&
Wallet\textless{}BtcAddress\textgreater{}
&
A set of Bitcoin address(es) of this vault, used for theft detection. Additionally, it contains the btcPublicKey used for generating deposit addresses in the issue process.
\\
\hline
\sphinxcode{\sphinxupquote{bannedUntil}}
&
u256
&
Block height until which this vault is banned from being used for Issue, Redeem (except during automatic liquidation) and Replace .
\\
\hline
\sphinxcode{\sphinxupquote{status}}
&
VaultStatus
&
Current status of the vault (Active, Liquidated, CommittedTheft)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
This specification currently assumes for simplicity that a vault will reuse the same BTC address, even after multiple redeem requests. \sphinxstylestrong{{[}Future Extension{]}}: For better security, Vaults may desire to generate new BTC addresses each time they execute a redeem request. This can be handled by pre\sphinxhyphen{}generating multiple BTC addresses and storing these in a list for each Vault. Caution is necessary for users which execute issue requests with “old” vault addresses \sphinxhyphen{} these BTC must be moved to the latest address by Vaults.
\end{sphinxadmonition}


\section{Dispatchable Functions}
\label{\detokenize{spec/vault-registry:dispatchable-functions}}

\subsection{registerVault}
\label{\detokenize{spec/vault-registry:registervault}}\label{\detokenize{spec/vault-registry:id4}}
Registers a new Vault. The vault locks up some amount of collateral, and provides a public key which is used for the {\hyperref[\detokenize{security_performance/security-analysis:okd}]{\sphinxcrossref{\DUrole{std,std-ref}{On\sphinxhyphen{}Chain Key Derivation Scheme}}}}.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:specification}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{registerVault(vault, collateral, btcPublicKey)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The account of the vault to be registered.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: to\sphinxhyphen{}be\sphinxhyphen{}locked collateral.

\item {} 
\sphinxcode{\sphinxupquote{btcPublicKey}}: public key used to derive deposit keys with the {\hyperref[\detokenize{security_performance/security-analysis:okd}]{\sphinxcrossref{\DUrole{std,std-ref}{On\sphinxhyphen{}Chain Key Derivation Scheme}}}}.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RegisterVault(Vault, collateral)}}: emit an event stating that a new vault (\sphinxcode{\sphinxupquote{vault}}) was registered and provide information on the Vault’s collateral (\sphinxcode{\sphinxupquote{collateral}}).

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxcode{\sphinxupquote{vaultId}}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be \sphinxcode{\sphinxupquote{SHUTDOWN:2}}.

\item {} 
The vault MUST NOT be registered yet

\item {} 
The vault MUST have sufficient funds to lock the collateral

\item {} 
\sphinxcode{\sphinxupquote{collateral \textgreater{} MinimumCollateralVault}}, i.e., the vault MUST provide sufficient collateral (above the spam protection threshold).

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The provided \sphinxcode{\sphinxupquote{collateral}} is locked.

\item {} 
A new vault is added to \sphinxcode{\sphinxupquote{Vaults}}, with \sphinxcode{\sphinxupquote{backing\_collateral}} set to \sphinxcode{\sphinxupquote{collateral}}, and with \sphinxcode{\sphinxupquote{btcPublicKey}} as the public key in the wallet.

\item {} 
The status is set to \sphinxcode{\sphinxupquote{Active(true)}}, meaning the new vault accepts new issues.

\item {} 
The rest of the variables (\sphinxcode{\sphinxupquote{issuedTokens}}, \sphinxcode{\sphinxupquote{toBeIssuedTokens}}, etc) are zero\sphinxhyphen{}initialized.

\end{itemize}


\subsection{registerAddress}
\label{\detokenize{spec/vault-registry:registeraddress}}\label{\detokenize{spec/vault-registry:id5}}
Add a new BTC address to the vault’s wallet. Typically this function is called by the vault client to register a return\sphinxhyphen{}to\sphinxhyphen{}self address, prior to making redeem/replace payments. If a vault makes a payment to an address that is not registered, nor is a valid redeem/replace payment, it will be marked as theft.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id6}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{registerAddress(vaultId, address)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: the account of the vault.

\item {} 
\sphinxcode{\sphinxupquote{address}}: a valid BTC address.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RegisterAddress(vaultId, address)}}

\end{itemize}

Precondition
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxcode{\sphinxupquote{vaultId}}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST NOT be registered.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{address}} is added to the vault’s wallet.

\end{itemize}


\subsection{updatePublicKey}
\label{\detokenize{spec/vault-registry:updatepublickey}}\label{\detokenize{spec/vault-registry:id7}}
Changes a vault’s public key that is used for the {\hyperref[\detokenize{security_performance/security-analysis:okd}]{\sphinxcrossref{\DUrole{std,std-ref}{On\sphinxhyphen{}Chain Key Derivation Scheme}}}}.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id8}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{updatePublicKey(vaultId, publicKey)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: the account of the vault.

\item {} 
\sphinxcode{\sphinxupquote{publicKey}}: the new BTC public key of the vault.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{UpdatePublicKey(vaultId, publicKey)}}

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxcode{\sphinxupquote{vaultId}}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The vault’s public key is set to \sphinxcode{\sphinxupquote{publicKey}}.

\end{itemize}


\subsection{depositCollateral}
\label{\detokenize{spec/vault-registry:depositcollateral}}\label{\detokenize{spec/vault-registry:id9}}
The vault locks additional collateral as a security against stealing the Bitcoin locked with it.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id10}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{lockCollateral(vaultId, collateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: The account of the vault locking collateral.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: to\sphinxhyphen{}be\sphinxhyphen{}locked collateral.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DepositCollateral(vaultId, newCollateral, totalCollateral, freeCollateral)}}: emit an event stating how much new (\sphinxcode{\sphinxupquote{newCollateral}}), total collateral (\sphinxcode{\sphinxupquote{totalCollateral}}) and freely available collateral (\sphinxcode{\sphinxupquote{freeCollateral}}) the vault calling this function has locked.

\end{itemize}


\subsubsection{Precondition}
\label{\detokenize{spec/vault-registry:precondition}}\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxcode{\sphinxupquote{vaultId}}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
The vault MUST have sufficient unlocked collateral to lock.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{backingCollateral}} is increased by the amount \sphinxcode{\sphinxupquote{collateral}}.

\end{itemize}


\subsection{withdrawCollateral}
\label{\detokenize{spec/vault-registry:withdrawcollateral}}\label{\detokenize{spec/vault-registry:id11}}
A vault can withdraw its \sphinxstyleemphasis{free} collateral at any time, as long as the collateralization ratio remains above the \sphinxcode{\sphinxupquote{SecureCollateralThreshold}}. Collateral that is currently being used to back issued interbtc remains locked until the vault is used for a redeem request (full release can take multiple redeem requests).


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id12}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{withdrawCollateral(vaultId, withdrawAmount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: The account of the vault withdrawing collateral.

\item {} 
\sphinxcode{\sphinxupquote{withdrawAmount}}: To\sphinxhyphen{}be\sphinxhyphen{}withdrawn collateral.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{WithdrawCollateral(vaultId, withdrawAmount, totalCollateral)}}: emit emit an event stating how much collateral was withdrawn by the vault and total collateral a vault has left.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The function call MUST be signed by \sphinxcode{\sphinxupquote{vaultId}}.

\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
The collatalization rate of the vault MUST remain above \sphinxcode{\sphinxupquote{SecureCollateralThreshold}} after the withdrawal of \sphinxcode{\sphinxupquote{withdrawAmount}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
* An amount of \sphinxcode{\sphinxupquote{withdrawAmount}} is unlocked.


\section{Functions called from other pallets}
\label{\detokenize{spec/vault-registry:functions-called-from-other-pallets}}

\subsection{tryIncreaseToBeIssuedTokens}
\label{\detokenize{spec/vault-registry:tryincreasetobeissuedtokens}}\label{\detokenize{spec/vault-registry:id13}}
During an issue request function ({\hyperref[\detokenize{spec/issue:requestissue}]{\sphinxcrossref{\DUrole{std,std-ref}{requestIssue}}}}), a user must be able to assign a vault to the issue request. As a vault can be assigned to multiple issue requests, race conditions may occur. To prevent race conditions, a Vault’s collateral is \sphinxstyleemphasis{reserved} when an \sphinxcode{\sphinxupquote{IssueRequest}} is created \sphinxhyphen{} \sphinxcode{\sphinxupquote{toBeIssuedTokens}} specifies how much interbtc is to be issued (and the reserved collateral is then calculated based on {\hyperref[\detokenize{spec/oracle:getexchangerate}]{\sphinxcrossref{\DUrole{std,std-ref}{getExchangeRate}}}}).


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id14}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{tryIncreaseToBeIssuedTokens(vaultId, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc to be locked.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{IncreaseToBeIssuedTokens(vaultId, tokens)}}

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST be set to \sphinxcode{\sphinxupquote{RUNNING:0}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
The vault MUST have sufficient collateral to remain above the \sphinxcode{\sphinxupquote{SecureCollateralThreshold}} after issuing \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
The vault status MUST be \sphinxtitleref{Active(true)}

\item {} 
The vault MUST NOT be banned

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is increased by an amount of  \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}


\subsection{decreaseToBeIssuedTokens}
\label{\detokenize{spec/vault-registry:decreasetobeissuedtokens}}\label{\detokenize{spec/vault-registry:id15}}
A Vault’s committed tokens are unreserved when an issue request ({\hyperref[\detokenize{spec/issue:cancelissue}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelIssue}}}}) is cancelled due to a timeout (failure!). If the vault has been liquidated, the tokens are instead unreserved on the liquidation vault.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id16}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{decreaseToBeIssuedTokens(vaultId, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc to be unreserved.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DecreaseToBeIssuedTokens(vaultId, tokens)}}

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
If the vault is not liquidated, it MUST have at least \sphinxcode{\sphinxupquote{tokens}} \sphinxcode{\sphinxupquote{toBeIssuedTokens}}.

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, it MUST have at least \sphinxcode{\sphinxupquote{tokens}} \sphinxcode{\sphinxupquote{toBeIssuedTokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
If the vault is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is decreased by an amount of \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, the liquidation vault’s \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is decreased by an amount of \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}


\subsection{issueTokens}
\label{\detokenize{spec/vault-registry:issuetokens}}\label{\detokenize{spec/vault-registry:id17}}
The issue process completes when a user calls the {\hyperref[\detokenize{spec/issue:executeissue}]{\sphinxcrossref{\DUrole{std,std-ref}{executeIssue}}}} function and provides a valid proof for sending BTC to the vault. At this point, the \sphinxcode{\sphinxupquote{toBeIssuedTokens}} assigned to a vault are decreased and the \sphinxcode{\sphinxupquote{issuedTokens}} balance is increased by the \sphinxcode{\sphinxupquote{amount}} of issued tokens.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id18}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{issueTokens(vaultId, amount)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc that were just issued.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{IssueTokens(vaultId, tokens)}}: Emit an event when an issue request is executed.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
If the vault is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeIssuedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, the \sphinxcode{\sphinxupquote{toBeIssuedTokens}} of the liquidation vault MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
If the vault is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}, while its \sphinxcode{\sphinxupquote{issuedTokens}} is increased by \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, the \sphinxcode{\sphinxupquote{toBeIssuedTokens}} of the liquidation vault is decreased by \sphinxcode{\sphinxupquote{tokens}}, while its \sphinxcode{\sphinxupquote{issuedTokens}} is increased by \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}


\subsection{tryIncreaseToBeRedeemedTokens}
\label{\detokenize{spec/vault-registry:tryincreasetoberedeemedtokens}}\label{\detokenize{spec/vault-registry:id19}}
Add an amount of tokens to the \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} balance of a vault. This function serves as a prevention against race conditions in the redeem and replace procedures.
If, for example, a vault would receive two redeem requests at the same time that have a higher amount of tokens to be issued than his \sphinxcode{\sphinxupquote{issuedTokens}} balance, one of the two redeem requests should be rejected.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id20}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{tryIncreaseToBeRedeemedTokens(vaultId, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc to be redeemed.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{IncreaseToBeRedeemedTokens(vaultId, tokens)}}: Emit an event when a redeem request is requested.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
The vault MUST NOT be liquidated.

\item {} 
The vault MUST have sufficient tokens to reserve, i.e. \sphinxcode{\sphinxupquote{tokens}} must be less than or equal to \sphinxcode{\sphinxupquote{issuedTokens \sphinxhyphen{} toBeRedeemedTokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} is increased by \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}


\subsection{decreaseToBeRedeemedTokens}
\label{\detokenize{spec/vault-registry:decreasetoberedeemedtokens}}\label{\detokenize{spec/vault-registry:id21}}
Subtract an amount tokens from the \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} balance of a vault. This function is called from {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}}.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id22}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{decreaseToBeRedeemedTokens(vaultId, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc not to be redeemed.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DecreaseToBeRedeemedTokens(vaultId, tokens)}}: Emit an event when a redeem request is cancelled.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must not be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
If the vault is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, the \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} of the liquidation vault MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
If the vault is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, the \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} of the liquidation vault is decreased by \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}


\subsection{decreaseTokens}
\label{\detokenize{spec/vault-registry:decreasetokens}}\label{\detokenize{spec/vault-registry:id23}}
Decreases both the \sphinxcode{\sphinxupquote{toBeRedeemed}} and \sphinxcode{\sphinxupquote{issued}} tokens, effectively burning the tokens. This is called from {\hyperref[\detokenize{spec/redeem:cancelredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{cancelRedeem}}}}.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id24}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{decreaseTokens(vaultId, user, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{userId}}: The BTC Parachain address of the user that made the redeem request.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc that were not redeemed.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DecreaseTokens(vaultId, userId, tokens)}}: Emit an event if a redeem request cannot be fulfilled.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component must not be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
If the vault is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and \sphinxcode{\sphinxupquote{issuedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, the \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and \sphinxcode{\sphinxupquote{issuedTokens}} of the liquidation vault MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
If the vault is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and \sphinxcode{\sphinxupquote{issuedTokens}} are decreased by \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, the \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and \sphinxcode{\sphinxupquote{issuedTokens}} of the liquidation vault are decreased by \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}


\subsection{redeemTokens}
\label{\detokenize{spec/vault-registry:redeemtokens}}\label{\detokenize{spec/vault-registry:id25}}
Reduces the to\sphinxhyphen{}be\sphinxhyphen{}redeemed tokens when a redeem request completes


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id26}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{redeemTokens(vaultId, tokens, premium, redeemerId)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: the id of the vault from which to redeem tokens

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: the amount of tokens to be decreased

\item {} 
\sphinxcode{\sphinxupquote{premium}}: amount of collateral to be rewarded to the redeemer if the vault is not liquidated yet

\item {} 
\sphinxcode{\sphinxupquote{redeemerId}}: the id of the redeemer

\end{itemize}

\sphinxstyleemphasis{Events}

One of:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RedeemTokens(vault, tokens)}}: Emit an event when a redeem request successfully completes.

\item {} 
\sphinxcode{\sphinxupquote{RedeemTokensPremium(vaultId, tokens, premium, redeemerId)}}: Emit an event when a redeem event with a non\sphinxhyphen{}zero premium completes.

\item {} 
\sphinxcode{\sphinxupquote{RedeemTokensLiquidatedVault(vaultId, tokens, amount)}}: Emit an event when a redeem is executed on a liquidated vault.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} \begin{description}
\item[{If the vault is \sphinxstyleemphasis{not} liquidated:}] \leavevmode\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} must be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{premium \textgreater{} 0}}, then the vault’s \sphinxcode{\sphinxupquote{backingCollateral}} must be greater than or equal to \sphinxcode{\sphinxupquote{premium}}.

\end{itemize}

\end{description}

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, then the liquidation vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} must be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} \begin{description}
\item[{If the vault is \sphinxstyleemphasis{not} liquidated:}] \leavevmode\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}, and its \sphinxcode{\sphinxupquote{issuedTokens}} is increased by the same amount.

\item {} 
If \sphinxcode{\sphinxupquote{premium = 0}}, then the \sphinxcode{\sphinxupquote{RedeemTokens}} event is emitted

\item {} 
If \sphinxcode{\sphinxupquote{premium \textgreater{} 0}}, then \sphinxcode{\sphinxupquote{premium}} is transferred from the vault’s collateral to the redeemer. The \sphinxcode{\sphinxupquote{RedeemTokensPremium}} event is emitted.

\end{itemize}

\end{description}

\item {} 
If the vault \sphinxstyleemphasis{is} liquidated, then the liquidation vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}, and its \sphinxcode{\sphinxupquote{issuedTokens}} is increased by the same amount. The \sphinxcode{\sphinxupquote{RedeemTokensLiquidatedVault}} event is emitted.

\end{itemize}


\subsection{redeemTokensLiquidation}
\label{\detokenize{spec/vault-registry:redeemtokensliquidation}}\label{\detokenize{spec/vault-registry:id27}}
Handles redeem requests which are executed against the LiquidationVault. Reduces the issued token of the LiquidationVault and slashes the
corresponding amount of collateral.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id28}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{redeemTokensLiquidation(redeemerId, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemerId}} : The account of the user redeeming interbtc.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc to be burned, in exchange for collateral.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{RedeemTokensLiquidation(redeemerId, tokens, reward)}}: Emit an event when a liquidation redeem is executed.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
The liquidation vault MUST have sufficient tokens, i.e. \sphinxcode{\sphinxupquote{tokens}} MUST be less than or equal to its \sphinxcode{\sphinxupquote{issuedTokens \sphinxhyphen{} toBeRedeemedTokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The liquidation vault’s \sphinxcode{\sphinxupquote{issuedTokens}} is reduced by \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
The redeemer has received an amount of collateral equal to \sphinxcode{\sphinxupquote{(tokens / liquidationVault.issuedTokens) * liquidationVault.backingCollateral}}.

\end{itemize}


\subsection{tryIncreaseToBeReplacedTokens}
\label{\detokenize{spec/vault-registry:tryincreasetobereplacedtokens}}\label{\detokenize{spec/vault-registry:id29}}
Increases the toBeReplaced tokens of a vault, which indicates how many tokens other vaults can replace in total.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id30}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{tryIncreaseToBeReplacedTokens(oldVault, tokens, collateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: Account identifier of the vault to be replaced.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc replaced.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: The extra collateral provided by the new vault as griefing collateral for potential accepted replaces.

\end{itemize}

\sphinxstyleemphasis{Returns}
\begin{itemize}
\item {} 
A tupple of the new total \sphinxcode{\sphinxupquote{toBeReplacedTokens}} and \sphinxcode{\sphinxupquote{replaceCollateral}}.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{IncreaseToBeReplacedTokens(vaultId, tokens)}}: Emit an event when a replacement is requested for additional tokens.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\item {} 
The vault MUST NOT be liquidated.

\item {} 
The vault’s increased \sphinxcode{\sphinxupquote{toBeReplaceedTokens}} MUST NOT exceed \sphinxcode{\sphinxupquote{issuedTokens \sphinxhyphen{} toBeRedeemedTokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeReplaceTokens}} is increased by \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
The vault’s \sphinxcode{\sphinxupquote{replaceCollateral}} is increased by \sphinxcode{\sphinxupquote{collateral}}.

\end{itemize}


\subsection{decreaseToBeReplacedTokens}
\label{\detokenize{spec/vault-registry:decreasetobereplacedtokens}}\label{\detokenize{spec/vault-registry:id31}}
Decreases the toBeReplaced tokens of a vault, which indicates how many tokens other vaults can replace in total.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id32}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{decreaseToBeReplacedTokens(oldVault, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: Account identifier of the vault to be replaced.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc replaced.

\end{itemize}

\sphinxstyleemphasis{Returns}
\begin{itemize}
\item {} 
A tupple of the new total \sphinxcode{\sphinxupquote{toBeReplacedTokens}} and \sphinxcode{\sphinxupquote{replaceCollateral}}.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{vaultId}} MUST be registered.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The vault’s \sphinxcode{\sphinxupquote{replaceCollateral}} is decreased by \sphinxcode{\sphinxupquote{(min(tokens, toBeReplacedTokens) / toBeReplacedTokens) * replaceCollateral}}.

\item {} 
The vault’s \sphinxcode{\sphinxupquote{toBeReplaceTokens}} is decreased by \sphinxcode{\sphinxupquote{min(tokens, toBeReplacedTokens)}}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
the \sphinxcode{\sphinxupquote{replaceCollateral}} is not actually unlocked \sphinxhyphen{} this is the responsibility of the caller. It is implemented this way, because in {\hyperref[\detokenize{spec/redeem:requestredeem}]{\sphinxcrossref{\DUrole{std,std-ref}{requestRedeem}}}} it needs to be unlocked, whereas in {\hyperref[\detokenize{spec/replace:requestreplace}]{\sphinxcrossref{\DUrole{std,std-ref}{requestReplace}}}} it must remain locked.
\end{sphinxadmonition}


\subsection{replaceTokens}
\label{\detokenize{spec/vault-registry:replacetokens}}\label{\detokenize{spec/vault-registry:id33}}
When a replace request successfully completes, the \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and the \sphinxcode{\sphinxupquote{issuedToken}} balance must be reduced to reflect that removal of interbtc from the \sphinxcode{\sphinxupquote{oldVault}}.Consequently, the \sphinxcode{\sphinxupquote{issuedTokens}} of the \sphinxcode{\sphinxupquote{newVault}} need to be increased by the same amount.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id34}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{replaceTokens(oldVault, newVault, tokens, collateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault to be replaced.

\item {} 
\sphinxcode{\sphinxupquote{newVault}}: Account identifier of the vault accepting the replace request.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc replaced.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: The collateral provided by the new vault.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ReplaceTokens(oldVault, newVault, tokens, collateral)}}: Emit an event when a replace requests is successfully executed.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{oldVault}} MUST be registered.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{newVault}} MUST be registered.

\item {} 
If \sphinxcode{\sphinxupquote{oldVault}} is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and \sphinxcode{\sphinxupquote{issuedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{oldVault}} \sphinxstyleemphasis{is} liquidated, the liquidation vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and \sphinxcode{\sphinxupquote{issuedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{newVault}} is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeIssuedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{newVault}} \sphinxstyleemphasis{is} liquidated, the liquidation vault’s \sphinxcode{\sphinxupquote{toBeIssuedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} \begin{description}
\item[{If \sphinxcode{\sphinxupquote{oldVault}} is \sphinxstyleemphasis{not} liquidated:}] \leavevmode\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{oldVault}}’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and \sphinxcode{\sphinxupquote{issuedTokens}} are decreased by the amount \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
Some of the \sphinxcode{\sphinxupquote{oldVault\textquotesingle{}s}} collateral is unlocked: an amount of \sphinxcode{\sphinxupquote{tokens / toBeRedeemed}}.

\end{itemize}

\end{description}

\item {} 
If \sphinxcode{\sphinxupquote{oldVault}} \sphinxstyleemphasis{is} liquidated, the liquidation vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} and \sphinxcode{\sphinxupquote{issuedTokens}} are decrease by the amount \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{newVault}} is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}, while its \sphinxcode{\sphinxupquote{issuedTokens}} is increased by the same amount.

\item {} 
If \sphinxcode{\sphinxupquote{newVault}} \sphinxstyleemphasis{is} liquidated, the liquidation vault’s  \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}, while its \sphinxcode{\sphinxupquote{issuedTokens}} is increased by the same amount.

\end{itemize}


\subsection{cancelReplaceTokens}
\label{\detokenize{spec/vault-registry:cancelreplacetokens}}\label{\detokenize{spec/vault-registry:id35}}
Cancels a replace: decrease the old\sphinxhyphen{}vault’s to\sphinxhyphen{}be\sphinxhyphen{}redeemed tokens, and the new\sphinxhyphen{}vault’s to\sphinxhyphen{}be\sphinxhyphen{}issued tokens. If one or both of the vaults has been liquidated, the change is forwarded to the liquidation vault.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id36}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{cancelReplaceTokens(oldVault, newVault, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault to be replaced.

\item {} 
\sphinxcode{\sphinxupquote{newVault}}: Account identifier of the vault accepting the replace request.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc replaced.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CancelReplaceTokens(oldVault, newVault, tokens, collateral)}}: Emit an event when a replace requests is cancelled.

\end{itemize}

\sphinxstyleemphasis{Preconditions}
\begin{itemize}
\item {} 
The BTC Parachain status in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} component MUST NOT be set to \sphinxcode{\sphinxupquote{SHUTDOWN: 2}}.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{oldVault}} MUST be registered.

\item {} 
A vault with id \sphinxcode{\sphinxupquote{newVault}} MUST be registered.

\item {} 
If \sphinxcode{\sphinxupquote{oldVault}} is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{oldVault}} \sphinxstyleemphasis{is} liquidated, the liquidation vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{newVault}} is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeIssuedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{newVault}} \sphinxstyleemphasis{is} liquidated, the liquidation vault’s \sphinxcode{\sphinxupquote{toBeIssuedTokens}} MUST be greater than or equal to \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
If \sphinxcode{\sphinxupquote{oldVault}} is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{oldVault}} \sphinxstyleemphasis{is} liquidated, the liquidation vault’s \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{newVault}} is \sphinxstyleemphasis{not} liquidated, its \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}.

\item {} 
If \sphinxcode{\sphinxupquote{newVault}} \sphinxstyleemphasis{is} liquidated, the liquidation vault’s  \sphinxcode{\sphinxupquote{toBeIssuedTokens}} is decreased by \sphinxcode{\sphinxupquote{tokens}}.

\end{itemize}


\subsection{liquidateVault}
\label{\detokenize{spec/vault-registry:liquidatevault}}\label{\detokenize{spec/vault-registry:id37}}
Liquidates a vault, transferring token balances to the \sphinxcode{\sphinxupquote{LiquidationVault}}, as well as collateral.


\subsubsection{Specification}
\label{\detokenize{spec/vault-registry:id38}}
\sphinxstyleemphasis{Function Signature}

\sphinxcode{\sphinxupquote{liquidateVault(vault)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: Account identifier of the vault to be liquidated.

\end{itemize}

\sphinxstyleemphasis{Events}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{LiquidateVault(vault)}}: Emit an event indicating that the vault with \sphinxcode{\sphinxupquote{vault}} account identifier has been liquidated.

\end{itemize}

\sphinxstyleemphasis{Preconditions}

\sphinxstyleemphasis{Postconditions}
\begin{itemize}
\item {} 
The liquidation vault’s \sphinxcode{\sphinxupquote{issuedTokens}}, \sphinxcode{\sphinxupquote{toBeIssuedTokens}} and \sphinxcode{\sphinxupquote{toBeRedeemedTokens}} are increased by the respective amounts in the vault.

\item {} 
The vault’s \sphinxcode{\sphinxupquote{issuedTokens}} and \sphinxcode{\sphinxupquote{toBeIssuedTokens}} are set to 0.

\item {} 
Collateral is moved from the vault to the liquidation vault: an amount of \sphinxcode{\sphinxupquote{confiscatedCollateral \sphinxhyphen{} confiscatedCollateral * (toBeRedeemedTokens / (toBeIssuedTokens + issuedTokens))}} is moved, where \sphinxcode{\sphinxupquote{confiscatedCollateral}} is the minimum of the \sphinxcode{\sphinxupquote{backingCollateral}} and \sphinxcode{\sphinxupquote{SecureCollateralThreshold}} times the equivalent worth of the amount of tokens it is backing.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
If a vault successfully executes a replace after having been liquidated, it receives some of its confiscated collateral back.
\end{sphinxadmonition}


\section{Events}
\label{\detokenize{spec/vault-registry:events}}

\subsection{RegisterVault}
\label{\detokenize{spec/vault-registry:id39}}
Emit an event stating that a new vault (\sphinxcode{\sphinxupquote{vault}}) was registered and provide information on the Vault’s collateral (\sphinxcode{\sphinxupquote{collateral}}).

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RegisterVault(vault, collateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The account of the vault to be registered.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: to\sphinxhyphen{}be\sphinxhyphen{}locked collateral in DOT.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:registervault}]{\sphinxcrossref{\DUrole{std,std-ref}{registerVault}}}}

\end{itemize}


\subsection{DepositCollateral}
\label{\detokenize{spec/vault-registry:event-depositcollateral}}\label{\detokenize{spec/vault-registry:id40}}
Emit an event stating how much new (\sphinxcode{\sphinxupquote{newCollateral}}), total collateral (\sphinxcode{\sphinxupquote{totalCollateral}}) and freely available collateral (\sphinxcode{\sphinxupquote{freeCollateral}}) the vault calling this function has locked.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{DepositCollateral(Vault, newCollateral, totalCollateral, freeCollateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Vault}}: The account of the vault locking collateral.

\item {} 
\sphinxcode{\sphinxupquote{newCollateral}}: to\sphinxhyphen{}be\sphinxhyphen{}locked collateral in DOT.

\item {} 
\sphinxcode{\sphinxupquote{totalCollateral}}: total collateral in DOT.

\item {} 
\sphinxcode{\sphinxupquote{freeCollateral}}: collateral not “occupied” with interbtc in DOT.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:depositcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{depositCollateral}}}}

\end{itemize}


\subsection{WithdrawCollateral}
\label{\detokenize{spec/vault-registry:id41}}
Emit emit an event stating how much collateral was withdrawn by the vault and total collateral a vault has left.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{WithdrawCollateral(Vault, withdrawAmount, totalCollateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Vault}}: The account of the vault locking collateral.

\item {} 
\sphinxcode{\sphinxupquote{withdrawAmount}}: To\sphinxhyphen{}be\sphinxhyphen{}withdrawn collateral in DOT.

\item {} 
\sphinxcode{\sphinxupquote{totalCollateral}}: total collateral in DOT.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:withdrawcollateral}]{\sphinxcrossref{\DUrole{std,std-ref}{withdrawCollateral}}}}

\end{itemize}


\subsection{RegisterAddress}
\label{\detokenize{spec/vault-registry:id42}}
Emit an event stating that a vault (\sphinxcode{\sphinxupquote{vault}}) registered a new address (\sphinxcode{\sphinxupquote{address}}).

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RegisterAddress(vault, address)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The account of the vault to be registered.

\item {} 
\sphinxcode{\sphinxupquote{address}}: The added address

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:registeraddress}]{\sphinxcrossref{\DUrole{std,std-ref}{registerAddress}}}}

\end{itemize}


\subsection{UpdatePublicKey}
\label{\detokenize{spec/vault-registry:id43}}
Emit an event stating that a vault (\sphinxcode{\sphinxupquote{vault}}) registered a new address (\sphinxcode{\sphinxupquote{address}}).

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{UpdatePublicKey(vaultId, publicKey)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vaultId}}: the account of the vault.

\item {} 
\sphinxcode{\sphinxupquote{publicKey}}: the new BTC public key of the vault.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:updatepublickey}]{\sphinxcrossref{\DUrole{std,std-ref}{updatePublicKey}}}}

\end{itemize}


\subsection{IncreaseToBeIssuedTokens}
\label{\detokenize{spec/vault-registry:increasetobeissuedtokens}}
Emit

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{IncreaseToBeIssuedTokens(vaultId, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc to be locked.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:tryincreasetobeissuedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{tryIncreaseToBeIssuedTokens}}}}

\end{itemize}


\subsection{DecreaseToBeIssuedTokens}
\label{\detokenize{spec/vault-registry:id44}}
Emit

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{DecreaseToBeIssuedTokens(vaultId, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc to be unreserved.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:decreasetobeissuedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{decreaseToBeIssuedTokens}}}}

\end{itemize}


\subsection{IssueTokens}
\label{\detokenize{spec/vault-registry:id45}}
Emit an event when an issue request is executed.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{IssueTokens(vault, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc that were just issued.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:issuetokens}]{\sphinxcrossref{\DUrole{std,std-ref}{issueTokens}}}}

\end{itemize}


\subsection{IncreaseToBeRedeemedTokens}
\label{\detokenize{spec/vault-registry:increasetoberedeemedtokens}}
Emit an event when a redeem request is requested.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{IncreaseToBeRedeemedTokens(vault, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc to be redeemed.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:tryincreasetoberedeemedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{tryIncreaseToBeRedeemedTokens}}}}

\end{itemize}


\subsection{DecreaseToBeRedeemedTokens}
\label{\detokenize{spec/vault-registry:id46}}
Emit an event when a replace request cannot be completed because the vault has too little tokens committed.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{DecreaseToBeRedeemedTokens(vault, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc not to be replaced.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:decreasetoberedeemedtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{decreaseToBeRedeemedTokens}}}}

\end{itemize}


\subsection{DecreaseTokens}
\label{\detokenize{spec/vault-registry:id47}}
Emit an event if a redeem request cannot be fulfilled.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{DecreaseTokens(vault, user, tokens, collateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{user}}: The BTC Parachain address of the user that made the redeem request.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc that were not redeemed.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: The amount of collateral assigned to this request.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:decreasetokens}]{\sphinxcrossref{\DUrole{std,std-ref}{decreaseTokens}}}}

\end{itemize}


\subsection{RedeemTokens}
\label{\detokenize{spec/vault-registry:id48}}
Emit an event when a redeem request successfully completes.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RedeemTokens(vault, tokens)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc redeemed.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:redeemtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{redeemTokens}}}}

\end{itemize}


\subsection{RedeemTokensPremium}
\label{\detokenize{spec/vault-registry:redeemtokenspremium}}
Emit an event when a user is executing a redeem request that includes a premium.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RedeemTokensPremium(vault, tokens, premiumDOT, redeemer)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: The BTC Parachain address of the Vault.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc redeemed.

\item {} 
\sphinxcode{\sphinxupquote{premiumDOT}}: The amount of DOT to be paid to the user as a premium using the Vault’s released collateral.

\item {} 
\sphinxcode{\sphinxupquote{redeemer}}: The user that redeems at a premium.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:redeemtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{redeemTokens}}}}

\end{itemize}


\subsection{RedeemTokensLiquidation}
\label{\detokenize{spec/vault-registry:id49}}
Emit an event when a redeem is executed under the \sphinxcode{\sphinxupquote{LIQUIDATION}} status.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RedeemTokensLiquidation(redeemer, redeemDOTinBTC)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}} : The account of the user redeeming interbtc.

\item {} 
\sphinxcode{\sphinxupquote{redeemDOTinBTC}}: The amount of interbtc to be redeemed in DOT with the \sphinxcode{\sphinxupquote{LiquidationVault}}, denominated in BTC.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:redeemtokensliquidation}]{\sphinxcrossref{\DUrole{std,std-ref}{redeemTokensLiquidation}}}}

\end{itemize}


\subsection{RedeemTokensLiquidatedVault}
\label{\detokenize{spec/vault-registry:redeemtokensliquidatedvault}}
Emit an event when a redeem is executed on a liquidated vault.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{RedeemTokensLiquidation(redeemer, tokens, unlockedCollateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{redeemer}} : The account of the user redeeming interbtc.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc that have been refeemed.

\item {} 
\sphinxcode{\sphinxupquote{unlockedCollateral}}: The amount of collateral that has been unlocked for the vault for this redeem.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:redeemtokens}]{\sphinxcrossref{\DUrole{std,std-ref}{redeemTokens}}}}

\end{itemize}


\subsection{ReplaceTokens}
\label{\detokenize{spec/vault-registry:id50}}
Emit an event when a replace requests is successfully executed.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{ReplaceTokens(oldVault, newVault, tokens, collateral)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVault}}: Account identifier of the vault to be replaced.

\item {} 
\sphinxcode{\sphinxupquote{newVault}}: Account identifier of the vault accepting the replace request.

\item {} 
\sphinxcode{\sphinxupquote{tokens}}: The amount of interbtc replaced.

\item {} 
\sphinxcode{\sphinxupquote{collateral}}: The collateral provided by the new vault.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:replacetokens}]{\sphinxcrossref{\DUrole{std,std-ref}{replaceTokens}}}}

\end{itemize}


\subsection{LiquidateVault}
\label{\detokenize{spec/vault-registry:id51}}
Emit an event indicating that the vault with \sphinxcode{\sphinxupquote{vault}} account identifier has been liquidated.

\sphinxstyleemphasis{Event Signature}

\sphinxcode{\sphinxupquote{LiquidateVault(vault)}}

\sphinxstyleemphasis{Parameters}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{vault}}: Account identifier of the vault to be liquidated.

\end{itemize}

\sphinxstyleemphasis{Functions}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/vault-registry:liquidatevault}]{\sphinxcrossref{\DUrole{std,std-ref}{liquidateVault}}}}

\end{itemize}


\section{Error Codes}
\label{\detokenize{spec/vault-registry:error-codes}}
\sphinxcode{\sphinxupquote{InsufficientVaultCollateralAmount}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The provided collateral was insufficient \sphinxhyphen{} it must be above \sphinxcode{\sphinxupquote{MinimumCollateralVault}}.”

\item {} 
\sphinxstylestrong{Cause}: The vault provided too little collateral, i.e. below the MinimumCollateralVault limit.

\end{itemize}

\sphinxcode{\sphinxupquote{VaultNotFound}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The specified vault does not exist.”

\item {} 
\sphinxstylestrong{Cause}: vault could not be found in \sphinxcode{\sphinxupquote{Vaults}} mapping.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_FREE\_COLLATERAL}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Not enough free collateral available.”

\item {} 
\sphinxstylestrong{Cause}: The vault is trying to withdraw more collateral than is currently free.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_EXCEEDING\_VAULT\_LIMIT}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Issue request exceeds vault collateral limit.”

\item {} 
\sphinxstylestrong{Cause}: The collateral provided by the vault combined with the exchange rate forms an upper limit on how much interbtc can be issued. The requested amount exceeds this limit.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_INSUFFICIENT\_TOKENS\_COMMITTED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “The requested amount of \sphinxcode{\sphinxupquote{tokens}} exceeds the amount available to vault.”

\item {} 
\sphinxstylestrong{Cause}: A user requests a redeem with an amount exceeding the vault’s tokens, or the vault is requesting replacement for more tokens than it has available.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VAULT\_BANNED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Action not allowed on banned vault.”

\item {} 
\sphinxstylestrong{Cause}: An illegal operation is attempted on a banned vault, e.g. an issue or redeem request.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_ALREADY\_REGISTERED}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “A vault with the given accountId is already registered.”

\item {} 
\sphinxstylestrong{Cause}: A vault tries to register a vault that is already registered.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_RESERVED\_DEPOSIT\_ADDRESS}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Deposit address is already registered.”

\item {} 
\sphinxstylestrong{Cause}: A vault tries to register a deposit address that is already in the system.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_VAULT\_NOT\_BELOW\_LIQUIDATION\_THRESHOLD}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Attempted to liquidate a vault that is not undercollateralized.”

\item {} 
\sphinxstylestrong{Cause}: A vault has been reported for being undercollateralized, but at the moment of execution, it is no longer undercollateralized.

\end{itemize}

\sphinxcode{\sphinxupquote{ERR\_INVALID\_PUBLIC\_KEY}}
\begin{itemize}
\item {} 
\sphinxstylestrong{Message}: “Deposit address could not be generated with the given public key.”

\item {} 
\sphinxstylestrong{Cause}: An error occurred while attempting to generate a new deposit address for an issue request.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
These are the errors defined in this pallet. It is possible that functions in this pallet return errors defined in other pallets.
\end{sphinxadmonition}


\chapter{Vault Liquidations}
\label{\detokenize{security_performance/liquidations:vault-liquidations}}\label{\detokenize{security_performance/liquidations:liquidations}}\label{\detokenize{security_performance/liquidations::doc}}
Vaults are collateralized entities in the system responsible for keeping BTC in custody.
If Vaults fail to behave according to protocol rules, they face punishment through slashing of collateral. There are two types of failures: \sphinxstylestrong{safety failures} and \sphinxstylestrong{crash failures}.


\section{Safety Failures}
\label{\detokenize{security_performance/liquidations:safety-failures}}
A safety failure occurs in two cases:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstylestrong{Theft}: a Vault is considered to have committed theft if it moves/spends BTC unauthorized by the interbtc bridge. Theft is detected and reported by Relayers via an SPV proof.

\item {} 
\sphinxstylestrong{Severe Undercollteralization}: a Vaults drops below the \sphinxcode{\sphinxupquote{110\%}} liquidation collateral threshold.

\end{enumerate}

In both cases, the Vault’s entire BTC holdings are liquidated and its DOT collateral is slashed \sphinxhyphen{} up to 150\% (secure collateral threshold) of the liquidated BTC value.

Consequently, the bridge offers users to burn (“Burn Event”) their tokens to restore the 1:1 balance between the issued (e.g., interbtc) and locked asset (e.g., BTC).


\section{Crash Failures}
\label{\detokenize{security_performance/liquidations:crash-failures}}
If Vaults go offline and fail to execute redeem, they are:
\begin{itemize}
\item {} 
\sphinxstylestrong{Penalized} (punishment fee slashed) and

\item {} 
\sphinxstylestrong{Temporarily banned for 24 hours} from accepting further issue, redeem, and replace requests.

\end{itemize}

The punishment fee is calculated based on the Vault’s SLA (Service Level Agreement) level, which is a value between 0 and 100. The higher the Vault’s SLA, the lower the punishment for a failed redeem.

In detail, the punishment fee is calculated as follows:
\begin{itemize}
\item {} 
\sphinxstylestrong{Minimum Punishment Fee}: 10\% of the failed redeem value.

\item {} 
\sphinxstylestrong{Maximum Punishment Fee}: 30\% of the failed redeem value.

\item {} 
\sphinxstylestrong{Punishment Fee}: calculated based on the Vaults SLA value as defined in the {\hyperref[\detokenize{spec/sla:slashamountvault}]{\sphinxcrossref{\DUrole{std,std-ref}{SlashAmountVault}}}}.

\end{itemize}


\section{Liquidations (Safety Failures)}
\label{\detokenize{security_performance/liquidations:liquidations-safety-failures}}
When a Vault is liquidated, its \sphinxcode{\sphinxupquote{issued}} and \sphinxcode{\sphinxupquote{toBeIssued}} tokens are \sphinxstyleemphasis{moved} to the Liquidation Vault.
In contrast, the Vault’s \sphinxcode{\sphinxupquote{toBeRedeemed}} tokens are \sphinxstyleemphasis{copied} over.
The Vault loses access to at least part of its backing collateral:
\begin{itemize}
\item {} 
The Vault loses \sphinxcode{\sphinxupquote{confiscatedCollateral = min(SECURE\_THRESHOLD * (issued + toBeIssued), backingCollateral)}}, and any leftover amount is released to its free balance.

\item {} 
Of the confiscated collateral, an amount of \sphinxcode{\sphinxupquote{confiscatedCollateral * (toBeRedeemed / (issued + toBeIssued))}} stays locked in the Vault, and the rest is moved to the Liquidation Vault. This is in anticipation of vaults being able to complete ongoing redeem and replace requests. When these requests succeed, the liquidated Vault’s collateral is returned. When the requests fail (i.e., the \sphinxcode{\sphinxupquote{cancel}} calls are being made), the remaining collateral is slashed to the Liquidation Vault.

\end{itemize}

When the Liquidation Vault contains tokens, users can do a liquidation\_redeem (“burn event”). Users can call this function to burn interbtc and receive DOT in return.
\begin{itemize}
\item {} 
The user receives \sphinxcode{\sphinxupquote{liquidationVault.collateral * (burnedTokens / (issued + toBeIssued)}} in its free balance.

\item {} 
At most \sphinxcode{\sphinxupquote{liquidationVault.issued \sphinxhyphen{} liquidationVault.toBeRedeemed}} tokens can be burned.

\end{itemize}

Vault liquidation affects Vault interactions is the following ways:
\begin{itemize}
\item {} 
Operations that increase \sphinxcode{\sphinxupquote{toBeIssued}} or \sphinxcode{\sphinxupquote{toBeRedeemed}} are disallowed. This means that no new issue/redeem/replace request can be made.

\item {} 
Any operation that would decrease \sphinxcode{\sphinxupquote{toBeIssued}} or change \sphinxcode{\sphinxupquote{issued}} on a user Vault instead changes it on the Liquidation Vault

\item {} 
Any operation that would decrease \sphinxcode{\sphinxupquote{toBeRedeemed}} tokens on a user Vault \sphinxstyleemphasis{additionally} decreases it on the Liquidation Vault

\end{itemize}


\subsection{Issue}
\label{\detokenize{security_performance/liquidations:issue}}\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{requestIssue}}}] \leavevmode\begin{itemize}
\item {} 
disallowed

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{executeIssue}}}] \leavevmode\begin{itemize}
\item {} 
Overpayment protection is disabled; if a user transfers too many BTC, the user loses it.

\item {} 
SLA of Vault is not increased

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{cancelIssue}}}] \leavevmode\begin{itemize}
\item {} 
User’s griefing collateral is released back to the user, rather than slashed to the Vault.

\end{itemize}

\end{description}

\end{itemize}


\subsection{Redeem}
\label{\detokenize{security_performance/liquidations:redeem}}\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{requestRedeem}}}] \leavevmode\begin{itemize}
\item {} 
disallowed

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{executeRedeem}}}] \leavevmode\begin{itemize}
\item {} 
Part of the Vault’s collateral is released. Amount: \sphinxcode{\sphinxupquote{Vault.backingCollateral * (redeem.amount / Vault.toBeRedeemed)}}, where \sphinxcode{\sphinxupquote{toBeRedeemed}} is read before it is decreased

\item {} 
The premium, if any, is not transferred to the user.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{cancelRedeem}}}] \leavevmode\begin{itemize}
\item {} 
Calculates \sphinxcode{\sphinxupquote{slashedCollateral = Vault.backingCollateral * (redeem.amount / Vault.toBeRedeemed)}},  where \sphinxcode{\sphinxupquote{toBeRedeemed}} is read \sphinxstyleemphasis{before} it is decreased, and then:

\item {} \begin{description}
\item[{If reimburse:}] \leavevmode\begin{itemize}
\item {} 
transfers \sphinxcode{\sphinxupquote{slashedCollateral}} to user.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Else if not reimburse:}] \leavevmode\begin{itemize}
\item {} 
transfers \sphinxcode{\sphinxupquote{slashedCollateral}} to Liquidation Vault.

\end{itemize}

\end{description}

\item {} 
Fee pool does not receive anything.

\end{itemize}

\end{description}

\end{itemize}


\subsection{Replace}
\label{\detokenize{security_performance/liquidations:replace}}\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{requestReplace}}, \sphinxcode{\sphinxupquote{acceptReplace}}, \sphinxcode{\sphinxupquote{withdrawReplace}}}] \leavevmode\begin{itemize}
\item {} 
disallowed

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{executeReplace}}}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{if \sphinxcode{\sphinxupquote{oldVault}} is liquidated}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{oldVVault}}’s collateral is released as in \sphinxcode{\sphinxupquote{executeRedeem}} above

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{if \sphinxcode{\sphinxupquote{newVault}} is liquidated}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{newVault}}’s remaining collateral is slashed as in \sphinxcode{\sphinxupquote{executeIssue}} above

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{cancelReplace}}}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{if \sphinxcode{\sphinxupquote{oldVault}} is liquidated}] \leavevmode\begin{itemize}
\item {} 
collateral is slashed to Liquidation Vault, as in \sphinxcode{\sphinxupquote{cancelRedeem}} above

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{if \sphinxcode{\sphinxupquote{newVault}} is liquidated}] \leavevmode\begin{itemize}
\item {} 
griefing collateral is slashed to \sphinxcode{\sphinxupquote{newVault}}’s free balance rather than to its backing collateral

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\end{itemize}


\subsection{Implementation Notes}
\label{\detokenize{security_performance/liquidations:implementation-notes}}\begin{itemize}
\item {} 
In \sphinxcode{\sphinxupquote{cancelIssue}}, when the griefing collateral is slashed, it is forwarded to the fee pool.

\item {} 
In \sphinxcode{\sphinxupquote{cancelReplace}}, when the griefing collateral is slashed, it is forwarded to the backing collateral to the Vault. In case the Vault is liquidated, it is forwarded to the free balance of the Vault.

\item {} 
In \sphinxcode{\sphinxupquote{premiumRedeem}}, the griefing collateral is set as 0.

\item {} 
In \sphinxcode{\sphinxupquote{executeReplace}}, the \sphinxcode{\sphinxupquote{oldVault}}’s griefing collateral is released, regardless of whether or not it is liquidated.

\end{itemize}


\chapter{Security Analysis}
\label{\detokenize{security_performance/security-analysis:security-analysis}}\label{\detokenize{security_performance/security-analysis:id1}}\label{\detokenize{security_performance/security-analysis::doc}}

\section{Replay Attacks}
\label{\detokenize{security_performance/security-analysis:replay-attacks}}
Without adequate protection, inclusion proofs for transactions on Bitcoin can be \sphinxstylestrong{replayed} by: (i) the user to trick interbtc component into issuing duplicate interbtc tokens and (ii) the vault to reuse a single transaction on Bitcoin to falsely prove multiple redeem, replace, and refund requests.
We employ two different mechanisms to achieve this:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstyleemphasis{Identification via OP\_RETURN}: When sending a Bitcoin transaction, the BTC\sphinxhyphen{}Parachain requires that a unique identifier is included as one of the outputs in the transaction.

\item {} 
\sphinxstyleemphasis{Unique Addresses via On\sphinxhyphen{}Chain Key Derivation}: The BTC\sphinxhyphen{}Parachain generates a new and unique address that Bitcoin can be transferred to.

\end{enumerate}

The details of the transaction format can be found at the \sphinxhref{https://interlay.gitlab.io/interbtc-spec/btcrelay-spec/intro/accepted-format.html}{accepted Bitcoin transaction format}.


\subsection{OP\_RETURN}
\label{\detokenize{security_performance/security-analysis:op-return}}\label{\detokenize{security_performance/security-analysis:id2}}
Applied in the following protocols:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}

\item {} 
{\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}

\item {} 
{\hyperref[\detokenize{spec/refund:refund-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Refund}}}}

\end{itemize}

A simple and practical mitigation is to introduce unique identifiers for each protocol execution and require transactions on Bitcoin submitted to the BTC\sphinxhyphen{}Relay of these protocols to contain the corresponding identifier.

In this specification, we achieve this by requiring that vaults prepare a transaction with at least two outputs. One output is an OP\_RETURN with a unique hash created in the {\hyperref[\detokenize{spec/security:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}} module.
Vaults are using Bitcoin full\sphinxhyphen{}nodes to send transactions and can easily and programmatically create transactions with an OP\_RETURN output.

\sphinxstylestrong{UX Issues with OP\_RETURN}

However, OP\_RETURN has severe UX problems. Most Bitcoin wallets do not support OP\_RETURN. That is, a user cannot use the UI to easily create an OP\_RETURN transaction.
As of this writing, the only wallet that supports this out of the box is Electrum. Other wallets, such as Samurai, exist but only support mainnet transactions (hence, have not yet been tested).

In addition, while Bitcoin’s URI format (\sphinxhref{https://en.bitcoin.it/wiki/BIP\_0021}{BIP21}) generally supports OP\_RETURN, none of the existing wallets have implemented an interpreter for this “upgraded” URI structure \sphinxhyphen{} this would have to be implemented manually by wallet providers.
An alternative solution is to pre\sphinxhyphen{}generate the Bitcoin transaction for the user. The problem with this is that \sphinxhyphen{} again \sphinxhyphen{} most Bitcoin wallets do not support parsing of raw Bitcoin transactions. That is, a user cannot easily verify that the raw Bitcoin transaction string provided by interbtc indeed does what it should do (and does not steal the user’s funds). This approach works with hardware wallets, such as Ledger \sphinxhyphen{} but again, not all users will use interbtc from hardware wallets.


\subsection{Unique Addresses via On\sphinxhyphen{}Chain Key Derivation}
\label{\detokenize{security_performance/security-analysis:unique-addresses-via-on-chain-key-derivation}}
Applied in the following protocol:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}}

\end{itemize}

To avoid the use of OP\_RETURN during the issue process, and the significant usability drawbacks incurred by this approach, we employ the use of an On\sphinxhyphen{}chain Key Derivation scheme (OKD) for Bitcoin’s ECDSA (secp256k1 curve). The BTC\sphinxhyphen{}Parachain maintains a BTC ‘master’ public key for each registered vault and generates a unique, ephemeral ‘deposit’ public key (and RIPEMD\sphinxhyphen{}160 address) for each issue request, utilizing the unique issue identifier for replay protection.

This way, each issue request can be linked to a distinct Bitcoin transaction via the receiving (‘deposit’) address, making it impossible for vaults/users to execute replay attacks. The use of OKD thereby allows to keep the issue process non\sphinxhyphen{}interactive, ensuring vaults cannot censor issue requests.


\subsubsection{On\sphinxhyphen{}Chain Key Derivation Scheme}
\label{\detokenize{security_performance/security-analysis:on-chain-key-derivation-scheme}}\label{\detokenize{security_performance/security-analysis:okd}}
We define the full OKD scheme as follows (additive notation):

\sphinxstylestrong{Preliminaries}

A Vault has a private/public keypair \((v, V)\), where \(V = v·G\) and \(G\) is the base point of the secp256k1 curve.
Upon registration, the Vault submits public key \(V\) to the BTC\sphinxhyphen{}Parachain storage.

\sphinxstylestrong{Issue protocol via new OKD scheme}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} \begin{description}
\item[{When a user creates an issue request, the BTC\sphinxhyphen{}Parachain}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
Computes \(c = H(V || id)\), where id is the unique issue identifier, generated on\sphinxhyphen{}chain by the BTC\sphinxhyphen{}Parachain using the user’s AccountId and an internal auto\sphinxhyphen{}incrementing nonce as input.

\item {} 
Generates a new public key (“deposit public key”) \(D = V·c\) and then the corresponding BTC RIPEMD\sphinxhyphen{}160 hash\sphinxhyphen{}based address \(addr(D)\) (‘deposit’ address) using \(D\) as input.

\item {} 
Stores \(D\) and \(addr(D)\) alongside the id of the Issue request.

\end{enumerate}

\end{description}

\item {} 
The user deposits the amount of to\sphinxhyphen{}be\sphinxhyphen{}issued BTC to \(addr(D)\) and submits the Bitcoin transaction inclusion proof, alongside the raw Bitcoin transaction, to BTC\sphinxhyphen{}Relay.

\item {} 
The BTC\sphinxhyphen{}Relay verifies that the destination address of the Bitcoin transaction is indeed \(addr(D)\) (and the amount, etc.) and mints new interbtc to the user’s AccountId.

\item {} 
The Vault knows that the private key of \(D\) is \(c·v\), where \(c = H(V || id)\) is publicly known (can be computed by the Vault off\sphinxhyphen{}chain, or stored on\sphinxhyphen{}chain for convenience). The Vault can now import the private key \(c·v\) into its Bitcoin wallet to gain access to the deposited BTC (required for redeem).

\end{enumerate}


\section{Counterfeiting}
\label{\detokenize{security_performance/security-analysis:counterfeiting}}
A vault which receives lock transaction from a user during {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}} could use these coins to re\sphinxhyphen{}execute the issue itself, creating counterfeit interbtc.
This would result in interbtc being issued for the same amount of lock transaction breaking \sphinxstylestrong{consistency}, i.e., \(|locked_BTC| < |interbtc|\).
To this end, the interbtc component forbids vaults to move locked funds lock transaction received during {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}} and considers such cases as theft.
This theft is observable by any user.
However, we used the specific roles of Staked Relayers to report theft of BTC.
To restore \sphinxstylestrong{Consistency}, the interbtc component slashes the vault’s entire collateral and executes automatic liquidation, yielding negative utility for the vault.
To allow economically rational vaults to move funds on the BTC Parachain we use the {\hyperref[\detokenize{spec/replace:replace-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Replace}}}}, a non\sphinxhyphen{}interactive atomic cross\sphinxhyphen{}chain swap (ACCS) protocol based on cross\sphinxhyphen{}chain state verification.


\section{Permanent Blockchain Splits}
\label{\detokenize{security_performance/security-analysis:permanent-blockchain-splits}}
Permanent chain splits or \sphinxstyleemphasis{hard forks} occur where consensus rules are loosened or conflicting rules are introduced, resulting in multiple instances of the same blockchain.
Thereby, a mechanism to differentiate between the two resulting chains \sphinxstyleemphasis{replay protection} is necessary for secure operation.


\subsection{Backing Chain}
\label{\detokenize{security_performance/security-analysis:backing-chain}}
If replay protection is provided after a permanent split of Bitcoin, the BTC\sphinxhyphen{}Relay must be updated to verify the latter for Bitcoin (or Bitcoin’ respectively).
If no replay protection is implemented, BTC\sphinxhyphen{}Relay will behave according to the protocol rules of Bitcoin for selecting the “main” chain. For example, it will follow the chain with most accumulated PoW under Nakamoto consensus.


\subsection{Issuing Chain}
\label{\detokenize{security_performance/security-analysis:issuing-chain}}
A permanent fork on the issuing blockchain results in two chains I and I’ with two instances of the interbtc component identified by the same public keys. To prevent an adversary exploiting this to execute replay attacks, both users and vaults must be required to include a unique identifier (or a digest thereof) in the transactions published on Bitcoin as part of {\hyperref[\detokenize{spec/issue:issue-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Issue}}}} and {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}} (in addition to the identifiers introduces in Replay Attacks).

Next, we identify two possibilities to synchronize Bitcoin balances on I and I’: (i) deploy a chain relay for I on I’ and vice\sphinxhyphen{}versa to continuously synchronize the interbtc components or (ii) redeploy the interbtc component on both chains and require users and vaults to re\sphinxhyphen{}issue Bitcoin, explicitly selecting I or I’.


\section{Denial\sphinxhyphen{}of\sphinxhyphen{}Service Attacks}
\label{\detokenize{security_performance/security-analysis:denial-of-service-attacks}}
interbtc is decentralized by design, thus making denial\sphinxhyphen{}of\sphinxhyphen{}service (DoS) attacks difficult. Given that any user with access to Bitcoin and BTC Parachain can become a vault, an adversary would have to target all vaults simultaneously. Where there are a large number of vaults, this attack would be impractical and expensive to perform. Alternatively, an attacker may try to target the interbtc component. However, performing a DoS attack against the interbtc component is equivalent to a DoS attack against the entire issuing blockchain or network, which conflicts with our assumptions of a resource bounded adversary and the security models of Bitcoin and BTC Parachain. Moreover, should an adversary perform a Sybil attack and register as a large number of vaults and ignore service requests to perform a DoS attack, the adversary would be required to lock up a large amount of collateral to be effective. This would lead to the collateral being slashed by the interbtc component, making this attack expensive and irrational.


\section{Fee Model Security: Sybil Attacks and Extortion}
\label{\detokenize{security_performance/security-analysis:fee-model-security-sybil-attacks-and-extortion}}
While the exact design of the fee model lies beyond the scope of this paper, we outline the following two restrictions, necessary to protect against attacks by malicious vaults.


\subsection{Sybil Attacks}
\label{\detokenize{security_performance/security-analysis:sybil-attacks}}
To prevent financial gains from Sybil attacks, where a single adversary creates multiple low collateralized vaults, the interbtc component can enforce (i) a minimum necessary collateral amount and (ii) a fee model based on issued volume, rather than “pay\sphinxhyphen{}per\sphinxhyphen{}issue”.
In practice, users can in principle easily filter out low\sphinxhyphen{}collateral vaults.


\subsection{Extortion}
\label{\detokenize{security_performance/security-analysis:extortion}}
Without adequate restrictions, vaults could set extreme fees for executing {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}}, making redeeming of Bitcoin unfeasible.
To this end, the interbtc component must enforce that either (i) no fees can be charged for executing {\hyperref[\detokenize{spec/redeem:redeem-protocol}]{\sphinxcrossref{\DUrole{std,std-ref}{Redeem}}}} or (ii) fees for redeeming must be pre\sphinxhyphen{}agreed upon during issue.


\section{Griefing}
\label{\detokenize{security_performance/security-analysis:griefing}}\label{\detokenize{security_performance/security-analysis:id3}}
Griefing describes the act of blocking a vaults collateral by creating “bogus” requests. There are two cases:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A user can create an issue request without the intention to issue tokens. The user “blocks” the vault’s collateral for a specific amount of time. if enough users execute this, a legitimate user could possibly not find a vault with free collateral to start an issue request.

\item {} 
A vault can request to be replaced without the intention to be replaced. When another vault accepts the replace request, that vault needs to lock additional collateral. The requesting vault, however, could never complete the replace request to e.g. ensure that it will be able to serve more issue requests.

\end{enumerate}

For both cases, we require the requesting parties to lock up a (small) amount of griefing collateral. This makes such attacks costly for the attacker.


\section{Concurrency}
\label{\detokenize{security_performance/security-analysis:concurrency}}
We need to ensure that concurrrent issue, redeem, and replace requests are handled.


\subsection{Concurrent redeem}
\label{\detokenize{security_performance/security-analysis:concurrent-redeem}}
We need to make sure that a vault cannot be used in multiple redeem requests in parallel if that would exceed his amount of locked BTC. \sphinxstylestrong{Example}: If the vault has 5 BTC locked and receives two redeem requests for 5 interbtc/BTC, he can only fulfil one and would lose his collateral with the other.


\subsection{Concurrent issue and redeem}
\label{\detokenize{security_performance/security-analysis:concurrent-issue-and-redeem}}
A vault can be used in parallel for issue and redeem requests. In the issue procedure, the vault’s \sphinxcode{\sphinxupquote{issuedTokens}} are already increased when the issue request is created. However, this is before (!) the BTC is sent to the vault. If we used these \sphinxcode{\sphinxupquote{issuedTokens}} as a basis for redeem requests, we might end up in a case where the vault does not have enough BTC. \sphinxstylestrong{Example}: The vault already has 3 BTC in custody from previous successful issue procedures. A user creates an issue request for 2 interbtc. At this point, the \sphinxcode{\sphinxupquote{issuedTokens}} by this vault are 5. However, his BTC balance is only 3. Now, a user could create a redeem request of 5 interbtc and the vault would have to fulfill those. The user could then cancel the issue request over 2 interbtc. The vault could only send 3 BTC to the user and would lose his deposit. Or the vault just loses his deposit without sending any BTC.


\subsection{Solution}
\label{\detokenize{security_performance/security-analysis:solution}}
We use seperate token balances to handle issue, replace, and redeem requests in the {\hyperref[\detokenize{spec/vault-registry:vault-registry}]{\sphinxcrossref{\DUrole{std,std-ref}{Vault Registry}}}}.


\chapter{Performance Analysis}
\label{\detokenize{security_performance/performance:performance-analysis}}\label{\detokenize{security_performance/performance:id1}}\label{\detokenize{security_performance/performance::doc}}

\chapter{Economic Incentives}
\label{\detokenize{economics/incentives:economic-incentives}}\label{\detokenize{economics/incentives:incentives}}\label{\detokenize{economics/incentives::doc}}
Incentives are the core of decentralized systems. Fundamentally, actors in decentralized systems participate in a game where each actor attempts to maximize its utility. Designs of such decentralized systems need to encode a mechanism that provides clear incentives for actors to adhere to protocol rules while discouraging undesired behavior. Specifically, actors make risk\sphinxhyphen{}based decisions: payoffs associated with the execution of certain actions are compared against the risk incurred by the action. The BTC Parachain, being an open system with multiple distinct stakeholders, must hence offer a mechanism to assure honest participation outweighs subversive strategies.

The overall objective of the incentive mechanism is an optimization problem with private information in a dynamic setting. Users need to pay fees to Vaults in return for their service. On the one hand, user fees should be low enough to allow them to profit from having interbtc (e.g., if a user stands to gain from earning interest in a stablecoin system using interbtc, then the fee for issuing interbtc should not outweigh the interest gain). On the other hand, fees need to be high enough to encourage Vaults and Staked Relayers to lock their DOT in the system and operate Vault/Staked Relayer clients. This problem is amplified as the BTC Parachain does not exist in isolation and Vaults/Staked Relayers can choose to participate in other protocols (e.g., staking, stablecoin issuance) as well. In the following we outline the constraints we see, a minimal viable incentive model, and pointers to further research questions we plan to solve by getting feedback from potential Vaults and Staked Relayers as well as quantitative modeling.


\section{Roles}
\label{\detokenize{economics/incentives:roles}}
We can classify four groups of users, or agents, in the BTC Parachain system. This is mainly based on their prior cryptocurrency holdings \sphinxhyphen{} namely BTC and DOT.


\subsection{Users}
\label{\detokenize{economics/incentives:users}}\begin{itemize}
\item {} 
\sphinxstylestrong{Protocol role} Users lock BTC with Vaults to create interbtc. They hold and/or use interbtc for payments, lending, or investment in financial products. At some point, users redeem interbtc for BTC by destroying the backed assets.

\item {} 
\sphinxstylestrong{Economics} A user holds BTC and has exposure to an exchange rate from BTC to other assets. A user’s incentives are based on the services (and their rewards) available when issuing interbtc.

\item {} 
\sphinxstylestrong{Risks} A user gives up custody over their BTC to a Vault. The Vault is over\sphinxhyphen{}collateralized in DOT (i.e., compared to the USD they will lose when taking away the user’s BTC), however, in a market crisis with significant price drops and liquidity shortages, Vaults might choose to keep the BTC. Users will be reimbursed with DOT in that case \sphinxhyphen{} not the currency they initially started out with.

\end{itemize}


\subsection{Vaults}
\label{\detokenize{economics/incentives:vaults}}\begin{itemize}
\item {} 
\sphinxstylestrong{Protocol role} Vaults lock up DOT collateral in the BTC Parachain and hold users’ BTC (i.e., receive custody). When users wish to redeem interbtc for BTC, Vaults release BTC to users according to the events received from the BTC Parachain.

\item {} 
\sphinxstylestrong{Economics} Vaults hold DOT and thus have exposure to the DOT price against other assets. Vaults inherently make a bet that DOT will increase in value against other assets \textendash{} otherwise they would simply exchange DOT against their preferred asset(s). This is a simplified view of the underlying problem. In reality, we need to additionally consider nominated vaults as well as vault pooling. Moreover, the inflation of DOT will play a major role in selection of the asset that fees should be paid in.

\item {} 
\sphinxstylestrong{Risks} A Vault backs a set of interbtc with DOT collateral. If the exchange rate of the DOT/BTC pair drops the Vault stands at risk to not be able to keep the required level of over\sphinxhyphen{}collateralization. This risk can be elevated by a shortage of liquidity.

\end{itemize}


\subsection{Staked Relayers}
\label{\detokenize{economics/incentives:staked-relayers}}\begin{itemize}
\item {} 
\sphinxstylestrong{Protocol role} Staked Relayers run Bitcoin full nodes and submit block headers to BTC\sphinxhyphen{}Relay, ensuring it remains up to date with Bitcoin’s state. They also report failures occurring on Bitcoin (missing transactional data or invalid blocks) and report misbehaving Vaults who have allegedly stolen BTC (move BTC outside of BTC Parachain constraints). Staked Relayers lock DOT as collateral to disincentivize false ﬂagging on Vaults and Bitcoin failures.

\item {} 
\sphinxstylestrong{Economics} Staked Relayers are exposed to similar mechanics as Vaults, since they also hold DOT. However, they have no direct exposure to the BTC/DOT exchange rate, since they (typically, at least as part of the BTC Parachain) do not hold BTC. As such, Staked Relayers can purely be motivated to earn interest on DOT, but can also have the option to earn interest in interbtc and optimize their holdings depending on the best possible return at any given time.

\item {} 
\sphinxstylestrong{Risks} Staked Relayers need to keep an up\sphinxhyphen{}to\sphinxhyphen{}date Bitcoin full node running to receive the latest blocks and be able to verify transaction availability and validity. They might risk voting on wrong status update proposals for the BTC Parachain if their node is being attacked, e.g. eclipse or DoS attacks.

\end{itemize}


\subsection{Collators}
\label{\detokenize{economics/incentives:collators}}\begin{itemize}
\item {} 
\sphinxstylestrong{Protocol role} Collators are full nodes on both a parachain and the Relay Chain. They collect parachain transactions and produce state transition proofs for the validators on the Relay Chain. They can also send and receive messages from other parachains using XCMP.

\item {} 
More on collators can be found in the Polkadot wiki: \sphinxurl{https://wiki.polkadot.network/docs/en/learn-collator\#docsNav}

\end{itemize}


\section{Processes}
\label{\detokenize{economics/incentives:processes}}
We will now explain how each of the four agent types above profits from participating in the BTC Parachain. Specifically, we sketch a typical interaction ﬂow with the BTC Parachain and explain how each agent type behaves.


\subsection{Issue process}
\label{\detokenize{economics/incentives:issue-process}}
The first step is to issue interbtc and give users access to other protocols.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A Vault locks an amount of DOT in the BTC Parachain.

\item {} 
A user requests to issue a certain amount of interbtc. A user can directly select a Vault to issue with. If the user does not select a Vault, a Vault is automatically selected with preference given to Vaults with higher SLA rating. In the first iteration of the protocol this selection is deterministic.

\item {} 
The user transfers the equivalent amount of BTC that he wants to issue to the Vault. Additionally, the user provides a fee in BTC that is locked with the Vault as well.

\item {} 
The user proves the transfer of BTC to the BTC Parachain and receives the requested amount of newly issued interbtc.

\item {} 
The fees paid by the users are issued as interbtc as well. They are forwarded to a general fee pool and distributed according to a configurable distribution to all Vaults, Staked Relayers, Maintainers, and Collators. This ensures that all participants earn on new issue requests, independent if their current collateral is already reserved or not.

\item {} 
The user can then freely use the issued interbtc to participate in any other protocol deployed on the BTC Parachain and connected Parachains.

\end{enumerate}


\subsection{Redeem process}
\label{\detokenize{economics/incentives:redeem-process}}
The BTC Parachain is intended to primarily incentivize users to issue interbtc and minimize friction to redeem BTC. Hence, the redeem process is structured in a simple way with providing the same incentives to all participating Vaults. Moreover, Vaults are punished for not fulfilling a redeem request in time.

A user can retry to redeem with other Vaults in case a redeem request is not fulfilled. In this case, the non\sphinxhyphen{}fulfilling Vault will be punished not by the entire BTC amount but rather by a smaller amount.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A user requests to redeem interbtc for BTC with a Vault and locks the equivalent amount of interbtc.

\item {} 
The Vault sends the BTC minus the globally defined fee to the user.

\item {} 
The fee is kept in interbtc and, equally to the issue process, paid into the fee pool to be distributed among all participants.

\item {} 
The Vault proves correct redeem with the BTC Parachain and unlocks the DOT collateral in return.

\item {} 
The Vault can decide to keep the DOT collateral in the BTC Parachain to participate in issue requests or withdraw the collateral.

\end{enumerate}


\subsection{interbtc interest process}
\label{\detokenize{economics/incentives:interbtc-interest-process}}
Fees paid in interbtc (on Issue, Redeem, and Replace) are forwarded to a fee pool.
The fee pool then distributes the interbtc fees to all Vaults, Staked Relayers, Maintainers, and Collators according to a configurable distribution, and, if implemented, depending on the SLA score.
All participants are able to withdraw their accumulated fees at any time.


\subsection{DOT interest process}
\label{\detokenize{economics/incentives:dot-interest-process}}
Fees paid in DOT are forwarded to a fee pool.
The fee pool then distributes the interbtc fees to all Vaults, Staked Relayers, Maintainers, and Collators according to a configurable distribution, and, if implemented, depending on the SLA score.
All participants are able to withdraw their accumulated fees at any time.


\subsection{Arbitrage}
\label{\detokenize{economics/incentives:arbitrage}}
After the issue process is completed a user can access any protocol deployed on Polkadot using interbtc. Not everyone that wants to obtain interbtc has to take this route. We imagine that liquidity providers issue interbtc and exchange these for other assets in the Polkadot ecosystem. The price of interbtc and BTC will hence be decoupled.

Price decoupling of BTC and interbtc, in turn, can be used by arbitrage traders. If interbtc trades relatively higher than BTC, arbitrage traders will seek to issue new interbtc with their existing BTC to sell interbtc at a higher market price. In case BTC trades above interbtc, arbitrageurs seek to redeem interbtc for BTC and trade these at a higher market price.


\section{Constraints}
\label{\detokenize{economics/incentives:constraints}}
We sketched above how each agent can be motivated to participate based on their incentive. However, determining the fee model, including how much a user should pay in BTC fees or the interest earned in DOT or interbtc by Vaults and Staked Relayers, requires careful consideration. These numbers depend on certain constraints than can be roughly categorized in two parts:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstylestrong{Inherent risks}: Each agent takes on different risks that include, for example, giving up custody of their BTC, exchange rate risk on the DOT/BTC pair, costs to maintain the infrastructure to operate Vault and Staked Relayer clients, as well as trusting the BTC Parachain to operate correctly and as designed.

\item {} 
\sphinxstylestrong{Opportunity costs}: Each agent might decide to take an alternative path to receive the desired incentives. For example, users might pick a different platform or bridge to utilize their BTC. Also Vaults, Staked Relayers, and Keepers might pick other protocols to earn interest on their DOT holdings.

\end{enumerate}

We provide an overview of the risks and alternatives for the agents in Table 1. When an agent is exposed to a high risk and has several alternatives, the agent needs to receive an accordingly high reward in return: if the risks and alternatives outweigh the incentives for an agent, the agent will not join the BTC Parachain. As seen in already deployed protocols including wBTC and pTokens, experiencing \textendash{} to this date \textendash{} insignificant volume, the balance of risks, alternatives, and incentives need to motivate agents to join.

\sphinxstyleemphasis{Table 1}: A subjective rating of the risks and alternatives for each agent. Risk ratings are from low to high. Alternatives ratings are also from low to high, where “high” indicates the existence of numerous viable alternatives, while “low“ indicates that the BTC Parachain is the dominant option on the market.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|l|l|p{0.3\linewidth}|l|p{0.3\linewidth}|}
\hline

Agent
&
Risk rating
&
Risks
&
Opportunity cost
&
Alternatives
\\
\hline
User
&
high
&
Counterparty (Vault, Staked Relayer), Technical risk (BTC Parachain), Market risks (DOT/BTC volatility and liquidity through Vault)
&
medium
&
wBTC, tBTC, RenVM, ChainX
\\
\hline
Vault
&
high
&
Counterparty (Staked Relayer), Technical risk (BTC Parachain, Vault client), Market risks (DOT/BTC volatility and liquidity)
&
high
&
Staking (relay chain, Parachains), Lending (Acala), Trading (Laminar)
\\
\hline
Staked Relayer
&
low
&
Technical risk (BTC Parachain, relayer client, Bitcoin client)
&
high
&
Staking (relay chain, Parachains), Lending (Acala), Trading (Laminar)
\\
\hline
Keeper
&
high
&
Counterparty (Staked Relayer), Technical risk (BTC Parachain, Vault and Keeper client), Market risks (DOT/BTC volatility and liquidity)
&
high
&
Staking (relay chain, Parachains), Lending (Acala), Trading (Laminar)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Fee Model}
\label{\detokenize{economics/fees:fee-model}}\label{\detokenize{economics/fees:id1}}\label{\detokenize{economics/fees::doc}}
We assume Vaults and Staked Relayer to be economically driven, i.e., following a strategy to maximize profits over time. While there may be altruistic actors, who follow protocol rules independent of the economic impact, we do not consider these here.

Byzantine actors aim to manipulate the system and cause damage to users \sphinxhyphen{} independent of the economic impact this has on them. To showcase how misbehavior impacts the fees earned by participants, we also consider byzantine behavior of Vaults and Staked Relayers in this analysis.


\section{Currencies}
\label{\detokenize{economics/fees:currencies}}
The BTC\sphinxhyphen{}Parachain features three assets:
\begin{itemize}
\item {} 
\sphinxtitleref{BTC} \sphinxhyphen{} the backing\sphinxhyphen{}asset (locked on Bitcoin)

\item {} 
\sphinxtitleref{interbtc} \sphinxhyphen{} the issued cryptocurrency\sphinxhyphen{}backed asset (on Polkadot)

\item {} 
\sphinxtitleref{DOT} \sphinxhyphen{} the currency used as collateral (\sphinxtitleref{DOT} used initially but may later be replaced with a stablecoin, currency\sphinxhyphen{}set, or similar)

\end{itemize}


\section{Actors: Income and Real/Opportunity Costs}
\label{\detokenize{economics/fees:actors-income-and-real-opportunity-costs}}
The main question when designing the fee model for interbtc is: When are fees paid, by whom, and how much?

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{taxable-actions}.png}
\caption{High\sphinxhyphen{}level overview of fee accrual in the BTC\sphinxhyphen{}Parachain (external sources only).}\label{\detokenize{economics/fees:id2}}\end{figure}

Below, we hence overview the income and cost sources for each actor/stakeholder in the BTC\sphinxhyphen{}Parachain.
Thereby, we differentiate between the following cost types:
\begin{itemize}
\item {} 
\sphinxstylestrong{Internal costs}: costs associated directly with the BTC\sphinxhyphen{}Parachain (i.e., inflow or internal flow of funds)

\item {} 
\sphinxstylestrong{External costs}: costs associated with external factors, such as node operation, engineering costs etc. (i.e., outflow of funds)

\item {} 
\sphinxstylestrong{Opportunity costs}: lost revenue, if e.g. locked up collateral was to be used in other applications (e.g. to stake on the Relay chain)

\end{itemize}


\subsection{Users}
\label{\detokenize{economics/fees:users}}\begin{itemize}
\item {} 
\sphinxstylestrong{Income}
\begin{itemize}
\item {} 
Slashed collateral

\item {} 
Use of interbtc in applications

\end{itemize}

\item {} 
\sphinxstylestrong{Internal Cost}
\begin{itemize}
\item {} 
Issue and redeem fees

\item {} 
BTC\sphinxhyphen{}Relay fees

\item {} 
Parachain transaction fees

\end{itemize}

\item {} 
\sphinxstylestrong{External Costs}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{None}

\end{itemize}

\item {} 
\sphinxstylestrong{Opportunity Cost}
\begin{itemize}
\item {} 
BTC lockup

\end{itemize}

\end{itemize}


\subsection{Vaults}
\label{\detokenize{economics/fees:vaults}}\begin{itemize}
\item {} 
\sphinxstylestrong{Income}
\begin{itemize}
\item {} 
Issue and redeem fees

\item {} 
SLA\sphinxhyphen{}based subsidy

\end{itemize}

\item {} 
\sphinxstylestrong{Internal Cost}
\begin{itemize}
\item {} 
BTC\sphinxhyphen{}Relay fee

\item {} 
Parachain transaction fees

\item {} 
(Upon failure: Slashed collateral)

\end{itemize}

\item {} 
\sphinxstylestrong{External Costs}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{None}

\end{itemize}

\item {} 
\sphinxstylestrong{Opportunity Cost}
\begin{itemize}
\item {} 
Backing\sphinxhyphen{}collateral lockup

\end{itemize}

\end{itemize}


\subsection{Staked Relayers}
\label{\detokenize{economics/fees:staked-relayers}}\begin{itemize}
\item {} 
\sphinxstylestrong{Income}
\begin{itemize}
\item {} 
SLA\sphinxhyphen{}based subsidy

\item {} 
BTC\sphinxhyphen{}Relay fees

\end{itemize}

\item {} 
\sphinxstylestrong{Internal Cost}
\begin{itemize}
\item {} 
Parachain transaction fees (offset against BTC\sphinxhyphen{}Relay fees)

\item {} 
(Upon failure: Slashed collateral)

\end{itemize}

\item {} 
\sphinxstylestrong{External Costs}
\begin{itemize}
\item {} 
Parachain node operation/maintenance costs

\item {} 
Bitcoin full node operation/maintenance costs

\end{itemize}

\item {} 
\sphinxstylestrong{Opportunity Cost}
\begin{itemize}
\item {} 
Staking\sphinxhyphen{}collateral lockup

\end{itemize}

\end{itemize}


\subsection{Collators}
\label{\detokenize{economics/fees:collators}}\begin{itemize}
\item {} 
\sphinxstylestrong{Income}
\begin{itemize}
\item {} 
Transaction fees

\item {} 
Parachain subsidy (SLA\sphinxhyphen{}based?)

\end{itemize}

\item {} 
\sphinxstylestrong{Internal Cost}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{None}

\end{itemize}

\item {} 
\sphinxstylestrong{External Costs}
\begin{itemize}
\item {} 
Parachain node operation/maintenance costs

\end{itemize}

\item {} 
\sphinxstylestrong{Opportunity Cost}
\begin{itemize}
\item {} 
Staking\sphinxhyphen{}collateral lockup

\end{itemize}

\end{itemize}


\subsection{Maintainers}
\label{\detokenize{economics/fees:maintainers}}\begin{itemize}
\item {} 
\sphinxstylestrong{Income}
\begin{itemize}
\item {} 
Parachain subsidy (revenue share)

\item {} 
Upgrade/extension/maintenance fee

\end{itemize}

\item {} 
\sphinxstylestrong{Internal Cost}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{None}

\end{itemize}

\item {} 
\sphinxstylestrong{External Costs}
\begin{itemize}
\item {} 
Server maintenance (UI, etc.)

\item {} 
Operational/developer costs

\end{itemize}

\item {} 
\sphinxstylestrong{Opportunity Cost}
\begin{itemize}
\item {} 
Other bridges

\end{itemize}

\end{itemize}


\section{Payment flows}
\label{\detokenize{economics/fees:payment-flows}}
We detail the payment flows in the figure below:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fee-payment-flows}.png}
\caption{Detailed overview of fee accrual in the BTC\sphinxhyphen{}Parachain, showing external and internal payment flows, as well as opportunity costs.}\label{\detokenize{economics/fees:id3}}\end{figure}


\section{Challenges Around Economic Efficiency}
\label{\detokenize{economics/fees:challenges-around-economic-efficiency}}
To ensure security of interbtc, i.e., that users never face financial damage, XCLAIM relies on collateral. However, in the current design, this leads to the following economic challenges:
\begin{itemize}
\item {} 
\sphinxstylestrong{Over\sphinxhyphen{}collateralization}. Vaults must lock up significantly (e.g. 200\%) more collateral than minted interbtc to ensure security against exchange rate fluctuations. Dynamically modifying the exchange rate could only marginally reduce this requirement, at a high computational overhead. As such, to issue 1 interbtc, one must lock up 1 BTC, as well as the 2 BTC worth of collateral (e.g. in DOT), resulting in a 300\% collateralization.

\item {} 
\sphinxstylestrong{Non\sphinxhyphen{}deterministic Collateral Lockup}. When a Vault locks collateral to secure interbtc, it does not know for how long this collateral will remain locked up. As such, it nearly impossible to determine a fair price for the premium charged to the user, without putting either the user or the Vault at a disadvantage.

\item {} 
\sphinxstylestrong{Limited Chargeable Events}. The Vault only has two events during which it can charge fees: (1) fulfillment of and issue request and (2) fulfillment of a redeem request. Thereby, the fees charged for the redeem request must be \sphinxstylestrong{upper\sphinxhyphen{}bounded} for security reasons (to prevent extortion by the Vault via sky\sphinxhyphen{}rocketing redeem fees).

\end{itemize}

As such, an open research question is:

\sphinxstyleemphasis{What is the value of a Vault’s locked collateral at any given point in time, considering the value of the collateral currency, the value of locked BTC, the value of interbtc (if different from BTC), as well as the projected earning from fees over time?}


\section{Subsidizing Vault Collateral Costs}
\label{\detokenize{economics/fees:subsidizing-vault-collateral-costs}}\begin{itemize}
\item {} 
\sphinxstylestrong{Higher user fees for issue/redeem} to ensure sufficiently good economic performance of Vaults to incentivize participation. Ideally, this would be combined with a supply/demand\sphinxhyphen{}based market for interbtc, driven by Parachains/applications on Polkadot (see below). The risk for (both) this model is that high fees may impede adoption if users revert to cheaper, yet centralized solutions.

\item {} 
\sphinxstylestrong{XCMP fees from other Parachains}. Charge Parachains additional fees for getting access to interbtc, creating an supply/demand\sphinxhyphen{}based market for interbtc access. The more demand for interbtc, the higher the market price, the more BTC will be locked to mint interbtc. However, this (i) impedes adoption by other Parachains and (ii) results in clear price deviations between interbtc and BTC in times of interbtc shortage. The latter may not be a bad thing per se, yet may have an unexpected effect for applications using interbtc.

\item {} 
\sphinxstylestrong{Polkadot treasury subsidy} to Vaults (and Staked Relayers) on a on a continuous basis, subject to correct operation / collateral usage, to account for the opportunity costs of the Vault accrued through locking up collateral.

\item {} 
\sphinxstylestrong{Governance token model}, where tokens are allocated to Vaults on a continuous basis, subject to correct operation / collateral usage. The token model, however, needs careful consideration and a clear use case (in addition to voting).

\item {} 
\sphinxstylestrong{On\sphinxhyphen{}demand collateral model via XCLAIM\sphinxhyphen{}Commit}, where Vaults lock up collateral only for short, deterministic periods and can hence compute an accurate fee model. In addition, users can request additional collateralization for specific periods and pay for collateral on demand. However, XCLAIM\sphinxhyphen{}Commit is still WIP and incurs stricter liveness requirements and a significantly more involved process for maintaining the secure 1:1 backing for Vaults.

\end{itemize}

Any of the above solutions can be implemented by themselves, or in combination \sphinxhyphen{} most likely, a mix of all will lead to the most well\sphinxhyphen{}balanced model.


\section{Other considerations}
\label{\detokenize{economics/fees:other-considerations}}\begin{itemize}
\item {} 
\sphinxstylestrong{Vault\sphinxhyphen{}User BTC Call Options / Perpetuals}: When a user locks BTC with the Vault, he implicitly sells a BTC call option to the Vault. The Vault can, at any point in time, decide to exercise this option by “stealing” the user’s BTC. The price for this option is determined by \sphinxstyleemphasis{spot\_price + punishment\_fee} (\sphinxstyleemphasis{punishment\_fee} is essentially the option premium). The main issue here is that we do not know how to price this option, because it has no expiry date \sphinxhyphen{} so this deal between the User and the Vault essentially becomes a \sphinxstylestrong{BTC perpetual that can be physically exercised at any point in time (American\sphinxhyphen{}style)}.

\end{itemize}


\chapter{Service Level Agreements}
\label{\detokenize{economics/SLA:service-level-agreements}}\label{\detokenize{economics/SLA:id1}}\label{\detokenize{economics/SLA::doc}}
Vaults and Staked Relayers take up critical roles in the BTC\sphinxhyphen{}Parachain. Both provide collateral, have clearly defined tasks and face punishment in case of misbehavior. However, slashing collateral for each minor protocol deviation would result in too high risk profiles for Vaults and Staked Relayers, yielding these roles unattractive to users.

As a result, we introduce Service Level Agreements for Vaults and Staked Relayers: being online and following protocol rules increases the SLA, while non\sphinxhyphen{}critical failures reduces the rating. Higher SLAs result in higher rewards and preferred treatment where applicable in the Issue and Redeem protocols. If the SLA of a Vault or Staked Relayer falls below a certain threshold, a punishment will be incurred, ranging from a mere collateral penalty up to full collateral confiscation and a system ban.


\section{SLA Value}
\label{\detokenize{economics/SLA:sla-value}}
The SLA value is a number between 0 and 100. When a Vault or Staked Relayer registers with BTC\sphinxhyphen{}Parachain, it starts with an SLA of 0.


\section{SLA Actions}
\label{\detokenize{economics/SLA:sla-actions}}
We list below several actions that Vaults and Staked Relayers can execute in the protocol that have an impact on their SLA.


\subsection{Vaults}
\label{\detokenize{economics/SLA:vaults}}

\subsubsection{Desired Actions}
\label{\detokenize{economics/SLA:desired-actions}}\begin{itemize}
\item {} 
\sphinxstylestrong{Execute Issue}: execute redeem, on time with the correct amount.

\item {} 
\sphinxstylestrong{Submit Issue Proof}: Vault submits correct Issue proof on behalf of the user.

\item {} 
\sphinxstylestrong{Forward Additional BTC}: Vault submits correct issue or return proof where the vault is the forwarding vault.

\end{itemize}


\subsubsection{Undesired Actions}
\label{\detokenize{economics/SLA:undesired-actions}}\begin{itemize}
\item {} 
\sphinxstylestrong{Fail Redeem}: redeem not executed on time (or at all) or with the incorrect amount (more specific: fail to provide inclusion proof for BTC payment to BTC\sphinxhyphen{}Relay on time)

\end{itemize}


\subsection{Staked Relayers}
\label{\detokenize{economics/SLA:staked-relayers}}

\subsubsection{Desired Actions}
\label{\detokenize{economics/SLA:id2}}\begin{itemize}
\item {} 
\sphinxstylestrong{Submit BTC block header}: submit a valid Bitcoin block header, that later becomes (\sphinxstylestrong{TODO:**define delay to not punish “good” fork submissions) part of the main chain.
\sphinxhyphen{} {[}Optional{]}: even if the block header already is stored, an additional confirmation is treated as beneficial action. This needs to be **time\sphinxhyphen{}bounded}. Otherwise, resubmitting old blocks allows to improve SLA, while adding no security and spamming the Parachain)

\item {} 
\sphinxstylestrong{Correctly report theft}: correctly report a Vault for moving BTC outside of the protocol rules (i.e., viewed as theft attempt).
\sphinxhyphen{} Note: TX inclusion proof must pass (TODO: check how this is currently implemented).

\end{itemize}


\subsubsection{Undesired Actions}
\label{\detokenize{economics/SLA:id3}}
No actions with SLA impact.


\section{Non\sphinxhyphen{}SLA Actions}
\label{\detokenize{economics/SLA:non-sla-actions}}
There are several other actions that do not impact the SLA scores at the moment.
For completeness, we list them here. The SLA model might be revised and the below actions may be considered to impact the SLA in the future.


\subsection{Vaults}
\label{\detokenize{economics/SLA:id4}}

\subsubsection{Desired Actions}
\label{\detokenize{economics/SLA:id5}}\begin{itemize}
\item {} 
\sphinxstylestrong{Execute Redeem}: execute redeem, on time with the correct amount.

\item {} 
\sphinxstylestrong{Collateralization}: Maintain a collateralization rate above the \sphinxstyleemphasis{Secure Collateral Threshold}.

\item {} 
\sphinxstylestrong{Execute Replace}: if requested replace, transfer the correct amount of BTC to the new Vault on time.

\end{itemize}


\subsubsection{Undesired Actions}
\label{\detokenize{economics/SLA:id6}}\begin{itemize}
\item {} 
\sphinxstylestrong{Fail Replace}: replace protocol (BTC transfer) not executed on time (or at all) or with the incorrect amount.

\item {} 
\sphinxstylestrong{Undercollateralization}: Collateralization rate below  \sphinxstyleemphasis{Secure Collateral Threshold}.

\item {} 
\sphinxstylestrong{Strong Undercollateralization}:  Collateralization rate below  \sphinxstyleemphasis{Premium Collateral Threshold}.

\item {} 
\sphinxstylestrong{Liquidation}:   Collateralization rate below  \sphinxstyleemphasis{Liquidation Collateral Threshold}, which triggers liquidation of the Vault.

\item {} 
\sphinxstylestrong{Theft}: the Vault transfers BTC from its UTXO(s) outside of the protocol rules. There is a dedicated check for this in the BTC\sphinxhyphen{}Parachain: only redeem, replace and registered migration of assets are allowed and these are clearly defined.

\item {} 
\sphinxstylestrong{Repeated Failed Redeem}: repeated failed redeem requests can incur a higher SLA deduction\#

\item {} 
\sphinxstylestrong{Repeated Failed Replace}: repeated failed replace requests can incur a higher SLA deduction

\end{itemize}


\subsection{Staked Relayers}
\label{\detokenize{economics/SLA:id7}}

\subsubsection{Desired Actions}
\label{\detokenize{economics/SLA:id8}}\begin{itemize}
\item {} 
\sphinxstylestrong{Correctly report NO\_DATA}: report/vote a block as NO\_DATA in case of a majority vote passed

\item {} 
\sphinxstylestrong{Correctly report INVALID}: report/vote a block as INVALID in case of a majority vote passed

\item {} 
\sphinxstylestrong{Correct report LIQUIDATION}: report a Vault for being below the \sphinxstyleemphasis{Liquidation Collateral Threshold} and trigger automatic liquidation.

\item {} 
\sphinxstylestrong{Correctly report ORACLE\_OFFLINE}: correctly report that the/an oracle has not reported data for a pre\sphinxhyphen{}defined amount of time (i.e., considered offline).

\item {} 
\sphinxstylestrong{Majority on status update vote}: participate in a status update vote on the \sphinxstylestrong{majority} side.
\sphinxhyphen{} Exception: NO\_DATA votes are rewarded no matter how the vote was cast. Reason: since NO\_DATA does not incur slashing of minority votes, being on the “majority” side must not yield additional benefits here, otherwise this incentivizes “herd” behavior without actually performing checks.

\end{itemize}


\subsubsection{Undesired Actions}
\label{\detokenize{economics/SLA:id9}}\begin{itemize}
\item {} 
\sphinxstylestrong{Ignore vote}: do not participate in a status update vote.

\item {} 
\sphinxstylestrong{Ignore NO\_DATA}: do note vote in a NO\_DATA vote at all.

\item {} 
\sphinxstylestrong{Ignore INVALID}: do note vote in an INVALID vote at all.

\item {} 
\sphinxstylestrong{Wrong INVALID report/vote}: report or vote on the \sphinxstylestrong{minority} (and persumably wrong side) of an INVALID vote

\item {} 
\sphinxstylestrong{Governance punishment}: the governance mechanism can reduce the SLA of a Vault (e.g. if majority did not vote INVALID, but there was indeed an invalid block, i.e. an attack)

\item {} 
{[}Optional{]} \sphinxstylestrong{Minority on status update vote}: vote on the \sphinxstylestrong{minority} side.
\sphinxhyphen{} Since this will also slash collateral in most cases, e.g. INVALID votes (exception: NO\_DATA), there may be no need for this extra SLA reduction.

\item {} 
{[}Optional{]} \sphinxstylestrong{Offline}: do not perform \sphinxstylestrong{any} of the desired actions within a certain time frame, while being registered. Time needs to be defined.

\item {} 
{[}Optional{]} \sphinxstylestrong{Wrong theft report}: report Vault theft but the BTC transaction turns out to be valid / according to protocol rules.
\sphinxhyphen{} If a such wrong call will automatically fail in the parachain, then there is probably no need for SLA reduction here.

\item {} 
{[}Optional{]} \sphinxstylestrong{Wrong ORCALE\_OFFLINE report}: oracle reported offline but was online. A such wrong call will fail in the parachain, so there is probably no need for SLA reduction here.

\item {} 
{[}Optional{]}: \sphinxstylestrong{Wrong LIQUIDATION report}: wrongly report a Vault for being below the \sphinxstyleemphasis{Liquidation Collateral Threshold}.  A such wrong call will fail in the parachain, so there is probably no need for SLA reduction here.

\end{itemize}


\chapter{License}
\label{\detokenize{other/license:license}}\label{\detokenize{other/license::doc}}
Copyright 2021 Interlay Ltd.

Licensed under the Apache License, Version 2.0 (the “License”);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
\begin{quote}

\sphinxurl{http://www.apache.org/licenses/LICENSE-2.0}
\end{quote}

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


\chapter{Interlay}
\label{\detokenize{other/interlay:interlay}}\label{\detokenize{other/interlay::doc}}
\sphinxhref{https://interlay.io}{Interlay} envisions a future where permissioned and permissionless blockchains, regardless of design and purpose, can seamlessly connect and interact. From DeFi loans to decentralized exchanges, from layer\sphinxhyphen{}2 protocols to application\sphinxhyphen{}specific ledgers: anyone should use any digital currency on any blockchain platform.

Interlay is co\sphinxhyphen{}founded by Imperial College London researchers \sphinxhref{https://alexeizamyatin.me}{Alexei Zamyatin}  and \sphinxhref{https://dominikharz.me}{Dominik Harz}, who have been contributing cutting edge research to the blockchain space for multiple years: from identifying centralization issues in merged mining, over off\sphinxhyphen{}chain computations and cross\sphinxhyphen{}chain bribing, to attacks against DeFi protocols.

Since the invention of XCLAIM in 2018, the team has been busy making the framework even more secure via more robust cryptographic primitives, scalable via payment channels and usable by reducing collateral requirements.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{Interlay_Logo}.png}
\end{figure}



\renewcommand{\indexname}{Index}
\printindex
\end{document}